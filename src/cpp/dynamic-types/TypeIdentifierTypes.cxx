// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TypeIdentifierTypes.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include <fastrtps/types/TypeIdentifierTypes.h>
#include <fastcdr/Cdr.h>
#include <fastrtps/types/TypeIdentifier.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


#define eprosima_fastrtps_types_PlainMapLTypeDefn_max_cdr_typesize 10ULL;






#define eprosima_fastrtps_types_PlainCollectionHeader_max_cdr_typesize 4ULL;
#define eprosima_fastrtps_types_PlainSequenceSElemDefn_max_cdr_typesize 5ULL;
#define eprosima_fastrtps_types_StringSTypeDefn_max_cdr_typesize 1ULL;

#define eprosima_fastrtps_types_PlainSequenceLElemDefn_max_cdr_typesize 8ULL;




#define eprosima_fastrtps_types_PlainArrayLElemDefn_max_cdr_typesize 408ULL;







#define eprosima_fastrtps_types_PlainArraySElemDefn_max_cdr_typesize 108ULL;




#define eprosima_fastrtps_types_PlainMapSTypeDefn_max_cdr_typesize 8ULL;


#define eprosima_fastrtps_types_ExtendedTypeDefn_max_cdr_typesize 0ULL;




#define eprosima_fastrtps_types_StringLTypeDefn_max_cdr_typesize 4ULL;
#define eprosima_fastrtps_types_StronglyConnectedComponentId_max_cdr_typesize 24ULL;




#define eprosima_fastrtps_types_PlainMapLTypeDefn_max_key_cdr_typesize 0ULL;






#define eprosima_fastrtps_types_PlainCollectionHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainSequenceSElemDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_StringSTypeDefn_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_PlainSequenceLElemDefn_max_key_cdr_typesize 0ULL;




#define eprosima_fastrtps_types_PlainArrayLElemDefn_max_key_cdr_typesize 0ULL;







#define eprosima_fastrtps_types_PlainArraySElemDefn_max_key_cdr_typesize 0ULL;




#define eprosima_fastrtps_types_PlainMapSTypeDefn_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_ExtendedTypeDefn_max_key_cdr_typesize 0ULL;




#define eprosima_fastrtps_types_StringLTypeDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_StronglyConnectedComponentId_max_key_cdr_typesize 0ULL;




eprosima::fastrtps::types::StringSTypeDefn::StringSTypeDefn()
{
    // eprosima::fastrtps::types::SBound m_bound
    m_bound = 0;

}

eprosima::fastrtps::types::StringSTypeDefn::~StringSTypeDefn()
{
}

eprosima::fastrtps::types::StringSTypeDefn::StringSTypeDefn(
        const StringSTypeDefn& x)
{
    m_bound = x.m_bound;
}

eprosima::fastrtps::types::StringSTypeDefn::StringSTypeDefn(
        StringSTypeDefn&& x) noexcept 
{
    m_bound = x.m_bound;
}

eprosima::fastrtps::types::StringSTypeDefn& eprosima::fastrtps::types::StringSTypeDefn::operator =(
        const StringSTypeDefn& x)
{

    m_bound = x.m_bound;

    return *this;
}

eprosima::fastrtps::types::StringSTypeDefn& eprosima::fastrtps::types::StringSTypeDefn::operator =(
        StringSTypeDefn&& x) noexcept
{

    m_bound = x.m_bound;

    return *this;
}

bool eprosima::fastrtps::types::StringSTypeDefn::operator ==(
        const StringSTypeDefn& x) const
{

    return (m_bound == x.m_bound);
}

bool eprosima::fastrtps::types::StringSTypeDefn::operator !=(
        const StringSTypeDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::StringSTypeDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_StringSTypeDefn_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::StringSTypeDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::StringSTypeDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::StringSTypeDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bound;

}

void eprosima::fastrtps::types::StringSTypeDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bound;
}

/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::StringSTypeDefn::bound(
        eprosima::fastrtps::types::SBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::SBound eprosima::fastrtps::types::StringSTypeDefn::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::SBound& eprosima::fastrtps::types::StringSTypeDefn::bound()
{
    return m_bound;
}



size_t eprosima::fastrtps::types::StringSTypeDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_StringSTypeDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::StringSTypeDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::StringSTypeDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::StringLTypeDefn::StringLTypeDefn()
{
    // eprosima::fastrtps::types::LBound m_bound
    m_bound = 0;

}

eprosima::fastrtps::types::StringLTypeDefn::~StringLTypeDefn()
{
}

eprosima::fastrtps::types::StringLTypeDefn::StringLTypeDefn(
        const StringLTypeDefn& x)
{
    m_bound = x.m_bound;
}

eprosima::fastrtps::types::StringLTypeDefn::StringLTypeDefn(
        StringLTypeDefn&& x) noexcept 
{
    m_bound = x.m_bound;
}

eprosima::fastrtps::types::StringLTypeDefn& eprosima::fastrtps::types::StringLTypeDefn::operator =(
        const StringLTypeDefn& x)
{

    m_bound = x.m_bound;

    return *this;
}

eprosima::fastrtps::types::StringLTypeDefn& eprosima::fastrtps::types::StringLTypeDefn::operator =(
        StringLTypeDefn&& x) noexcept
{

    m_bound = x.m_bound;

    return *this;
}

bool eprosima::fastrtps::types::StringLTypeDefn::operator ==(
        const StringLTypeDefn& x) const
{

    return (m_bound == x.m_bound);
}

bool eprosima::fastrtps::types::StringLTypeDefn::operator !=(
        const StringLTypeDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::StringLTypeDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_StringLTypeDefn_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::StringLTypeDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::StringLTypeDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::StringLTypeDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bound;

}

void eprosima::fastrtps::types::StringLTypeDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bound;
}

/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::StringLTypeDefn::bound(
        eprosima::fastrtps::types::LBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::LBound eprosima::fastrtps::types::StringLTypeDefn::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::LBound& eprosima::fastrtps::types::StringLTypeDefn::bound()
{
    return m_bound;
}



size_t eprosima::fastrtps::types::StringLTypeDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_StringLTypeDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::StringLTypeDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::StringLTypeDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainCollectionHeader::PlainCollectionHeader()
{
    // eprosima::fastrtps::types::EquivalenceKind m_equiv_kind
    m_equiv_kind = 0;
    // eprosima::fastrtps::types::CollectionElementFlag m_element_flags
    m_element_flags = static_cast<eprosima::fastrtps::types::CollectionElementFlag>(0);

}

eprosima::fastrtps::types::PlainCollectionHeader::~PlainCollectionHeader()
{


}

eprosima::fastrtps::types::PlainCollectionHeader::PlainCollectionHeader(
        const PlainCollectionHeader& x)
{
    m_equiv_kind = x.m_equiv_kind;
    m_element_flags = x.m_element_flags;
}

eprosima::fastrtps::types::PlainCollectionHeader::PlainCollectionHeader(
        PlainCollectionHeader&& x) noexcept 
{
    m_equiv_kind = x.m_equiv_kind;
    m_element_flags = x.m_element_flags;
}

eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainCollectionHeader::operator =(
        const PlainCollectionHeader& x)
{

    m_equiv_kind = x.m_equiv_kind;
    m_element_flags = x.m_element_flags;

    return *this;
}

eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainCollectionHeader::operator =(
        PlainCollectionHeader&& x) noexcept
{

    m_equiv_kind = x.m_equiv_kind;
    m_element_flags = x.m_element_flags;

    return *this;
}

bool eprosima::fastrtps::types::PlainCollectionHeader::operator ==(
        const PlainCollectionHeader& x) const
{

    return (m_equiv_kind == x.m_equiv_kind && m_element_flags == x.m_element_flags);
}

bool eprosima::fastrtps::types::PlainCollectionHeader::operator !=(
        const PlainCollectionHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainCollectionHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainCollectionHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainCollectionHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainCollectionHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_equiv_kind;
    scdr << (uint16_t)m_element_flags;

}

void eprosima::fastrtps::types::PlainCollectionHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_equiv_kind;
    uint16_t bitmask_value = 0;
    dcdr >> bitmask_value;
    m_element_flags = (eprosima::fastrtps::types::CollectionElementFlag)bitmask_value;
}

/*!
 * @brief This function sets a value in member equiv_kind
 * @param _equiv_kind New value for member equiv_kind
 */
void eprosima::fastrtps::types::PlainCollectionHeader::equiv_kind(
        eprosima::fastrtps::types::EquivalenceKind _equiv_kind)
{
    m_equiv_kind = _equiv_kind;
}

/*!
 * @brief This function returns the value of member equiv_kind
 * @return Value of member equiv_kind
 */
eprosima::fastrtps::types::EquivalenceKind eprosima::fastrtps::types::PlainCollectionHeader::equiv_kind() const
{
    return m_equiv_kind;
}

/*!
 * @brief This function returns a reference to member equiv_kind
 * @return Reference to member equiv_kind
 */
eprosima::fastrtps::types::EquivalenceKind& eprosima::fastrtps::types::PlainCollectionHeader::equiv_kind()
{
    return m_equiv_kind;
}

/*!
 * @brief This function sets a value in member element_flags
 * @param _element_flags New value for member element_flags
 */
void eprosima::fastrtps::types::PlainCollectionHeader::element_flags(
        eprosima::fastrtps::types::CollectionElementFlag _element_flags)
{
    m_element_flags = _element_flags;
}

/*!
 * @brief This function returns the value of member element_flags
 * @return Value of member element_flags
 */
eprosima::fastrtps::types::CollectionElementFlag eprosima::fastrtps::types::PlainCollectionHeader::element_flags() const
{
    return m_element_flags;
}

/*!
 * @brief This function returns a reference to member element_flags
 * @return Reference to member element_flags
 */
eprosima::fastrtps::types::CollectionElementFlag& eprosima::fastrtps::types::PlainCollectionHeader::element_flags()
{
    return m_element_flags;
}



size_t eprosima::fastrtps::types::PlainCollectionHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainCollectionHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainCollectionHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainCollectionHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainSequenceSElemDefn::PlainSequenceSElemDefn()
{
    // eprosima::fastrtps::types::PlainCollectionHeader m_header

    // eprosima::fastrtps::types::SBound m_bound
    m_bound = 0;

    // XTypes v1.3 Clauses 7.5.1.2.3.1 & 7.5.1.2.3.2: The constructor/initializer of the enclosing object shall set
    // the external member pointers to NULL. The behavior of the constructor shall be the same as specified for C.
    // eprosima::fastrtps::types::TypeIdentifier* m_element_identifier
    m_element_identifier = nullptr;

}

eprosima::fastrtps::types::PlainSequenceSElemDefn::~PlainSequenceSElemDefn()
{
    // XTypes v1.3 Clauses 7.5.1.2.3.1 & 7.5.1.2.3.2: The destructor of the enclosing object shall delete the objects
    // referenced by non-NULL external member pointers. The behavior of the destructor shall be the same as specified
    // for C.
    delete m_element_identifier;

}

eprosima::fastrtps::types::PlainSequenceSElemDefn::PlainSequenceSElemDefn(
        const PlainSequenceSElemDefn& x)
{
    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainSequenceSElemDefn::PlainSequenceSElemDefn(
        PlainSequenceSElemDefn&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

// XTypes v1.3 Clauses 7.5.1.2.3.1 & 7.5.1.2.3.2: The copy function of the enclosing object shall do a deep copy of the
// external members. If the destination external member is NULL it shall be allocated. If the destination external
// member is not NULL it shall be filled with a copy of the source member. If the copy operation of the external member
// fails, the the copy function of the containing object shall fail as well.
eprosima::fastrtps::types::PlainSequenceSElemDefn& eprosima::fastrtps::types::PlainSequenceSElemDefn::operator =(
        const PlainSequenceSElemDefn& x)
{

    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

eprosima::fastrtps::types::PlainSequenceSElemDefn& eprosima::fastrtps::types::PlainSequenceSElemDefn::operator =(
        PlainSequenceSElemDefn&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

bool eprosima::fastrtps::types::PlainSequenceSElemDefn::operator ==(
        const PlainSequenceSElemDefn& x) const
{

    return (m_header == x.m_header && m_bound == x.m_bound && *m_element_identifier == *x.m_element_identifier);
}

bool eprosima::fastrtps::types::PlainSequenceSElemDefn::operator !=(
        const PlainSequenceSElemDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainSequenceSElemDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
/* TODO(jlbueno): XTYPES
    size_t initial_alignment = current_alignment;
    size_t size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
*/
    return eprosima_fastrtps_types_PlainSequenceSElemDefn_max_cdr_typesize; // + current_alignment - initial_alignment;
}

size_t eprosima::fastrtps::types::PlainSequenceSElemDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainSequenceSElemDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    // XTypes v1.3 Clause 7.3.1.2.1.4 Unless also annotated as Optional, external members shall always be present and
    // therefore the pointer to non-optional external member cannot be NULL.
    if (data.element_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.element_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainSequenceSElemDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    if (m_element_identifier != nullptr)
    {
        scdr << m_header;
        scdr << m_bound;
        scdr << *m_element_identifier;
    }

}

void eprosima::fastrtps::types::PlainSequenceSElemDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_bound;
    if (m_element_identifier == nullptr)
    {
        m_element_identifier = new TypeIdentifier();
    }
    dcdr >> *m_element_identifier;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::PlainSequenceSElemDefn::header(
        const eprosima::fastrtps::types::PlainCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::PlainSequenceSElemDefn::header(
        eprosima::fastrtps::types::PlainCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainSequenceSElemDefn::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainSequenceSElemDefn::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::PlainSequenceSElemDefn::bound(
        eprosima::fastrtps::types::SBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::SBound eprosima::fastrtps::types::PlainSequenceSElemDefn::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::SBound& eprosima::fastrtps::types::PlainSequenceSElemDefn::bound()
{
    return m_bound;
}

void eprosima::fastrtps::types::PlainSequenceSElemDefn::element_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _element_identifier)
{
    if (_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainSequenceSElemDefn::element_identifier() const
{
    return m_element_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainSequenceSElemDefn::element_identifier()
{
    return m_element_identifier;
}

size_t eprosima::fastrtps::types::PlainSequenceSElemDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainSequenceSElemDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainSequenceSElemDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainSequenceSElemDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainSequenceLElemDefn::PlainSequenceLElemDefn()
{
    // eprosima::fastrtps::types::PlainCollectionHeader m_header

    // eprosima::fastrtps::types::LBound m_bound
    m_bound = 0;
    m_element_identifier = nullptr;

}

eprosima::fastrtps::types::PlainSequenceLElemDefn::~PlainSequenceLElemDefn()
{
    delete m_element_identifier;

}

eprosima::fastrtps::types::PlainSequenceLElemDefn::PlainSequenceLElemDefn(
        const PlainSequenceLElemDefn& x)
{
    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainSequenceLElemDefn::PlainSequenceLElemDefn(
        PlainSequenceLElemDefn&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainSequenceLElemDefn& eprosima::fastrtps::types::PlainSequenceLElemDefn::operator =(
        const PlainSequenceLElemDefn& x)
{

    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

eprosima::fastrtps::types::PlainSequenceLElemDefn& eprosima::fastrtps::types::PlainSequenceLElemDefn::operator =(
        PlainSequenceLElemDefn&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

bool eprosima::fastrtps::types::PlainSequenceLElemDefn::operator ==(
        const PlainSequenceLElemDefn& x) const
{

    return (m_header == x.m_header && m_bound == x.m_bound && *m_element_identifier == *x.m_element_identifier);
}

bool eprosima::fastrtps::types::PlainSequenceLElemDefn::operator !=(
        const PlainSequenceLElemDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainSequenceLElemDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
/* TODO(jlbueno): XTYPES
    size_t initial_alignment = current_alignment;
    size_t size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
*/
    return eprosima_fastrtps_types_PlainSequenceLElemDefn_max_cdr_typesize; // + current_alignment - initial_alignment;
}

size_t eprosima::fastrtps::types::PlainSequenceLElemDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainSequenceLElemDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    if (data.element_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.element_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainSequenceLElemDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    if (m_element_identifier != nullptr)
    {
        scdr << m_header;
        scdr << m_bound;
        scdr << *m_element_identifier;
    }

}

void eprosima::fastrtps::types::PlainSequenceLElemDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_bound;
    if (m_element_identifier == nullptr)
    {
        m_element_identifier = new TypeIdentifier();
    }
    dcdr >> *m_element_identifier;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::PlainSequenceLElemDefn::header(
        const eprosima::fastrtps::types::PlainCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::PlainSequenceLElemDefn::header(
        eprosima::fastrtps::types::PlainCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainSequenceLElemDefn::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainSequenceLElemDefn::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::PlainSequenceLElemDefn::bound(
        eprosima::fastrtps::types::LBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::LBound eprosima::fastrtps::types::PlainSequenceLElemDefn::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::LBound& eprosima::fastrtps::types::PlainSequenceLElemDefn::bound()
{
    return m_bound;
}

void eprosima::fastrtps::types::PlainSequenceLElemDefn::element_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _element_identifier)
{
    if (_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainSequenceLElemDefn::element_identifier() const
{
    return m_element_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainSequenceLElemDefn::element_identifier()
{
    return m_element_identifier;
}


size_t eprosima::fastrtps::types::PlainSequenceLElemDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainSequenceLElemDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainSequenceLElemDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainSequenceLElemDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainArraySElemDefn::PlainArraySElemDefn()
{
    // eprosima::fastrtps::types::PlainCollectionHeader m_header

    // eprosima::fastrtps::types::SBoundSeq m_array_bound_seq
    m_element_identifier = nullptr;

}

eprosima::fastrtps::types::PlainArraySElemDefn::~PlainArraySElemDefn()
{
    delete m_element_identifier;

}

eprosima::fastrtps::types::PlainArraySElemDefn::PlainArraySElemDefn(
        const PlainArraySElemDefn& x)
{
    m_header = x.m_header;
    m_array_bound_seq = x.m_array_bound_seq;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainArraySElemDefn::PlainArraySElemDefn(
        PlainArraySElemDefn&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_array_bound_seq = std::move(x.m_array_bound_seq);
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainArraySElemDefn& eprosima::fastrtps::types::PlainArraySElemDefn::operator =(
        const PlainArraySElemDefn& x)
{

    m_header = x.m_header;
    m_array_bound_seq = x.m_array_bound_seq;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

eprosima::fastrtps::types::PlainArraySElemDefn& eprosima::fastrtps::types::PlainArraySElemDefn::operator =(
        PlainArraySElemDefn&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_array_bound_seq = std::move(x.m_array_bound_seq);
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

bool eprosima::fastrtps::types::PlainArraySElemDefn::operator ==(
        const PlainArraySElemDefn& x) const
{

    return (m_header == x.m_header && m_array_bound_seq == x.m_array_bound_seq
            && *m_element_identifier == *x.m_element_identifier);
}

bool eprosima::fastrtps::types::PlainArraySElemDefn::operator !=(
        const PlainArraySElemDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainArraySElemDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
/* TODO(jlbueno): XTYPES
    size_t initial_alignment = current_alignment;
    size_t size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
*/
    return eprosima_fastrtps_types_PlainArraySElemDefn_max_cdr_typesize; // + current_alignment - initial_alignment;
}

size_t eprosima::fastrtps::types::PlainArraySElemDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainArraySElemDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.array_bound_seq().size() > 0)
    {
        current_alignment += (data.array_bound_seq().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }

    if (data.element_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.element_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainArraySElemDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    if (m_element_identifier != nullptr)
    {
        scdr << m_header;
        scdr << m_array_bound_seq;
        scdr << *m_element_identifier;
    }
}

void eprosima::fastrtps::types::PlainArraySElemDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_array_bound_seq;
    if (m_element_identifier == nullptr)
    {
        m_element_identifier = new TypeIdentifier();
    }
    dcdr >> *m_element_identifier;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::PlainArraySElemDefn::header(
        const eprosima::fastrtps::types::PlainCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::PlainArraySElemDefn::header(
        eprosima::fastrtps::types::PlainCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainArraySElemDefn::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainArraySElemDefn::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member array_bound_seq
 * @param _array_bound_seq New value to be copied in member array_bound_seq
 */
void eprosima::fastrtps::types::PlainArraySElemDefn::array_bound_seq(
        const eprosima::fastrtps::types::SBoundSeq& _array_bound_seq)
{
    m_array_bound_seq = _array_bound_seq;
}

/*!
 * @brief This function moves the value in member array_bound_seq
 * @param _array_bound_seq New value to be moved in member array_bound_seq
 */
void eprosima::fastrtps::types::PlainArraySElemDefn::array_bound_seq(
        eprosima::fastrtps::types::SBoundSeq&& _array_bound_seq)
{
    m_array_bound_seq = std::move(_array_bound_seq);
}

/*!
 * @brief This function returns a constant reference to member array_bound_seq
 * @return Constant reference to member array_bound_seq
 */
const eprosima::fastrtps::types::SBoundSeq& eprosima::fastrtps::types::PlainArraySElemDefn::array_bound_seq() const
{
    return m_array_bound_seq;
}

/*!
 * @brief This function returns a reference to member array_bound_seq
 * @return Reference to member array_bound_seq
 */
eprosima::fastrtps::types::SBoundSeq& eprosima::fastrtps::types::PlainArraySElemDefn::array_bound_seq()
{
    return m_array_bound_seq;
}

void eprosima::fastrtps::types::PlainArraySElemDefn::element_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _element_identifier)
{
    if (_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainArraySElemDefn::element_identifier() const
{
    return m_element_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainArraySElemDefn::element_identifier()
{
    return m_element_identifier;
}

size_t eprosima::fastrtps::types::PlainArraySElemDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainArraySElemDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainArraySElemDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainArraySElemDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainArrayLElemDefn::PlainArrayLElemDefn()
{
    // eprosima::fastrtps::types::PlainCollectionHeader m_header

    // eprosima::fastrtps::types::LBoundSeq m_array_bound_seq
    m_element_identifier = nullptr;

}

eprosima::fastrtps::types::PlainArrayLElemDefn::~PlainArrayLElemDefn()
{
    delete m_element_identifier;

}

eprosima::fastrtps::types::PlainArrayLElemDefn::PlainArrayLElemDefn(
        const PlainArrayLElemDefn& x)
{
    m_header = x.m_header;
    m_array_bound_seq = x.m_array_bound_seq;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainArrayLElemDefn::PlainArrayLElemDefn(
        PlainArrayLElemDefn&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_array_bound_seq = std::move(x.m_array_bound_seq);
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainArrayLElemDefn& eprosima::fastrtps::types::PlainArrayLElemDefn::operator =(
        const PlainArrayLElemDefn& x)
{

    m_header = x.m_header;
    m_array_bound_seq = x.m_array_bound_seq;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

eprosima::fastrtps::types::PlainArrayLElemDefn& eprosima::fastrtps::types::PlainArrayLElemDefn::operator =(
        PlainArrayLElemDefn&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_array_bound_seq = std::move(x.m_array_bound_seq);
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }

    return *this;
}

bool eprosima::fastrtps::types::PlainArrayLElemDefn::operator ==(
        const PlainArrayLElemDefn& x) const
{

    return (m_header == x.m_header && m_array_bound_seq == x.m_array_bound_seq
            && *m_element_identifier == *x.m_element_identifier);
}

bool eprosima::fastrtps::types::PlainArrayLElemDefn::operator !=(
        const PlainArrayLElemDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainArrayLElemDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
/* TODO(jlbueno): XTYPES
    size_t initial_alignment = current_alignment;
    size_t size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
*/
    return eprosima_fastrtps_types_PlainArrayLElemDefn_max_cdr_typesize; // + current_alignment - initial_alignment;
}

size_t eprosima::fastrtps::types::PlainArrayLElemDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainArrayLElemDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.array_bound_seq().size() > 0)
    {
        current_alignment += (data.array_bound_seq().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }

    if (data.element_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.element_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainArrayLElemDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    if (m_element_identifier != nullptr)
    {
        scdr << m_header;
        scdr << m_array_bound_seq;
        scdr << *m_element_identifier;
    }

}

void eprosima::fastrtps::types::PlainArrayLElemDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_array_bound_seq;
    if (m_element_identifier == nullptr)
    {
        m_element_identifier = new TypeIdentifier();
    }
    dcdr >> *m_element_identifier;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::PlainArrayLElemDefn::header(
        const eprosima::fastrtps::types::PlainCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::PlainArrayLElemDefn::header(
        eprosima::fastrtps::types::PlainCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainArrayLElemDefn::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainArrayLElemDefn::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member array_bound_seq
 * @param _array_bound_seq New value to be copied in member array_bound_seq
 */
void eprosima::fastrtps::types::PlainArrayLElemDefn::array_bound_seq(
        const eprosima::fastrtps::types::LBoundSeq& _array_bound_seq)
{
    m_array_bound_seq = _array_bound_seq;
}

/*!
 * @brief This function moves the value in member array_bound_seq
 * @param _array_bound_seq New value to be moved in member array_bound_seq
 */
void eprosima::fastrtps::types::PlainArrayLElemDefn::array_bound_seq(
        eprosima::fastrtps::types::LBoundSeq&& _array_bound_seq)
{
    m_array_bound_seq = std::move(_array_bound_seq);
}

/*!
 * @brief This function returns a constant reference to member array_bound_seq
 * @return Constant reference to member array_bound_seq
 */
const eprosima::fastrtps::types::LBoundSeq& eprosima::fastrtps::types::PlainArrayLElemDefn::array_bound_seq() const
{
    return m_array_bound_seq;
}

/*!
 * @brief This function returns a reference to member array_bound_seq
 * @return Reference to member array_bound_seq
 */
eprosima::fastrtps::types::LBoundSeq& eprosima::fastrtps::types::PlainArrayLElemDefn::array_bound_seq()
{
    return m_array_bound_seq;
}

void eprosima::fastrtps::types::PlainArrayLElemDefn::element_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _element_identifier)
{
    if (_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainArrayLElemDefn::element_identifier() const
{
    return m_element_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainArrayLElemDefn::element_identifier()
{
    return m_element_identifier;
}


size_t eprosima::fastrtps::types::PlainArrayLElemDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainArrayLElemDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainArrayLElemDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainArrayLElemDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainMapSTypeDefn::PlainMapSTypeDefn()
{
    // eprosima::fastrtps::types::PlainCollectionHeader m_header

    // eprosima::fastrtps::types::SBound m_bound
    m_bound = 0;
    m_element_identifier = nullptr;
    // eprosima::fastrtps::types::CollectionElementFlag m_key_flags
    m_key_flags = static_cast<eprosima::fastrtps::types::CollectionElementFlag>(0);
    m_key_identifier = nullptr;

}

eprosima::fastrtps::types::PlainMapSTypeDefn::~PlainMapSTypeDefn()
{
    delete m_element_identifier;
    delete m_key_identifier;

}

eprosima::fastrtps::types::PlainMapSTypeDefn::PlainMapSTypeDefn(
        const PlainMapSTypeDefn& x)
{
    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        m_key_identifier = new TypeIdentifier();
        *m_key_identifier = *x.m_key_identifier;
    }
    else
    {
        m_key_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainMapSTypeDefn::PlainMapSTypeDefn(
        PlainMapSTypeDefn&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        m_key_identifier = new TypeIdentifier();
        *m_key_identifier = std::move(*x.m_key_identifier);
    }
    else
    {
        m_key_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainMapSTypeDefn& eprosima::fastrtps::types::PlainMapSTypeDefn::operator =(
        const PlainMapSTypeDefn& x)
{

    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        if (m_key_identifier == nullptr)
        {
            m_key_identifier = new TypeIdentifier();
        }
        *m_key_identifier = *x.m_key_identifier;
    }
    else
    {
        delete m_key_identifier;
        m_key_identifier = nullptr;
    }

    return *this;
}

eprosima::fastrtps::types::PlainMapSTypeDefn& eprosima::fastrtps::types::PlainMapSTypeDefn::operator =(
        PlainMapSTypeDefn&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        if (m_key_identifier == nullptr)
        {
            m_key_identifier = new TypeIdentifier();
        }
        *m_key_identifier = std::move(*x.m_key_identifier);
    }
    else
    {
        delete m_key_identifier;
        m_key_identifier = nullptr;
    }

    return *this;
}

bool eprosima::fastrtps::types::PlainMapSTypeDefn::operator ==(
        const PlainMapSTypeDefn& x) const
{

    return (m_header == x.m_header && m_bound == x.m_bound && *m_element_identifier == *x.m_element_identifier
            && m_key_flags == x.m_key_flags && *m_key_identifier == *x.m_key_identifier);
}

bool eprosima::fastrtps::types::PlainMapSTypeDefn::operator !=(
        const PlainMapSTypeDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainMapSTypeDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
/* TODO(jlbueno): XTYPES
    size_t initial_alignment = current_alignment;
    size_t size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
*/
    return eprosima_fastrtps_types_PlainMapSTypeDefn_max_cdr_typesize; // + current_alignment - initial_alignment;
}

size_t eprosima::fastrtps::types::PlainMapSTypeDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainMapSTypeDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    if (data.element_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.element_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    if (data.key_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.key_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainMapSTypeDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    if (m_element_identifier != nullptr && m_key_identifier != nullptr)
    {
        scdr << m_header;
        scdr << m_bound;
        scdr << *m_element_identifier;
        scdr << (uint16_t)m_key_flags;
        scdr << *m_key_identifier;
    }

}

void eprosima::fastrtps::types::PlainMapSTypeDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_bound;
    if (m_element_identifier == nullptr)
    {
        m_element_identifier = new TypeIdentifier();
    }
    dcdr >> *m_element_identifier;
    uint16_t bitmask_value = 0;
    dcdr >> bitmask_value;
    m_key_flags = (eprosima::fastrtps::types::CollectionElementFlag)bitmask_value;
    if (m_key_identifier == nullptr)
    {
        m_key_identifier = new TypeIdentifier();
    }
    dcdr >> *m_key_identifier;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::PlainMapSTypeDefn::header(
        const eprosima::fastrtps::types::PlainCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::PlainMapSTypeDefn::header(
        eprosima::fastrtps::types::PlainCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainMapSTypeDefn::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainMapSTypeDefn::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::PlainMapSTypeDefn::bound(
        eprosima::fastrtps::types::SBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::SBound eprosima::fastrtps::types::PlainMapSTypeDefn::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::SBound& eprosima::fastrtps::types::PlainMapSTypeDefn::bound()
{
    return m_bound;
}

void eprosima::fastrtps::types::PlainMapSTypeDefn::element_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _element_identifier)
{
    if (_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainMapSTypeDefn::element_identifier() const
{
    return m_element_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainMapSTypeDefn::element_identifier()
{
    return m_element_identifier;
}

/*!
 * @brief This function sets a value in member key_flags
 * @param _key_flags New value for member key_flags
 */
void eprosima::fastrtps::types::PlainMapSTypeDefn::key_flags(
        eprosima::fastrtps::types::CollectionElementFlag _key_flags)
{
    m_key_flags = _key_flags;
}

/*!
 * @brief This function returns the value of member key_flags
 * @return Value of member key_flags
 */
eprosima::fastrtps::types::CollectionElementFlag eprosima::fastrtps::types::PlainMapSTypeDefn::key_flags() const
{
    return m_key_flags;
}

/*!
 * @brief This function returns a reference to member key_flags
 * @return Reference to member key_flags
 */
eprosima::fastrtps::types::CollectionElementFlag& eprosima::fastrtps::types::PlainMapSTypeDefn::key_flags()
{
    return m_key_flags;
}

void eprosima::fastrtps::types::PlainMapSTypeDefn::key_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _key_identifier)
{
    if (_key_identifier != nullptr)
    {
        if (m_key_identifier == nullptr)
        {
            m_key_identifier = new TypeIdentifier();
        }
        *m_key_identifier = *_key_identifier;
    }
    else
    {
        delete m_key_identifier;
        m_key_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainMapSTypeDefn::key_identifier() const
{
    return m_key_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainMapSTypeDefn::key_identifier()
{
    return m_key_identifier;
}


size_t eprosima::fastrtps::types::PlainMapSTypeDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainMapSTypeDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainMapSTypeDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainMapSTypeDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::PlainMapLTypeDefn::PlainMapLTypeDefn()
{
    // eprosima::fastrtps::types::PlainCollectionHeader m_header

    // eprosima::fastrtps::types::LBound m_bound
    m_bound = 0;
    m_element_identifier = nullptr;
    // eprosima::fastrtps::types::CollectionElementFlag m_key_flags
    m_key_flags = static_cast<eprosima::fastrtps::types::CollectionElementFlag>(0);
    m_key_identifier = nullptr;

}

eprosima::fastrtps::types::PlainMapLTypeDefn::~PlainMapLTypeDefn()
{
    delete m_element_identifier;
    delete m_key_identifier;

}

eprosima::fastrtps::types::PlainMapLTypeDefn::PlainMapLTypeDefn(
        const PlainMapLTypeDefn& x)
{
    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        m_key_identifier = new TypeIdentifier();
        *m_key_identifier = *x.m_key_identifier;
    }
    else
    {
        m_key_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainMapLTypeDefn::PlainMapLTypeDefn(
        PlainMapLTypeDefn&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        m_element_identifier = new TypeIdentifier();
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        m_key_identifier = new TypeIdentifier();
        *m_key_identifier = std::move(*x.m_key_identifier);
    }
    else
    {
        m_key_identifier = nullptr;
    }
}

eprosima::fastrtps::types::PlainMapLTypeDefn& eprosima::fastrtps::types::PlainMapLTypeDefn::operator =(
        const PlainMapLTypeDefn& x)
{

    m_header = x.m_header;
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *x.m_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        if (m_key_identifier == nullptr)
        {
            m_key_identifier = new TypeIdentifier();
        }
        *m_key_identifier = *x.m_key_identifier;
    }
    else
    {
        delete m_key_identifier;
        m_key_identifier = nullptr;
    }

    return *this;
}

eprosima::fastrtps::types::PlainMapLTypeDefn& eprosima::fastrtps::types::PlainMapLTypeDefn::operator =(
        PlainMapLTypeDefn&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_bound = x.m_bound;
    if (x.m_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = std::move(*x.m_element_identifier);
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
    m_key_flags = x.m_key_flags;
    if (x.m_key_identifier != nullptr)
    {
        if (m_key_identifier == nullptr)
        {
            m_key_identifier = new TypeIdentifier();
        }
        *m_key_identifier = std::move(*x.m_key_identifier);
    }
    else
    {
        delete m_key_identifier;
        m_key_identifier = nullptr;
    }

    return *this;
}

bool eprosima::fastrtps::types::PlainMapLTypeDefn::operator ==(
        const PlainMapLTypeDefn& x) const
{

    return (m_header == x.m_header && m_bound == x.m_bound && *m_element_identifier == *x.m_element_identifier
            && m_key_flags == x.m_key_flags && *m_key_identifier == *x.m_key_identifier);
}

bool eprosima::fastrtps::types::PlainMapLTypeDefn::operator !=(
        const PlainMapLTypeDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::PlainMapLTypeDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
/* TODO(jlbueno): XTYPES
    size_t initial_alignment = current_alignment;
    size_t size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    size = TypeIdentifier::getMaxCdrSerializedSize(current_alignment);
    current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
*/
    return eprosima_fastrtps_types_PlainMapLTypeDefn_max_cdr_typesize; // + current_alignment - initial_alignment;
}

size_t eprosima::fastrtps::types::PlainMapLTypeDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::PlainMapLTypeDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::PlainCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    if (data.element_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.element_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    if (data.key_identifier() != nullptr)
    {
        size_t size = TypeIdentifier::getCdrSerializedSize(*data.key_identifier(), current_alignment);
        current_alignment += size + eprosima::fastcdr::Cdr::alignment(current_alignment, size);
    }
    else
    {
        return initial_alignment;
    }


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::PlainMapLTypeDefn::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    if (m_element_identifier != nullptr && m_key_identifier != nullptr)
    {
        scdr << m_header;
        scdr << m_bound;
        scdr << *m_element_identifier;
        scdr << (uint16_t)m_key_flags;
        scdr << *m_key_identifier;
    }

}

void eprosima::fastrtps::types::PlainMapLTypeDefn::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_bound;
    if (m_element_identifier == nullptr)
    {
        m_element_identifier = new TypeIdentifier();
    }
    dcdr >> *m_element_identifier;
    uint16_t bitmask_value = 0;
    dcdr >> bitmask_value;
    m_key_flags = (eprosima::fastrtps::types::CollectionElementFlag)bitmask_value;
    if (m_key_identifier == nullptr)
    {
        m_key_identifier = new TypeIdentifier();
    }
    dcdr >> *m_key_identifier;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::PlainMapLTypeDefn::header(
        const eprosima::fastrtps::types::PlainCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::PlainMapLTypeDefn::header(
        eprosima::fastrtps::types::PlainCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainMapLTypeDefn::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::PlainCollectionHeader& eprosima::fastrtps::types::PlainMapLTypeDefn::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::PlainMapLTypeDefn::bound(
        eprosima::fastrtps::types::LBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::LBound eprosima::fastrtps::types::PlainMapLTypeDefn::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::LBound& eprosima::fastrtps::types::PlainMapLTypeDefn::bound()
{
    return m_bound;
}

void eprosima::fastrtps::types::PlainMapLTypeDefn::element_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _element_identifier)
{
    if (_element_identifier != nullptr)
    {
        if (m_element_identifier == nullptr)
        {
            m_element_identifier = new TypeIdentifier();
        }
        *m_element_identifier = *_element_identifier;
    }
    else
    {
        delete m_element_identifier;
        m_element_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainMapLTypeDefn::element_identifier() const
{
    return m_element_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainMapLTypeDefn::element_identifier()
{
    return m_element_identifier;
}

/*!
 * @brief This function sets a value in member key_flags
 * @param _key_flags New value for member key_flags
 */
void eprosima::fastrtps::types::PlainMapLTypeDefn::key_flags(
        eprosima::fastrtps::types::CollectionElementFlag _key_flags)
{
    m_key_flags = _key_flags;
}

/*!
 * @brief This function returns the value of member key_flags
 * @return Value of member key_flags
 */
eprosima::fastrtps::types::CollectionElementFlag eprosima::fastrtps::types::PlainMapLTypeDefn::key_flags() const
{
    return m_key_flags;
}

/*!
 * @brief This function returns a reference to member key_flags
 * @return Reference to member key_flags
 */
eprosima::fastrtps::types::CollectionElementFlag& eprosima::fastrtps::types::PlainMapLTypeDefn::key_flags()
{
    return m_key_flags;
}

void eprosima::fastrtps::types::PlainMapLTypeDefn::key_identifier(
        const eprosima::fastrtps::types::TypeIdentifier* _key_identifier)
{
    if (_key_identifier != nullptr)
    {
        if (m_key_identifier == nullptr)
        {
            m_key_identifier = new TypeIdentifier();
        }
        *m_key_identifier = *_key_identifier;
    }
    else
    {
        delete m_key_identifier;
        m_key_identifier = nullptr;
    }
}

eprosima::fastrtps::types::TypeIdentifier* eprosima::fastrtps::types::PlainMapLTypeDefn::key_identifier() const
{
    return m_key_identifier;
}

eprosima::fastrtps::types::TypeIdentifier*& eprosima::fastrtps::types::PlainMapLTypeDefn::key_identifier()
{
    return m_key_identifier;
}


size_t eprosima::fastrtps::types::PlainMapLTypeDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_PlainMapLTypeDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::PlainMapLTypeDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::PlainMapLTypeDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::StronglyConnectedComponentId::StronglyConnectedComponentId()
{
    // eprosima::fastrtps::types::TypeObjectHashId m_sc_component_id

    // long m_scc_length
    m_scc_length = 0;
    // long m_scc_index
    m_scc_index = 0;

}

eprosima::fastrtps::types::StronglyConnectedComponentId::~StronglyConnectedComponentId()
{



}

eprosima::fastrtps::types::StronglyConnectedComponentId::StronglyConnectedComponentId(
        const StronglyConnectedComponentId& x)
{
    m_sc_component_id = x.m_sc_component_id;
    m_scc_length = x.m_scc_length;
    m_scc_index = x.m_scc_index;
}

eprosima::fastrtps::types::StronglyConnectedComponentId::StronglyConnectedComponentId(
        StronglyConnectedComponentId&& x) noexcept 
{
    m_sc_component_id = std::move(x.m_sc_component_id);
    m_scc_length = x.m_scc_length;
    m_scc_index = x.m_scc_index;
}

eprosima::fastrtps::types::StronglyConnectedComponentId& eprosima::fastrtps::types::StronglyConnectedComponentId::operator =(
        const StronglyConnectedComponentId& x)
{

    m_sc_component_id = x.m_sc_component_id;
    m_scc_length = x.m_scc_length;
    m_scc_index = x.m_scc_index;

    return *this;
}

eprosima::fastrtps::types::StronglyConnectedComponentId& eprosima::fastrtps::types::StronglyConnectedComponentId::operator =(
        StronglyConnectedComponentId&& x) noexcept
{

    m_sc_component_id = std::move(x.m_sc_component_id);
    m_scc_length = x.m_scc_length;
    m_scc_index = x.m_scc_index;

    return *this;
}

bool eprosima::fastrtps::types::StronglyConnectedComponentId::operator ==(
        const StronglyConnectedComponentId& x) const
{

    return (m_sc_component_id == x.m_sc_component_id && m_scc_length == x.m_scc_length && m_scc_index == x.m_scc_index);
}

bool eprosima::fastrtps::types::StronglyConnectedComponentId::operator !=(
        const StronglyConnectedComponentId& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::StronglyConnectedComponentId::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_StronglyConnectedComponentId_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::StronglyConnectedComponentId::getCdrSerializedSize(
        const eprosima::fastrtps::types::StronglyConnectedComponentId& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeObjectHashId::getCdrSerializedSize(data.sc_component_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::StronglyConnectedComponentId::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sc_component_id;
    scdr << m_scc_length;
    scdr << m_scc_index;

}

void eprosima::fastrtps::types::StronglyConnectedComponentId::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sc_component_id;
    dcdr >> m_scc_length;
    dcdr >> m_scc_index;
}

/*!
 * @brief This function copies the value in member sc_component_id
 * @param _sc_component_id New value to be copied in member sc_component_id
 */
void eprosima::fastrtps::types::StronglyConnectedComponentId::sc_component_id(
        const eprosima::fastrtps::types::TypeObjectHashId& _sc_component_id)
{
    m_sc_component_id = _sc_component_id;
}

/*!
 * @brief This function moves the value in member sc_component_id
 * @param _sc_component_id New value to be moved in member sc_component_id
 */
void eprosima::fastrtps::types::StronglyConnectedComponentId::sc_component_id(
        eprosima::fastrtps::types::TypeObjectHashId&& _sc_component_id)
{
    m_sc_component_id = std::move(_sc_component_id);
}

/*!
 * @brief This function returns a constant reference to member sc_component_id
 * @return Constant reference to member sc_component_id
 */
const eprosima::fastrtps::types::TypeObjectHashId& eprosima::fastrtps::types::StronglyConnectedComponentId::sc_component_id() const
{
    return m_sc_component_id;
}

/*!
 * @brief This function returns a reference to member sc_component_id
 * @return Reference to member sc_component_id
 */
eprosima::fastrtps::types::TypeObjectHashId& eprosima::fastrtps::types::StronglyConnectedComponentId::sc_component_id()
{
    return m_sc_component_id;
}
/*!
 * @brief This function sets a value in member scc_length
 * @param _scc_length New value for member scc_length
 */
void eprosima::fastrtps::types::StronglyConnectedComponentId::scc_length(
        int32_t _scc_length)
{
    m_scc_length = _scc_length;
}

/*!
 * @brief This function returns the value of member scc_length
 * @return Value of member scc_length
 */
int32_t eprosima::fastrtps::types::StronglyConnectedComponentId::scc_length() const
{
    return m_scc_length;
}

/*!
 * @brief This function returns a reference to member scc_length
 * @return Reference to member scc_length
 */
int32_t& eprosima::fastrtps::types::StronglyConnectedComponentId::scc_length()
{
    return m_scc_length;
}

/*!
 * @brief This function sets a value in member scc_index
 * @param _scc_index New value for member scc_index
 */
void eprosima::fastrtps::types::StronglyConnectedComponentId::scc_index(
        int32_t _scc_index)
{
    m_scc_index = _scc_index;
}

/*!
 * @brief This function returns the value of member scc_index
 * @return Value of member scc_index
 */
int32_t eprosima::fastrtps::types::StronglyConnectedComponentId::scc_index() const
{
    return m_scc_index;
}

/*!
 * @brief This function returns a reference to member scc_index
 * @return Reference to member scc_index
 */
int32_t& eprosima::fastrtps::types::StronglyConnectedComponentId::scc_index()
{
    return m_scc_index;
}



size_t eprosima::fastrtps::types::StronglyConnectedComponentId::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_StronglyConnectedComponentId_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::StronglyConnectedComponentId::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::StronglyConnectedComponentId::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::ExtendedTypeDefn::ExtendedTypeDefn()
{

}

eprosima::fastrtps::types::ExtendedTypeDefn::~ExtendedTypeDefn()
{
}

eprosima::fastrtps::types::ExtendedTypeDefn::ExtendedTypeDefn(
        const ExtendedTypeDefn& /*x*/)
{
}

eprosima::fastrtps::types::ExtendedTypeDefn::ExtendedTypeDefn(
        ExtendedTypeDefn&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::ExtendedTypeDefn& eprosima::fastrtps::types::ExtendedTypeDefn::operator =(
        const ExtendedTypeDefn& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::ExtendedTypeDefn& eprosima::fastrtps::types::ExtendedTypeDefn::operator =(
        ExtendedTypeDefn&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::ExtendedTypeDefn::operator ==(
        const ExtendedTypeDefn& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::ExtendedTypeDefn::operator !=(
        const ExtendedTypeDefn& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::ExtendedTypeDefn::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_ExtendedTypeDefn_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::ExtendedTypeDefn::getCdrSerializedSize(
        const eprosima::fastrtps::types::ExtendedTypeDefn& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::ExtendedTypeDefn::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::ExtendedTypeDefn::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::ExtendedTypeDefn::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_ExtendedTypeDefn_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::ExtendedTypeDefn::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::ExtendedTypeDefn::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}




