// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file AnnotationParameterValue.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>





#define eprosima_fastrtps_types_PlainCollectionHeader_max_cdr_typesize 4ULL;


#define eprosima_fastrtps_types_ExtendedAnnotationParameterValue_max_cdr_typesize 0ULL;


















#define eprosima_fastrtps_types_StronglyConnectedComponentId_max_cdr_typesize 24ULL;

#define eprosima_fastrtps_types_AppliedVerbatimAnnotation_max_cdr_typesize 340ULL;
#define eprosima_fastrtps_types_AppliedBuiltinMemberAnnotations_max_cdr_typesize 1560ULL;






#define eprosima_fastrtps_types_StringSTypeDefn_max_cdr_typesize 1ULL;
#define eprosima_fastrtps_types_AppliedAnnotationParameter_max_cdr_typesize 524ULL;



#define eprosima_fastrtps_types_ExtendedTypeDefn_max_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_StringLTypeDefn_max_cdr_typesize 4ULL;







#define eprosima_fastrtps_types_PlainCollectionHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainSequenceSElemDefn_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_ExtendedAnnotationParameterValue_max_key_cdr_typesize 0ULL;










#define eprosima_fastrtps_types_PlainArraySElemDefn_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_PlainMapSTypeDefn_max_key_cdr_typesize 0ULL;






#define eprosima_fastrtps_types_StronglyConnectedComponentId_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_AppliedVerbatimAnnotation_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_AppliedBuiltinMemberAnnotations_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_PlainMapLTypeDefn_max_key_cdr_typesize 0ULL;



#define eprosima_fastrtps_types_AppliedAnnotation_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_StringSTypeDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainSequenceLElemDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_AppliedAnnotationParameter_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_PlainArrayLElemDefn_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_ExtendedTypeDefn_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_StringLTypeDefn_max_key_cdr_typesize 0ULL;







eprosima::fastrtps::types::ExtendedAnnotationParameterValue::ExtendedAnnotationParameterValue()
{

}

eprosima::fastrtps::types::ExtendedAnnotationParameterValue::~ExtendedAnnotationParameterValue()
{
}

eprosima::fastrtps::types::ExtendedAnnotationParameterValue::ExtendedAnnotationParameterValue(
        const ExtendedAnnotationParameterValue& /*x*/)
{
}

eprosima::fastrtps::types::ExtendedAnnotationParameterValue::ExtendedAnnotationParameterValue(
        ExtendedAnnotationParameterValue&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::ExtendedAnnotationParameterValue& eprosima::fastrtps::types::ExtendedAnnotationParameterValue::operator =(
        const ExtendedAnnotationParameterValue& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::ExtendedAnnotationParameterValue& eprosima::fastrtps::types::ExtendedAnnotationParameterValue::operator =(
        ExtendedAnnotationParameterValue&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::ExtendedAnnotationParameterValue::operator ==(
        const ExtendedAnnotationParameterValue& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::ExtendedAnnotationParameterValue::operator !=(
        const ExtendedAnnotationParameterValue& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::ExtendedAnnotationParameterValue::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_ExtendedAnnotationParameterValue_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::ExtendedAnnotationParameterValue::getCdrSerializedSize(
        const eprosima::fastrtps::types::ExtendedAnnotationParameterValue& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::ExtendedAnnotationParameterValue::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::ExtendedAnnotationParameterValue::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::ExtendedAnnotationParameterValue::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_ExtendedAnnotationParameterValue_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::ExtendedAnnotationParameterValue::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::ExtendedAnnotationParameterValue::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::AnnotationParameterValue::AnnotationParameterValue()
{
    m__d = 0;
    // boolean m_boolean_value
    m_boolean_value = false;
    // octet m_byte_value
    m_byte_value = 0;
    // int8 m_int8_value
    m_int8_value = 0;
    // uint8 m_uint8_value
    m_uint8_value = 0;
    // short m_int16_value
    m_int16_value = 0;
    // unsigned short m_uint16_value
    m_uint16_value = 0;
    // long m_int32_value
    m_int32_value = 0;
    // unsigned long m_uint32_value
    m_uint32_value = 0;
    // long long m_int64_value
    m_int64_value = 0;
    // unsigned long long m_uint64_value
    m_uint64_value = 0;
    // float m_float32_value
    m_float32_value = 0.0;
    // double m_float64_value
    m_float64_value = 0.0;
    // long double m_float128_value
    m_float128_value = 0.0;
    // char m_char_value
    m_char_value = 0;
    // wchar m_wchar_value
    m_wchar_value = 0;
    // long m_enumerated_value
    m_enumerated_value = 0;
    // string m_string8_value
    m_string8_value ="";
    // wstring m_string16_value

    // eprosima::fastrtps::types::ExtendedAnnotationParameterValue m_extended_value

}

eprosima::fastrtps::types::AnnotationParameterValue::~AnnotationParameterValue()
{
}

eprosima::fastrtps::types::AnnotationParameterValue::AnnotationParameterValue(
        const AnnotationParameterValue& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_BOOLEAN:
        m_boolean_value = x.m_boolean_value;
        break;
        case TK_BYTE:
        m_byte_value = x.m_byte_value;
        break;
        case TK_INT8:
        m_int8_value = x.m_int8_value;
        break;
        case TK_UINT8:
        m_uint8_value = x.m_uint8_value;
        break;
        case TK_INT16:
        m_int16_value = x.m_int16_value;
        break;
        case TK_UINT16:
        m_uint16_value = x.m_uint16_value;
        break;
        case TK_INT32:
        m_int32_value = x.m_int32_value;
        break;
        case TK_UINT32:
        m_uint32_value = x.m_uint32_value;
        break;
        case TK_INT64:
        m_int64_value = x.m_int64_value;
        break;
        case TK_UINT64:
        m_uint64_value = x.m_uint64_value;
        break;
        case TK_FLOAT32:
        m_float32_value = x.m_float32_value;
        break;
        case TK_FLOAT64:
        m_float64_value = x.m_float64_value;
        break;
        case TK_FLOAT128:
        m_float128_value = x.m_float128_value;
        break;
        case TK_CHAR8:
        m_char_value = x.m_char_value;
        break;
        case TK_CHAR16:
        m_wchar_value = x.m_wchar_value;
        break;
        case TK_ENUM:
        m_enumerated_value = x.m_enumerated_value;
        break;
        case TK_STRING8:
        m_string8_value = x.m_string8_value;
        break;
        case TK_STRING16:
        m_string16_value = x.m_string16_value;
        break;

        default:
        m_extended_value = x.m_extended_value;
        break;
    }
}

eprosima::fastrtps::types::AnnotationParameterValue::AnnotationParameterValue(
        AnnotationParameterValue&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_BOOLEAN:
        m_boolean_value = x.m_boolean_value;
        break;
        case TK_BYTE:
        m_byte_value = x.m_byte_value;
        break;
        case TK_INT8:
        m_int8_value = x.m_int8_value;
        break;
        case TK_UINT8:
        m_uint8_value = x.m_uint8_value;
        break;
        case TK_INT16:
        m_int16_value = x.m_int16_value;
        break;
        case TK_UINT16:
        m_uint16_value = x.m_uint16_value;
        break;
        case TK_INT32:
        m_int32_value = x.m_int32_value;
        break;
        case TK_UINT32:
        m_uint32_value = x.m_uint32_value;
        break;
        case TK_INT64:
        m_int64_value = x.m_int64_value;
        break;
        case TK_UINT64:
        m_uint64_value = x.m_uint64_value;
        break;
        case TK_FLOAT32:
        m_float32_value = x.m_float32_value;
        break;
        case TK_FLOAT64:
        m_float64_value = x.m_float64_value;
        break;
        case TK_FLOAT128:
        m_float128_value = x.m_float128_value;
        break;
        case TK_CHAR8:
        m_char_value = x.m_char_value;
        break;
        case TK_CHAR16:
        m_wchar_value = x.m_wchar_value;
        break;
        case TK_ENUM:
        m_enumerated_value = x.m_enumerated_value;
        break;
        case TK_STRING8:
        m_string8_value = std::move(x.m_string8_value);
        break;
        case TK_STRING16:
        m_string16_value = std::move(x.m_string16_value);
        break;

        default:
        m_extended_value = std::move(x.m_extended_value);
        break;
    }
}

eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AnnotationParameterValue::operator =(
        const AnnotationParameterValue& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_BOOLEAN:
        m_boolean_value = x.m_boolean_value;
        break;
        case TK_BYTE:
        m_byte_value = x.m_byte_value;
        break;
        case TK_INT8:
        m_int8_value = x.m_int8_value;
        break;
        case TK_UINT8:
        m_uint8_value = x.m_uint8_value;
        break;
        case TK_INT16:
        m_int16_value = x.m_int16_value;
        break;
        case TK_UINT16:
        m_uint16_value = x.m_uint16_value;
        break;
        case TK_INT32:
        m_int32_value = x.m_int32_value;
        break;
        case TK_UINT32:
        m_uint32_value = x.m_uint32_value;
        break;
        case TK_INT64:
        m_int64_value = x.m_int64_value;
        break;
        case TK_UINT64:
        m_uint64_value = x.m_uint64_value;
        break;
        case TK_FLOAT32:
        m_float32_value = x.m_float32_value;
        break;
        case TK_FLOAT64:
        m_float64_value = x.m_float64_value;
        break;
        case TK_FLOAT128:
        m_float128_value = x.m_float128_value;
        break;
        case TK_CHAR8:
        m_char_value = x.m_char_value;
        break;
        case TK_CHAR16:
        m_wchar_value = x.m_wchar_value;
        break;
        case TK_ENUM:
        m_enumerated_value = x.m_enumerated_value;
        break;
        case TK_STRING8:
        m_string8_value = x.m_string8_value;
        break;
        case TK_STRING16:
        m_string16_value = x.m_string16_value;
        break;

        default:
        m_extended_value = x.m_extended_value;
        break;
    }

    return *this;
}

eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AnnotationParameterValue::operator =(
        AnnotationParameterValue&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_BOOLEAN:
        m_boolean_value = x.m_boolean_value;
        break;
        case TK_BYTE:
        m_byte_value = x.m_byte_value;
        break;
        case TK_INT8:
        m_int8_value = x.m_int8_value;
        break;
        case TK_UINT8:
        m_uint8_value = x.m_uint8_value;
        break;
        case TK_INT16:
        m_int16_value = x.m_int16_value;
        break;
        case TK_UINT16:
        m_uint16_value = x.m_uint16_value;
        break;
        case TK_INT32:
        m_int32_value = x.m_int32_value;
        break;
        case TK_UINT32:
        m_uint32_value = x.m_uint32_value;
        break;
        case TK_INT64:
        m_int64_value = x.m_int64_value;
        break;
        case TK_UINT64:
        m_uint64_value = x.m_uint64_value;
        break;
        case TK_FLOAT32:
        m_float32_value = x.m_float32_value;
        break;
        case TK_FLOAT64:
        m_float64_value = x.m_float64_value;
        break;
        case TK_FLOAT128:
        m_float128_value = x.m_float128_value;
        break;
        case TK_CHAR8:
        m_char_value = x.m_char_value;
        break;
        case TK_CHAR16:
        m_wchar_value = x.m_wchar_value;
        break;
        case TK_ENUM:
        m_enumerated_value = x.m_enumerated_value;
        break;
        case TK_STRING8:
        m_string8_value = std::move(x.m_string8_value);
        break;
        case TK_STRING16:
        m_string16_value = std::move(x.m_string16_value);
        break;

        default:
        m_extended_value = std::move(x.m_extended_value);
        break;
    }

    return *this;
}

bool eprosima::fastrtps::types::AnnotationParameterValue::operator ==(
        const AnnotationParameterValue& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case TK_BOOLEAN:
            return (m_boolean_value == x.m_boolean_value);
            break;
        case TK_BYTE:
            return (m_byte_value == x.m_byte_value);
            break;
        case TK_INT8:
            return (m_int8_value == x.m_int8_value);
            break;
        case TK_UINT8:
            return (m_uint8_value == x.m_uint8_value);
            break;
        case TK_INT16:
            return (m_int16_value == x.m_int16_value);
            break;
        case TK_UINT16:
            return (m_uint16_value == x.m_uint16_value);
            break;
        case TK_INT32:
            return (m_int32_value == x.m_int32_value);
            break;
        case TK_UINT32:
            return (m_uint32_value == x.m_uint32_value);
            break;
        case TK_INT64:
            return (m_int64_value == x.m_int64_value);
            break;
        case TK_UINT64:
            return (m_uint64_value == x.m_uint64_value);
            break;
        case TK_FLOAT32:
            return (m_float32_value == x.m_float32_value);
            break;
        case TK_FLOAT64:
            return (m_float64_value == x.m_float64_value);
            break;
        case TK_FLOAT128:
            return (m_float128_value == x.m_float128_value);
            break;
        case TK_CHAR8:
            return (m_char_value == x.m_char_value);
            break;
        case TK_CHAR16:
            return (m_wchar_value == x.m_wchar_value);
            break;
        case TK_ENUM:
            return (m_enumerated_value == x.m_enumerated_value);
            break;
        case TK_STRING8:
            return (m_string8_value == x.m_string8_value);
            break;
        case TK_STRING16:
            return (m_string16_value == x.m_string16_value);
            break;

        default:
        return m_extended_value == x.m_extended_value;
        break;
    }
    return false;
}

bool eprosima::fastrtps::types::AnnotationParameterValue::operator !=(
        const AnnotationParameterValue& x) const
{
    return !(*this == x);
}

void eprosima::fastrtps::types::AnnotationParameterValue::_d(
        uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case TK_BOOLEAN:
        switch(__d)
        {
            case TK_BOOLEAN:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_BYTE:
        switch(__d)
        {
            case TK_BYTE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_INT8:
        switch(__d)
        {
            case TK_INT8:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_UINT8:
        switch(__d)
        {
            case TK_UINT8:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_INT16:
        switch(__d)
        {
            case TK_INT16:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_UINT16:
        switch(__d)
        {
            case TK_UINT16:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_INT32:
        switch(__d)
        {
            case TK_INT32:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_UINT32:
        switch(__d)
        {
            case TK_UINT32:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_INT64:
        switch(__d)
        {
            case TK_INT64:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_UINT64:
        switch(__d)
        {
            case TK_UINT64:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_FLOAT32:
        switch(__d)
        {
            case TK_FLOAT32:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_FLOAT64:
        switch(__d)
        {
            case TK_FLOAT64:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_FLOAT128:
        switch(__d)
        {
            case TK_FLOAT128:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_CHAR8:
        switch(__d)
        {
            case TK_CHAR8:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_CHAR16:
        switch(__d)
        {
            case TK_CHAR16:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ENUM:
        switch(__d)
        {
            case TK_ENUM:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_STRING8:
        switch(__d)
        {
            case TK_STRING8:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_STRING16:
        switch(__d)
        {
            case TK_STRING16:
            b = true;
            break;
            default:
            break;
        }
        break;
        default:
        b = true;
        switch(__d)
        {
            case TK_BOOLEAN:
            case TK_BYTE:
            case TK_INT8:
            case TK_UINT8:
            case TK_INT16:
            case TK_UINT16:
            case TK_INT32:
            case TK_UINT32:
            case TK_INT64:
            case TK_UINT64:
            case TK_FLOAT32:
            case TK_FLOAT64:
            case TK_FLOAT128:
            case TK_CHAR8:
            case TK_CHAR16:
            case TK_ENUM:
            case TK_STRING8:
            case TK_STRING16:
            b = false;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t eprosima::fastrtps::types::AnnotationParameterValue::_d() const
{
    return m__d;
}

uint8_t& eprosima::fastrtps::types::AnnotationParameterValue::_d()
{
    return m__d;
}

void eprosima::fastrtps::types::AnnotationParameterValue::boolean_value(
        bool _boolean_value)
{
    m_boolean_value = _boolean_value;
    m__d = TK_BOOLEAN;
}

bool eprosima::fastrtps::types::AnnotationParameterValue::boolean_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_BOOLEAN:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_boolean_value;
}

bool& eprosima::fastrtps::types::AnnotationParameterValue::boolean_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_BOOLEAN:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_boolean_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::byte_value(
        uint8_t _byte_value)
{
    m_byte_value = _byte_value;
    m__d = TK_BYTE;
}

uint8_t eprosima::fastrtps::types::AnnotationParameterValue::byte_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_BYTE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_byte_value;
}

uint8_t& eprosima::fastrtps::types::AnnotationParameterValue::byte_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_BYTE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_byte_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::int8_value(
        int8_t _int8_value)
{
    m_int8_value = _int8_value;
    m__d = TK_INT8;
}

int8_t eprosima::fastrtps::types::AnnotationParameterValue::int8_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int8_value;
}

int8_t& eprosima::fastrtps::types::AnnotationParameterValue::int8_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int8_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::uint8_value(
        uint8_t _uint8_value)
{
    m_uint8_value = _uint8_value;
    m__d = TK_UINT8;
}

uint8_t eprosima::fastrtps::types::AnnotationParameterValue::uint8_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint8_value;
}

uint8_t& eprosima::fastrtps::types::AnnotationParameterValue::uint8_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint8_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::int16_value(
        int16_t _int16_value)
{
    m_int16_value = _int16_value;
    m__d = TK_INT16;
}

int16_t eprosima::fastrtps::types::AnnotationParameterValue::int16_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int16_value;
}

int16_t& eprosima::fastrtps::types::AnnotationParameterValue::int16_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int16_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::uint16_value(
        uint16_t _uint16_value)
{
    m_uint16_value = _uint16_value;
    m__d = TK_UINT16;
}

uint16_t eprosima::fastrtps::types::AnnotationParameterValue::uint16_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint16_value;
}

uint16_t& eprosima::fastrtps::types::AnnotationParameterValue::uint16_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint16_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::int32_value(
        int32_t _int32_value)
{
    m_int32_value = _int32_value;
    m__d = TK_INT32;
}

int32_t eprosima::fastrtps::types::AnnotationParameterValue::int32_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT32:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int32_value;
}

int32_t& eprosima::fastrtps::types::AnnotationParameterValue::int32_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT32:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int32_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::uint32_value(
        uint32_t _uint32_value)
{
    m_uint32_value = _uint32_value;
    m__d = TK_UINT32;
}

uint32_t eprosima::fastrtps::types::AnnotationParameterValue::uint32_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT32:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint32_value;
}

uint32_t& eprosima::fastrtps::types::AnnotationParameterValue::uint32_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT32:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint32_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::int64_value(
        int64_t _int64_value)
{
    m_int64_value = _int64_value;
    m__d = TK_INT64;
}

int64_t eprosima::fastrtps::types::AnnotationParameterValue::int64_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT64:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int64_value;
}

int64_t& eprosima::fastrtps::types::AnnotationParameterValue::int64_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_INT64:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_int64_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::uint64_value(
        uint64_t _uint64_value)
{
    m_uint64_value = _uint64_value;
    m__d = TK_UINT64;
}

uint64_t eprosima::fastrtps::types::AnnotationParameterValue::uint64_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT64:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint64_value;
}

uint64_t& eprosima::fastrtps::types::AnnotationParameterValue::uint64_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_UINT64:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint64_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::float32_value(
        float _float32_value)
{
    m_float32_value = _float32_value;
    m__d = TK_FLOAT32;
}

float eprosima::fastrtps::types::AnnotationParameterValue::float32_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_FLOAT32:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float32_value;
}

float& eprosima::fastrtps::types::AnnotationParameterValue::float32_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_FLOAT32:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float32_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::float64_value(
        double _float64_value)
{
    m_float64_value = _float64_value;
    m__d = TK_FLOAT64;
}

double eprosima::fastrtps::types::AnnotationParameterValue::float64_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_FLOAT64:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float64_value;
}

double& eprosima::fastrtps::types::AnnotationParameterValue::float64_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_FLOAT64:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float64_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::float128_value(
        long double _float128_value)
{
    m_float128_value = _float128_value;
    m__d = TK_FLOAT128;
}

long double eprosima::fastrtps::types::AnnotationParameterValue::float128_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_FLOAT128:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float128_value;
}

long double& eprosima::fastrtps::types::AnnotationParameterValue::float128_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_FLOAT128:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float128_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::char_value(
        char _char_value)
{
    m_char_value = _char_value;
    m__d = TK_CHAR8;
}

char eprosima::fastrtps::types::AnnotationParameterValue::char_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_CHAR8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_char_value;
}

char& eprosima::fastrtps::types::AnnotationParameterValue::char_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_CHAR8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_char_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::wchar_value(
        wchar_t _wchar_value)
{
    m_wchar_value = _wchar_value;
    m__d = TK_CHAR16;
}

wchar_t eprosima::fastrtps::types::AnnotationParameterValue::wchar_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_CHAR16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_wchar_value;
}

wchar_t& eprosima::fastrtps::types::AnnotationParameterValue::wchar_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_CHAR16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_wchar_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::enumerated_value(
        int32_t _enumerated_value)
{
    m_enumerated_value = _enumerated_value;
    m__d = TK_ENUM;
}

int32_t eprosima::fastrtps::types::AnnotationParameterValue::enumerated_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ENUM:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_enumerated_value;
}

int32_t& eprosima::fastrtps::types::AnnotationParameterValue::enumerated_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ENUM:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_enumerated_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::string8_value(
        const eprosima::fastrtps::fixed_string<128>& _string8_value)
{
    m_string8_value = _string8_value;
    m__d = TK_STRING8;
}

void eprosima::fastrtps::types::AnnotationParameterValue::string8_value(
        eprosima::fastrtps::fixed_string<128>&& _string8_value)
{
    m_string8_value = std::move(_string8_value);
    m__d = TK_STRING8;
}

const eprosima::fastrtps::fixed_string<128>& eprosima::fastrtps::types::AnnotationParameterValue::string8_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRING8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_string8_value;
}

eprosima::fastrtps::fixed_string<128>& eprosima::fastrtps::types::AnnotationParameterValue::string8_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRING8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_string8_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::string16_value(
        const std::wstring& _string16_value)
{
    m_string16_value = _string16_value;
    m__d = TK_STRING16;
}

void eprosima::fastrtps::types::AnnotationParameterValue::string16_value(
        std::wstring&& _string16_value)
{
    m_string16_value = std::move(_string16_value);
    m__d = TK_STRING16;
}

const std::wstring& eprosima::fastrtps::types::AnnotationParameterValue::string16_value() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRING16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_string16_value;
}

std::wstring& eprosima::fastrtps::types::AnnotationParameterValue::string16_value()
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRING16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_string16_value;
}
void eprosima::fastrtps::types::AnnotationParameterValue::extended_value(
        const eprosima::fastrtps::types::ExtendedAnnotationParameterValue& _extended_value)
{
    m_extended_value = _extended_value;
    m__d = 0;
}

void eprosima::fastrtps::types::AnnotationParameterValue::extended_value(
        eprosima::fastrtps::types::ExtendedAnnotationParameterValue&& _extended_value)
{
    m_extended_value = std::move(_extended_value);
    m__d = 0;
}

const eprosima::fastrtps::types::ExtendedAnnotationParameterValue& eprosima::fastrtps::types::AnnotationParameterValue::extended_value() const
{
    bool b = true;

    switch(m__d)
    {
        case TK_BOOLEAN:
        case TK_BYTE:
        case TK_INT8:
        case TK_UINT8:
        case TK_INT16:
        case TK_UINT16:
        case TK_INT32:
        case TK_UINT32:
        case TK_INT64:
        case TK_UINT64:
        case TK_FLOAT32:
        case TK_FLOAT64:
        case TK_FLOAT128:
        case TK_CHAR8:
        case TK_CHAR16:
        case TK_ENUM:
        case TK_STRING8:
        case TK_STRING16:
        b = false;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_extended_value;
}

eprosima::fastrtps::types::ExtendedAnnotationParameterValue& eprosima::fastrtps::types::AnnotationParameterValue::extended_value()
{
    bool b = true;

    switch(m__d)
    {
        case TK_BOOLEAN:
        case TK_BYTE:
        case TK_INT8:
        case TK_UINT8:
        case TK_INT16:
        case TK_UINT16:
        case TK_INT32:
        case TK_UINT32:
        case TK_INT64:
        case TK_UINT64:
        case TK_FLOAT32:
        case TK_FLOAT64:
        case TK_FLOAT128:
        case TK_CHAR8:
        case TK_CHAR16:
        case TK_ENUM:
        case TK_STRING8:
        case TK_STRING16:
        b = false;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_extended_value;
}

// TODO(Ricardo) Review
size_t eprosima::fastrtps::types::AnnotationParameterValue::getCdrSerializedSize(
        const eprosima::fastrtps::types::AnnotationParameterValue& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case TK_BOOLEAN:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TK_BYTE:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TK_INT8:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TK_UINT8:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TK_INT16:
        current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

        break;
        case TK_UINT16:
        current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

        break;
        case TK_INT32:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case TK_UINT32:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case TK_INT64:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        case TK_UINT64:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        case TK_FLOAT32:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case TK_FLOAT64:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        case TK_FLOAT128:
        current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64

        break;
        case TK_CHAR8:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TK_CHAR16:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case TK_ENUM:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case TK_STRING8:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.string8_value().size() + 1;
        break;
        case TK_STRING16:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.string16_value().size()) * 4; // 32 bits
        break;

        default:
        current_alignment += eprosima::fastrtps::types::ExtendedAnnotationParameterValue::getCdrSerializedSize(data.extended_value(), current_alignment);
        break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::AnnotationParameterValue::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case TK_BOOLEAN:
        scdr << m_boolean_value;
        break;
        case TK_BYTE:
        scdr << m_byte_value;
        break;
        case TK_INT8:
        scdr << m_int8_value;
        break;
        case TK_UINT8:
        scdr << m_uint8_value;
        break;
        case TK_INT16:
        scdr << m_int16_value;
        break;
        case TK_UINT16:
        scdr << m_uint16_value;
        break;
        case TK_INT32:
        scdr << m_int32_value;
        break;
        case TK_UINT32:
        scdr << m_uint32_value;
        break;
        case TK_INT64:
        scdr << m_int64_value;
        break;
        case TK_UINT64:
        scdr << m_uint64_value;
        break;
        case TK_FLOAT32:
        scdr << m_float32_value;
        break;
        case TK_FLOAT64:
        scdr << m_float64_value;
        break;
        case TK_FLOAT128:
        scdr << m_float128_value;
        break;
        case TK_CHAR8:
        scdr << m_char_value;
        break;
        case TK_CHAR16:
        scdr << m_wchar_value;
        break;
        case TK_ENUM:
        scdr << m_enumerated_value;
        break;
        case TK_STRING8:
        scdr << m_string8_value.c_str();
        break;
        case TK_STRING16:
        scdr << m_string16_value;
        break;

        default:
        scdr << m_extended_value;
        break;
    }
}

void eprosima::fastrtps::types::AnnotationParameterValue::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case TK_BOOLEAN:
        dcdr >> m_boolean_value;
        break;
        case TK_BYTE:
        dcdr >> m_byte_value;
        break;
        case TK_INT8:
        dcdr >> m_int8_value;
        break;
        case TK_UINT8:
        dcdr >> m_uint8_value;
        break;
        case TK_INT16:
        dcdr >> m_int16_value;
        break;
        case TK_UINT16:
        dcdr >> m_uint16_value;
        break;
        case TK_INT32:
        dcdr >> m_int32_value;
        break;
        case TK_UINT32:
        dcdr >> m_uint32_value;
        break;
        case TK_INT64:
        dcdr >> m_int64_value;
        break;
        case TK_UINT64:
        dcdr >> m_uint64_value;
        break;
        case TK_FLOAT32:
        dcdr >> m_float32_value;
        break;
        case TK_FLOAT64:
        dcdr >> m_float64_value;
        break;
        case TK_FLOAT128:
        dcdr >> m_float128_value;
        break;
        case TK_CHAR8:
        dcdr >> m_char_value;
        break;
        case TK_CHAR16:
        dcdr >> m_wchar_value;
        break;
        case TK_ENUM:
        dcdr >> m_enumerated_value;
        break;
        case TK_STRING8:
        {
            std::string aux;
            dcdr >> aux;
            m_string8_value = aux.c_str();
        }break;
        case TK_STRING16:
        dcdr >> m_string16_value;
        break;

        default:
        dcdr >> m_extended_value;
        break;
    }
}


eprosima::fastrtps::types::AppliedAnnotationParameter::AppliedAnnotationParameter()
{
    // eprosima::fastrtps::types::NameHash m_paramname_hash
    memset(&m_paramname_hash, 0, (4) * 1);
    // eprosima::fastrtps::types::AnnotationParameterValue m_value


}

eprosima::fastrtps::types::AppliedAnnotationParameter::~AppliedAnnotationParameter()
{


}

eprosima::fastrtps::types::AppliedAnnotationParameter::AppliedAnnotationParameter(
        const AppliedAnnotationParameter& x)
{
    m_paramname_hash = x.m_paramname_hash;
    m_value = x.m_value;
}

eprosima::fastrtps::types::AppliedAnnotationParameter::AppliedAnnotationParameter(
        AppliedAnnotationParameter&& x) noexcept 
{
    m_paramname_hash = std::move(x.m_paramname_hash);
    m_value = std::move(x.m_value);
}

eprosima::fastrtps::types::AppliedAnnotationParameter& eprosima::fastrtps::types::AppliedAnnotationParameter::operator =(
        const AppliedAnnotationParameter& x)
{

    m_paramname_hash = x.m_paramname_hash;
    m_value = x.m_value;

    return *this;
}

eprosima::fastrtps::types::AppliedAnnotationParameter& eprosima::fastrtps::types::AppliedAnnotationParameter::operator =(
        AppliedAnnotationParameter&& x) noexcept
{

    m_paramname_hash = std::move(x.m_paramname_hash);
    m_value = std::move(x.m_value);

    return *this;
}

bool eprosima::fastrtps::types::AppliedAnnotationParameter::operator ==(
        const AppliedAnnotationParameter& x) const
{

    return (m_paramname_hash == x.m_paramname_hash && m_value == x.m_value);
}

bool eprosima::fastrtps::types::AppliedAnnotationParameter::operator !=(
        const AppliedAnnotationParameter& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::AppliedAnnotationParameter::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedAnnotationParameter_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::AppliedAnnotationParameter::getCdrSerializedSize(
        const eprosima::fastrtps::types::AppliedAnnotationParameter& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += eprosima::fastrtps::types::AnnotationParameterValue::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::AppliedAnnotationParameter::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_paramname_hash;
    scdr << m_value;
}

void eprosima::fastrtps::types::AppliedAnnotationParameter::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_paramname_hash;

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member paramname_hash
 * @param _paramname_hash New value to be copied in member paramname_hash
 */
void eprosima::fastrtps::types::AppliedAnnotationParameter::paramname_hash(
        const eprosima::fastrtps::types::NameHash& _paramname_hash)
{
    m_paramname_hash = _paramname_hash;
}

/*!
 * @brief This function moves the value in member paramname_hash
 * @param _paramname_hash New value to be moved in member paramname_hash
 */
void eprosima::fastrtps::types::AppliedAnnotationParameter::paramname_hash(
        eprosima::fastrtps::types::NameHash&& _paramname_hash)
{
    m_paramname_hash = std::move(_paramname_hash);
}

/*!
 * @brief This function returns a constant reference to member paramname_hash
 * @return Constant reference to member paramname_hash
 */
const eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::AppliedAnnotationParameter::paramname_hash() const
{
    return m_paramname_hash;
}

/*!
 * @brief This function returns a reference to member paramname_hash
 * @return Reference to member paramname_hash
 */
eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::AppliedAnnotationParameter::paramname_hash()
{
    return m_paramname_hash;
}
/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void eprosima::fastrtps::types::AppliedAnnotationParameter::value(
        const eprosima::fastrtps::types::AnnotationParameterValue& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void eprosima::fastrtps::types::AppliedAnnotationParameter::value(
        eprosima::fastrtps::types::AnnotationParameterValue&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AppliedAnnotationParameter::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AppliedAnnotationParameter::value()
{
    return m_value;
}


size_t eprosima::fastrtps::types::AppliedAnnotationParameter::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedAnnotationParameter_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::AppliedAnnotationParameter::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::AppliedAnnotationParameter::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::AppliedAnnotation::AppliedAnnotation()
{
    // eprosima::fastrtps::types::TypeIdentifier m_annotation_typeid

    // eprosima::fastrtps::types::AppliedAnnotationParameterSeq m_param_seq


}

eprosima::fastrtps::types::AppliedAnnotation::~AppliedAnnotation()
{


}

eprosima::fastrtps::types::AppliedAnnotation::AppliedAnnotation(
        const AppliedAnnotation& x)
{
    m_annotation_typeid = x.m_annotation_typeid;
    m_param_seq = x.m_param_seq;
}

eprosima::fastrtps::types::AppliedAnnotation::AppliedAnnotation(
        AppliedAnnotation&& x) noexcept 
{
    m_annotation_typeid = std::move(x.m_annotation_typeid);
    m_param_seq = std::move(x.m_param_seq);
}

eprosima::fastrtps::types::AppliedAnnotation& eprosima::fastrtps::types::AppliedAnnotation::operator =(
        const AppliedAnnotation& x)
{

    m_annotation_typeid = x.m_annotation_typeid;
    m_param_seq = x.m_param_seq;

    return *this;
}

eprosima::fastrtps::types::AppliedAnnotation& eprosima::fastrtps::types::AppliedAnnotation::operator =(
        AppliedAnnotation&& x) noexcept
{

    m_annotation_typeid = std::move(x.m_annotation_typeid);
    m_param_seq = std::move(x.m_param_seq);

    return *this;
}

bool eprosima::fastrtps::types::AppliedAnnotation::operator ==(
        const AppliedAnnotation& x) const
{

    return (m_annotation_typeid == x.m_annotation_typeid && m_param_seq == x.m_param_seq);
}

bool eprosima::fastrtps::types::AppliedAnnotation::operator !=(
        const AppliedAnnotation& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::AppliedAnnotation::getCdrSerializedSize(
        const eprosima::fastrtps::types::AppliedAnnotation& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.annotation_typeid(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.param_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::AppliedAnnotationParameter::getCdrSerializedSize(data.param_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::AppliedAnnotation::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_annotation_typeid;
    scdr << m_param_seq;

}

void eprosima::fastrtps::types::AppliedAnnotation::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_annotation_typeid;
    dcdr >> m_param_seq;
}

/*!
 * @brief This function copies the value in member annotation_typeid
 * @param _annotation_typeid New value to be copied in member annotation_typeid
 */
void eprosima::fastrtps::types::AppliedAnnotation::annotation_typeid(
        const eprosima::fastrtps::types::TypeIdentifier& _annotation_typeid)
{
    m_annotation_typeid = _annotation_typeid;
}

/*!
 * @brief This function moves the value in member annotation_typeid
 * @param _annotation_typeid New value to be moved in member annotation_typeid
 */
void eprosima::fastrtps::types::AppliedAnnotation::annotation_typeid(
        eprosima::fastrtps::types::TypeIdentifier&& _annotation_typeid)
{
    m_annotation_typeid = std::move(_annotation_typeid);
}

/*!
 * @brief This function returns a constant reference to member annotation_typeid
 * @return Constant reference to member annotation_typeid
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::AppliedAnnotation::annotation_typeid() const
{
    return m_annotation_typeid;
}

/*!
 * @brief This function returns a reference to member annotation_typeid
 * @return Reference to member annotation_typeid
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::AppliedAnnotation::annotation_typeid()
{
    return m_annotation_typeid;
}
/*!
 * @brief This function copies the value in member param_seq
 * @param _param_seq New value to be copied in member param_seq
 */
void eprosima::fastrtps::types::AppliedAnnotation::param_seq(
        const eprosima::fastrtps::types::AppliedAnnotationParameterSeq& _param_seq)
{
    m_param_seq = _param_seq;
}

/*!
 * @brief This function moves the value in member param_seq
 * @param _param_seq New value to be moved in member param_seq
 */
void eprosima::fastrtps::types::AppliedAnnotation::param_seq(
        eprosima::fastrtps::types::AppliedAnnotationParameterSeq&& _param_seq)
{
    m_param_seq = std::move(_param_seq);
}

/*!
 * @brief This function returns a constant reference to member param_seq
 * @return Constant reference to member param_seq
 */
const eprosima::fastrtps::types::AppliedAnnotationParameterSeq& eprosima::fastrtps::types::AppliedAnnotation::param_seq() const
{
    return m_param_seq;
}

/*!
 * @brief This function returns a reference to member param_seq
 * @return Reference to member param_seq
 */
eprosima::fastrtps::types::AppliedAnnotationParameterSeq& eprosima::fastrtps::types::AppliedAnnotation::param_seq()
{
    return m_param_seq;
}


size_t eprosima::fastrtps::types::AppliedAnnotation::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedAnnotation_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::AppliedAnnotation::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::AppliedAnnotation::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::AppliedVerbatimAnnotation::AppliedVerbatimAnnotation()
{
    // string m_placement
    m_placement ="";
    // string m_language
    m_language ="";
    // string m_text
    m_text ="";

}

eprosima::fastrtps::types::AppliedVerbatimAnnotation::~AppliedVerbatimAnnotation()
{



}

eprosima::fastrtps::types::AppliedVerbatimAnnotation::AppliedVerbatimAnnotation(
        const AppliedVerbatimAnnotation& x)
{
    m_placement = x.m_placement;
    m_language = x.m_language;
    m_text = x.m_text;
}

eprosima::fastrtps::types::AppliedVerbatimAnnotation::AppliedVerbatimAnnotation(
        AppliedVerbatimAnnotation&& x) noexcept 
{
    m_placement = std::move(x.m_placement);
    m_language = std::move(x.m_language);
    m_text = std::move(x.m_text);
}

eprosima::fastrtps::types::AppliedVerbatimAnnotation& eprosima::fastrtps::types::AppliedVerbatimAnnotation::operator =(
        const AppliedVerbatimAnnotation& x)
{

    m_placement = x.m_placement;
    m_language = x.m_language;
    m_text = x.m_text;

    return *this;
}

eprosima::fastrtps::types::AppliedVerbatimAnnotation& eprosima::fastrtps::types::AppliedVerbatimAnnotation::operator =(
        AppliedVerbatimAnnotation&& x) noexcept
{

    m_placement = std::move(x.m_placement);
    m_language = std::move(x.m_language);
    m_text = std::move(x.m_text);

    return *this;
}

bool eprosima::fastrtps::types::AppliedVerbatimAnnotation::operator ==(
        const AppliedVerbatimAnnotation& x) const
{

    return (m_placement == x.m_placement && m_language == x.m_language && m_text == x.m_text);
}

bool eprosima::fastrtps::types::AppliedVerbatimAnnotation::operator !=(
        const AppliedVerbatimAnnotation& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::AppliedVerbatimAnnotation::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedVerbatimAnnotation_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::AppliedVerbatimAnnotation::getCdrSerializedSize(
        const eprosima::fastrtps::types::AppliedVerbatimAnnotation& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.placement().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.language().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.text().size() + 1;


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::AppliedVerbatimAnnotation::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_placement.c_str();scdr << m_language.c_str();scdr << m_text.c_str();
}

void eprosima::fastrtps::types::AppliedVerbatimAnnotation::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        std::string aux;
        dcdr >> aux;
        m_placement = aux.c_str();
    }
    {
        std::string aux;
        dcdr >> aux;
        m_language = aux.c_str();
    }
    dcdr >> m_text;
}

/*!
 * @brief This function copies the value in member placement
 * @param _placement New value to be copied in member placement
 */
void eprosima::fastrtps::types::AppliedVerbatimAnnotation::placement(
        const eprosima::fastrtps::fixed_string<32>& _placement)
{
    m_placement = _placement;
}

/*!
 * @brief This function moves the value in member placement
 * @param _placement New value to be moved in member placement
 */
void eprosima::fastrtps::types::AppliedVerbatimAnnotation::placement(
        eprosima::fastrtps::fixed_string<32>&& _placement)
{
    m_placement = std::move(_placement);
}

/*!
 * @brief This function returns a constant reference to member placement
 * @return Constant reference to member placement
 */
const eprosima::fastrtps::fixed_string<32>& eprosima::fastrtps::types::AppliedVerbatimAnnotation::placement() const
{
    return m_placement;
}

/*!
 * @brief This function returns a reference to member placement
 * @return Reference to member placement
 */
eprosima::fastrtps::fixed_string<32>& eprosima::fastrtps::types::AppliedVerbatimAnnotation::placement()
{
    return m_placement;
}
/*!
 * @brief This function copies the value in member language
 * @param _language New value to be copied in member language
 */
void eprosima::fastrtps::types::AppliedVerbatimAnnotation::language(
        const eprosima::fastrtps::fixed_string<32>& _language)
{
    m_language = _language;
}

/*!
 * @brief This function moves the value in member language
 * @param _language New value to be moved in member language
 */
void eprosima::fastrtps::types::AppliedVerbatimAnnotation::language(
        eprosima::fastrtps::fixed_string<32>&& _language)
{
    m_language = std::move(_language);
}

/*!
 * @brief This function returns a constant reference to member language
 * @return Constant reference to member language
 */
const eprosima::fastrtps::fixed_string<32>& eprosima::fastrtps::types::AppliedVerbatimAnnotation::language() const
{
    return m_language;
}

/*!
 * @brief This function returns a reference to member language
 * @return Reference to member language
 */
eprosima::fastrtps::fixed_string<32>& eprosima::fastrtps::types::AppliedVerbatimAnnotation::language()
{
    return m_language;
}
/*!
 * @brief This function copies the value in member text
 * @param _text New value to be copied in member text
 */
void eprosima::fastrtps::types::AppliedVerbatimAnnotation::text(
        const std::string& _text)
{
    m_text = _text;
}

/*!
 * @brief This function moves the value in member text
 * @param _text New value to be moved in member text
 */
void eprosima::fastrtps::types::AppliedVerbatimAnnotation::text(
        std::string&& _text)
{
    m_text = std::move(_text);
}

/*!
 * @brief This function returns a constant reference to member text
 * @return Constant reference to member text
 */
const std::string& eprosima::fastrtps::types::AppliedVerbatimAnnotation::text() const
{
    return m_text;
}

/*!
 * @brief This function returns a reference to member text
 * @return Reference to member text
 */
std::string& eprosima::fastrtps::types::AppliedVerbatimAnnotation::text()
{
    return m_text;
}


size_t eprosima::fastrtps::types::AppliedVerbatimAnnotation::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedVerbatimAnnotation_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::AppliedVerbatimAnnotation::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::AppliedVerbatimAnnotation::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::AppliedBuiltinMemberAnnotations()
{
    // string m_unit
    m_unit ="";
    // eprosima::fastrtps::types::AnnotationParameterValue m_min

    // eprosima::fastrtps::types::AnnotationParameterValue m_max

    // string m_hash_id
    m_hash_id ="";

}

eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::~AppliedBuiltinMemberAnnotations()
{




}

eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::AppliedBuiltinMemberAnnotations(
        const AppliedBuiltinMemberAnnotations& x)
{
    m_unit = x.m_unit;
    m_min = x.m_min;
    m_max = x.m_max;
    m_hash_id = x.m_hash_id;
}

eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::AppliedBuiltinMemberAnnotations(
        AppliedBuiltinMemberAnnotations&& x) noexcept 
{
    m_unit = std::move(x.m_unit);
    m_min = std::move(x.m_min);
    m_max = std::move(x.m_max);
    m_hash_id = std::move(x.m_hash_id);
}

eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::operator =(
        const AppliedBuiltinMemberAnnotations& x)
{

    m_unit = x.m_unit;
    m_min = x.m_min;
    m_max = x.m_max;
    m_hash_id = x.m_hash_id;

    return *this;
}

eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::operator =(
        AppliedBuiltinMemberAnnotations&& x) noexcept
{

    m_unit = std::move(x.m_unit);
    m_min = std::move(x.m_min);
    m_max = std::move(x.m_max);
    m_hash_id = std::move(x.m_hash_id);

    return *this;
}

bool eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::operator ==(
        const AppliedBuiltinMemberAnnotations& x) const
{

    return (m_unit == x.m_unit && m_min == x.m_min && m_max == x.m_max && m_hash_id == x.m_hash_id);
}

bool eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::operator !=(
        const AppliedBuiltinMemberAnnotations& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedBuiltinMemberAnnotations_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::getCdrSerializedSize(
        const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += eprosima::fastrtps::types::AnnotationParameterValue::getCdrSerializedSize(data.min(), current_alignment);
    current_alignment += eprosima::fastrtps::types::AnnotationParameterValue::getCdrSerializedSize(data.max(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.hash_id().size() + 1;


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_unit.c_str();scdr << m_min;scdr << m_max;scdr << m_hash_id.c_str();
}

void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_unit;
    dcdr >> m_min;
    dcdr >> m_max;
    dcdr >> m_hash_id;
}

/*!
 * @brief This function copies the value in member unit
 * @param _unit New value to be copied in member unit
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::unit(
        const std::string& _unit)
{
    m_unit = _unit;
}

/*!
 * @brief This function moves the value in member unit
 * @param _unit New value to be moved in member unit
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::unit(
        std::string&& _unit)
{
    m_unit = std::move(_unit);
}

/*!
 * @brief This function returns a constant reference to member unit
 * @return Constant reference to member unit
 */
const std::string& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::unit() const
{
    return m_unit;
}

/*!
 * @brief This function returns a reference to member unit
 * @return Reference to member unit
 */
std::string& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::unit()
{
    return m_unit;
}
/*!
 * @brief This function copies the value in member min
 * @param _min New value to be copied in member min
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::min(
        const eprosima::fastrtps::types::AnnotationParameterValue& _min)
{
    m_min = _min;
}

/*!
 * @brief This function moves the value in member min
 * @param _min New value to be moved in member min
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::min(
        eprosima::fastrtps::types::AnnotationParameterValue&& _min)
{
    m_min = std::move(_min);
}

/*!
 * @brief This function returns a constant reference to member min
 * @return Constant reference to member min
 */
const eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::min() const
{
    return m_min;
}

/*!
 * @brief This function returns a reference to member min
 * @return Reference to member min
 */
eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::min()
{
    return m_min;
}
/*!
 * @brief This function copies the value in member max
 * @param _max New value to be copied in member max
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::max(
        const eprosima::fastrtps::types::AnnotationParameterValue& _max)
{
    m_max = _max;
}

/*!
 * @brief This function moves the value in member max
 * @param _max New value to be moved in member max
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::max(
        eprosima::fastrtps::types::AnnotationParameterValue&& _max)
{
    m_max = std::move(_max);
}

/*!
 * @brief This function returns a constant reference to member max
 * @return Constant reference to member max
 */
const eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::max() const
{
    return m_max;
}

/*!
 * @brief This function returns a reference to member max
 * @return Reference to member max
 */
eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::max()
{
    return m_max;
}
/*!
 * @brief This function copies the value in member hash_id
 * @param _hash_id New value to be copied in member hash_id
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::hash_id(
        const std::string& _hash_id)
{
    m_hash_id = _hash_id;
}

/*!
 * @brief This function moves the value in member hash_id
 * @param _hash_id New value to be moved in member hash_id
 */
void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::hash_id(
        std::string&& _hash_id)
{
    m_hash_id = std::move(_hash_id);
}

/*!
 * @brief This function returns a constant reference to member hash_id
 * @return Constant reference to member hash_id
 */
const std::string& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::hash_id() const
{
    return m_hash_id;
}

/*!
 * @brief This function returns a reference to member hash_id
 * @return Reference to member hash_id
 */
std::string& eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::hash_id()
{
    return m_hash_id;
}


size_t eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedBuiltinMemberAnnotations_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}




