// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include <fastrtps/types/TypeObject.h>
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


#define eprosima_fastrtps_types_CommonBitflag_max_cdr_typesize 4ULL;

#define eprosima_fastrtps_types_MinimalExtendedType_max_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainCollectionHeader_max_cdr_typesize 4ULL;



#define eprosima_fastrtps_types_ExtendedAnnotationParameterValue_max_cdr_typesize 0ULL;




#define eprosima_fastrtps_types_MinimalAliasHeader_max_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalUnionHeader_max_cdr_typesize 0ULL;













#define eprosima_fastrtps_types_StronglyConnectedComponentId_max_cdr_typesize 24ULL;
#define eprosima_fastrtps_types_AppliedBuiltinMemberAnnotations_max_cdr_typesize 1560ULL;

#define eprosima_fastrtps_types_MinimalMemberDetail_max_cdr_typesize 4ULL;


#define eprosima_fastrtps_types_CompleteTypeDetail_max_cdr_typesize 605ULL;


#define eprosima_fastrtps_types_MinimalBitflag_max_cdr_typesize 8ULL;
#define eprosima_fastrtps_types_StringSTypeDefn_max_cdr_typesize 1ULL;
#define eprosima_fastrtps_types_CompleteArrayHeader_max_cdr_typesize 1009ULL;
#define eprosima_fastrtps_types_MinimalArrayHeader_max_cdr_typesize 404ULL;
#define eprosima_fastrtps_types_MinimalBitfield_max_cdr_typesize 10ULL;
#define eprosima_fastrtps_types_CompleteEnumeratedType_max_cdr_typesize 184216ULL;
#define eprosima_fastrtps_types_AppliedBuiltinTypeAnnotations_max_cdr_typesize 340ULL;

#define eprosima_fastrtps_types_MinimalCollectionHeader_max_cdr_typesize 4ULL;
#define eprosima_fastrtps_types_CompleteBitsetHeader_max_cdr_typesize 605ULL;
#define eprosima_fastrtps_types_CompleteEnumeratedLiteral_max_cdr_typesize 1836ULL;
#define eprosima_fastrtps_types_MinimalEnumeratedHeader_max_cdr_typesize 2ULL;


#define eprosima_fastrtps_types_CommonEnumeratedHeader_max_cdr_typesize 2ULL;
#define eprosima_fastrtps_types_CompleteEnumeratedHeader_max_cdr_typesize 609ULL;

#define eprosima_fastrtps_types_CompleteAliasHeader_max_cdr_typesize 605ULL;

#define eprosima_fastrtps_types_StringLTypeDefn_max_cdr_typesize 4ULL;

#define eprosima_fastrtps_types_CommonCollectionHeader_max_cdr_typesize 4ULL;




#define eprosima_fastrtps_types_MinimalEnumeratedType_max_cdr_typesize 1206ULL;



#define eprosima_fastrtps_types_CommonBitmaskHeader_max_cdr_typesize 2ULL;
#define eprosima_fastrtps_types_CommonEnumeratedLiteral_max_cdr_typesize 6ULL;
#define eprosima_fastrtps_types_MinimalBitsetType_max_cdr_typesize 1008ULL;



#define eprosima_fastrtps_types_CompleteCollectionHeader_max_cdr_typesize 609ULL;




#define eprosima_fastrtps_types_CompleteMemberDetail_max_cdr_typesize 1828ULL;





#define eprosima_fastrtps_types_AppliedVerbatimAnnotation_max_cdr_typesize 340ULL;

#define eprosima_fastrtps_types_CompleteBitmaskType_max_cdr_typesize 183816ULL;

#define eprosima_fastrtps_types_MinimalBitsetHeader_max_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_MinimalBitmaskType_max_cdr_typesize 808ULL;

#define eprosima_fastrtps_types_CompleteBitflag_max_cdr_typesize 1832ULL;

#define eprosima_fastrtps_types_CommonBitfield_max_cdr_typesize 6ULL;
#define eprosima_fastrtps_types_AppliedAnnotationParameter_max_cdr_typesize 524ULL;


#define eprosima_fastrtps_types_CompleteBitfield_max_cdr_typesize 1836ULL;

#define eprosima_fastrtps_types_CommonArrayHeader_max_cdr_typesize 404ULL;
#define eprosima_fastrtps_types_MinimalAnnotationHeader_max_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteBitsetType_max_cdr_typesize 184216ULL;
#define eprosima_fastrtps_types_MinimalEnumeratedLiteral_max_cdr_typesize 10ULL;
#define eprosima_fastrtps_types_CompleteAnnotationHeader_max_cdr_typesize 261ULL;


#define eprosima_fastrtps_types_ExtendedTypeDefn_max_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteUnionHeader_max_cdr_typesize 605ULL;

#define eprosima_fastrtps_types_CompleteElementDetail_max_cdr_typesize 1564ULL;
#define eprosima_fastrtps_types_CompleteExtendedType_max_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalTypeDetail_max_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteCollectionElement_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalAnnotationParameter_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CommonBitflag_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteAnnotationParameter_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalExtendedType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainCollectionHeader_max_key_cdr_typesize 0ULL;



#define eprosima_fastrtps_types_ExtendedAnnotationParameterValue_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteStructHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CommonDiscriminatorMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteSequenceType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalMapType_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteUnionMember_max_key_cdr_typesize 0ULL;



#define eprosima_fastrtps_types_MinimalDiscriminatorMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalAliasHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalUnionHeader_max_key_cdr_typesize 0ULL;




#define eprosima_fastrtps_types_MinimalAliasBody_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CommonAnnotationParameter_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_MinimalUnionType_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_PlainMapSTypeDefn_max_key_cdr_typesize 0ULL;





#define eprosima_fastrtps_types_StronglyConnectedComponentId_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteAliasBody_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_AppliedBuiltinMemberAnnotations_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_MinimalMemberDetail_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_AppliedAnnotation_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteTypeDetail_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_MinimalBitflag_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteArrayType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_StringSTypeDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteArrayHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalArrayHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalBitfield_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteEnumeratedType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_AppliedBuiltinTypeAnnotations_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_PlainArrayLElemDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalCollectionHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteBitsetHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteDiscriminatorMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteEnumeratedLiteral_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalEnumeratedHeader_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_CommonEnumeratedHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteStructMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteEnumeratedHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_TypeIdentifierTypeObjectPair_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteAliasHeader_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_StringLTypeDefn_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CommonStructMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CommonCollectionHeader_max_key_cdr_typesize 0ULL;



#define eprosima_fastrtps_types_CompleteAnnotationType_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_MinimalEnumeratedType_max_key_cdr_typesize 0ULL;



#define eprosima_fastrtps_types_CommonBitmaskHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CommonEnumeratedLiteral_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainSequenceSElemDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalBitsetType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalStructHeader_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_CompleteAliasType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteMapType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_TypeIdentifierPair_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteCollectionHeader_max_key_cdr_typesize 0ULL;



#define eprosima_fastrtps_types_PlainArraySElemDefn_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CommonUnionMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteMemberDetail_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalStructType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_TypeInformation_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CommonCollectionElement_max_key_cdr_typesize 0ULL;





#define eprosima_fastrtps_types_MinimalArrayType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_AppliedVerbatimAnnotation_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteUnionType_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteBitmaskType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_TypeIdentifierWithDependencies_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainMapLTypeDefn_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_MinimalBitsetHeader_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_MinimalCollectionElement_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalBitmaskType_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteBitflag_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CommonAliasBody_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CommonBitfield_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_PlainSequenceLElemDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_AppliedAnnotationParameter_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_CompleteBitfield_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_MinimalUnionMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CommonArrayHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_TypeIdentifierWithSize_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalAnnotationHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteBitsetType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalEnumeratedLiteral_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteAnnotationHeader_max_key_cdr_typesize 0ULL;


#define eprosima_fastrtps_types_ExtendedTypeDefn_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteUnionHeader_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalStructMember_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalSequenceType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteStructType_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_types_CompleteElementDetail_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalAnnotationType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_CompleteExtendedType_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalTypeDetail_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_types_MinimalAliasType_max_key_cdr_typesize 0ULL;


eprosima::fastrtps::types::CommonStructMember::CommonStructMember()
{
    // eprosima::fastrtps::types::MemberId m_member_id
    m_member_id = 0;
    // eprosima::fastrtps::types::StructMemberFlag m_member_flags
    m_member_flags = static_cast<eprosima::fastrtps::types::StructMemberFlag>(0);
    // eprosima::fastrtps::types::TypeIdentifier m_member_type_id

}

eprosima::fastrtps::types::CommonStructMember::~CommonStructMember()
{


}

eprosima::fastrtps::types::CommonStructMember::CommonStructMember(
        const CommonStructMember& x)
{
    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_member_type_id = x.m_member_type_id;

}

eprosima::fastrtps::types::CommonStructMember::CommonStructMember(
        CommonStructMember&& x) noexcept 
{
    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_member_type_id = std::move(x.m_member_type_id);
}

eprosima::fastrtps::types::CommonStructMember& eprosima::fastrtps::types::CommonStructMember::operator =(
        const CommonStructMember& x)
{

    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_member_type_id = x.m_member_type_id;


    return *this;
}

eprosima::fastrtps::types::CommonStructMember& eprosima::fastrtps::types::CommonStructMember::operator =(
        CommonStructMember&& x) noexcept
{

    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_member_type_id = std::move(x.m_member_type_id);

    return *this;
}

bool eprosima::fastrtps::types::CommonStructMember::operator ==(
        const CommonStructMember& x) const
{

    return (m_member_id == x.m_member_id && m_member_flags == x.m_member_flags && m_member_type_id == x.m_member_type_id);
}

bool eprosima::fastrtps::types::CommonStructMember::operator !=(
        const CommonStructMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonStructMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonStructMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.member_type_id(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonStructMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_member_id;scdr << (uint16_t)m_member_flags;scdr << m_member_type_id;
}

void eprosima::fastrtps::types::CommonStructMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_member_id;
    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_member_flags = (eprosima::fastrtps::types::StructMemberFlag)bitmask_value;
    }


    dcdr >> m_member_type_id;
}

/*!
 * @brief This function sets a value in member member_id
 * @param _member_id New value for member member_id
 */
void eprosima::fastrtps::types::CommonStructMember::member_id(
        eprosima::fastrtps::types::MemberId _member_id)
{
    m_member_id = _member_id;
}

/*!
 * @brief This function returns the value of member member_id
 * @return Value of member member_id
 */
eprosima::fastrtps::types::MemberId eprosima::fastrtps::types::CommonStructMember::member_id() const
{
    return m_member_id;
}

/*!
 * @brief This function returns a reference to member member_id
 * @return Reference to member member_id
 */
eprosima::fastrtps::types::MemberId& eprosima::fastrtps::types::CommonStructMember::member_id()
{
    return m_member_id;
}

/*!
 * @brief This function sets a value in member member_flags
 * @param _member_flags New value for member member_flags
 */
void eprosima::fastrtps::types::CommonStructMember::member_flags(
        eprosima::fastrtps::types::StructMemberFlag _member_flags)
{
    m_member_flags = _member_flags;
}

/*!
 * @brief This function returns the value of member member_flags
 * @return Value of member member_flags
 */
eprosima::fastrtps::types::StructMemberFlag eprosima::fastrtps::types::CommonStructMember::member_flags() const
{
    return m_member_flags;
}

/*!
 * @brief This function returns a reference to member member_flags
 * @return Reference to member member_flags
 */
eprosima::fastrtps::types::StructMemberFlag& eprosima::fastrtps::types::CommonStructMember::member_flags()
{
    return m_member_flags;
}

/*!
 * @brief This function copies the value in member member_type_id
 * @param _member_type_id New value to be copied in member member_type_id
 */
void eprosima::fastrtps::types::CommonStructMember::member_type_id(
        const eprosima::fastrtps::types::TypeIdentifier& _member_type_id)
{
    m_member_type_id = _member_type_id;
}

/*!
 * @brief This function moves the value in member member_type_id
 * @param _member_type_id New value to be moved in member member_type_id
 */
void eprosima::fastrtps::types::CommonStructMember::member_type_id(
        eprosima::fastrtps::types::TypeIdentifier&& _member_type_id)
{
    m_member_type_id = std::move(_member_type_id);
}

/*!
 * @brief This function returns a constant reference to member member_type_id
 * @return Constant reference to member member_type_id
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonStructMember::member_type_id() const
{
    return m_member_type_id;
}

/*!
 * @brief This function returns a reference to member member_type_id
 * @return Reference to member member_type_id
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonStructMember::member_type_id()
{
    return m_member_type_id;
}


size_t eprosima::fastrtps::types::CommonStructMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonStructMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonStructMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonStructMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteMemberDetail::CompleteMemberDetail()
{
    // eprosima::fastrtps::types::MemberName m_name
    m_name ="";
    // eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations m_ann_builtin

    // eprosima::fastrtps::types::AppliedAnnotationSeq m_ann_custom


}

eprosima::fastrtps::types::CompleteMemberDetail::~CompleteMemberDetail()
{



}

eprosima::fastrtps::types::CompleteMemberDetail::CompleteMemberDetail(
        const CompleteMemberDetail& x)
{
    m_name = x.m_name;
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;
}

eprosima::fastrtps::types::CompleteMemberDetail::CompleteMemberDetail(
        CompleteMemberDetail&& x) noexcept 
{
    m_name = std::move(x.m_name);
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);
}

eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteMemberDetail::operator =(
        const CompleteMemberDetail& x)
{

    m_name = x.m_name;
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;

    return *this;
}

eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteMemberDetail::operator =(
        CompleteMemberDetail&& x) noexcept
{

    m_name = std::move(x.m_name);
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);

    return *this;
}

bool eprosima::fastrtps::types::CompleteMemberDetail::operator ==(
        const CompleteMemberDetail& x) const
{

    return (m_name == x.m_name && m_ann_builtin == x.m_ann_builtin && m_ann_custom == x.m_ann_custom);
}

bool eprosima::fastrtps::types::CompleteMemberDetail::operator !=(
        const CompleteMemberDetail& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteMemberDetail::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteMemberDetail_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteMemberDetail::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteMemberDetail& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::getCdrSerializedSize(data.ann_builtin(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.ann_custom().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::AppliedAnnotation::getCdrSerializedSize(data.ann_custom().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteMemberDetail::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name.c_str();scdr << m_ann_builtin;scdr << m_ann_custom;

}

void eprosima::fastrtps::types::CompleteMemberDetail::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        std::string aux;
        dcdr >> aux;
        m_name = aux.c_str();
    }
    dcdr >> m_ann_builtin;
    dcdr >> m_ann_custom;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void eprosima::fastrtps::types::CompleteMemberDetail::name(
        const eprosima::fastrtps::types::MemberName& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void eprosima::fastrtps::types::CompleteMemberDetail::name(
        eprosima::fastrtps::types::MemberName&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const eprosima::fastrtps::types::MemberName& eprosima::fastrtps::types::CompleteMemberDetail::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
eprosima::fastrtps::types::MemberName& eprosima::fastrtps::types::CompleteMemberDetail::name()
{
    return m_name;
}
/*!
 * @brief This function copies the value in member ann_builtin
 * @param _ann_builtin New value to be copied in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteMemberDetail::ann_builtin(
        const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& _ann_builtin)
{
    m_ann_builtin = _ann_builtin;
}

/*!
 * @brief This function moves the value in member ann_builtin
 * @param _ann_builtin New value to be moved in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteMemberDetail::ann_builtin(
        eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations&& _ann_builtin)
{
    m_ann_builtin = std::move(_ann_builtin);
}

/*!
 * @brief This function returns a constant reference to member ann_builtin
 * @return Constant reference to member ann_builtin
 */
const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::CompleteMemberDetail::ann_builtin() const
{
    return m_ann_builtin;
}

/*!
 * @brief This function returns a reference to member ann_builtin
 * @return Reference to member ann_builtin
 */
eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::CompleteMemberDetail::ann_builtin()
{
    return m_ann_builtin;
}
/*!
 * @brief This function copies the value in member ann_custom
 * @param _ann_custom New value to be copied in member ann_custom
 */
void eprosima::fastrtps::types::CompleteMemberDetail::ann_custom(
        const eprosima::fastrtps::types::AppliedAnnotationSeq& _ann_custom)
{
    m_ann_custom = _ann_custom;
}

/*!
 * @brief This function moves the value in member ann_custom
 * @param _ann_custom New value to be moved in member ann_custom
 */
void eprosima::fastrtps::types::CompleteMemberDetail::ann_custom(
        eprosima::fastrtps::types::AppliedAnnotationSeq&& _ann_custom)
{
    m_ann_custom = std::move(_ann_custom);
}

/*!
 * @brief This function returns a constant reference to member ann_custom
 * @return Constant reference to member ann_custom
 */
const eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteMemberDetail::ann_custom() const
{
    return m_ann_custom;
}

/*!
 * @brief This function returns a reference to member ann_custom
 * @return Reference to member ann_custom
 */
eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteMemberDetail::ann_custom()
{
    return m_ann_custom;
}


size_t eprosima::fastrtps::types::CompleteMemberDetail::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteMemberDetail_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteMemberDetail::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteMemberDetail::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalMemberDetail::MinimalMemberDetail()
{
    // eprosima::fastrtps::types::NameHash m_name_hash
    memset(&m_name_hash, 0, (4) * 1);

}

eprosima::fastrtps::types::MinimalMemberDetail::~MinimalMemberDetail()
{
}

eprosima::fastrtps::types::MinimalMemberDetail::MinimalMemberDetail(
        const MinimalMemberDetail& x)
{
    m_name_hash = x.m_name_hash;
}

eprosima::fastrtps::types::MinimalMemberDetail::MinimalMemberDetail(
        MinimalMemberDetail&& x) noexcept 
{
    m_name_hash = std::move(x.m_name_hash);
}

eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalMemberDetail::operator =(
        const MinimalMemberDetail& x)
{

    m_name_hash = x.m_name_hash;

    return *this;
}

eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalMemberDetail::operator =(
        MinimalMemberDetail&& x) noexcept
{

    m_name_hash = std::move(x.m_name_hash);

    return *this;
}

bool eprosima::fastrtps::types::MinimalMemberDetail::operator ==(
        const MinimalMemberDetail& x) const
{

    return (m_name_hash == x.m_name_hash);
}

bool eprosima::fastrtps::types::MinimalMemberDetail::operator !=(
        const MinimalMemberDetail& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalMemberDetail::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalMemberDetail_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalMemberDetail::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalMemberDetail& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalMemberDetail::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name_hash;

}

void eprosima::fastrtps::types::MinimalMemberDetail::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name_hash;

}

/*!
 * @brief This function copies the value in member name_hash
 * @param _name_hash New value to be copied in member name_hash
 */
void eprosima::fastrtps::types::MinimalMemberDetail::name_hash(
        const eprosima::fastrtps::types::NameHash& _name_hash)
{
    m_name_hash = _name_hash;
}

/*!
 * @brief This function moves the value in member name_hash
 * @param _name_hash New value to be moved in member name_hash
 */
void eprosima::fastrtps::types::MinimalMemberDetail::name_hash(
        eprosima::fastrtps::types::NameHash&& _name_hash)
{
    m_name_hash = std::move(_name_hash);
}

/*!
 * @brief This function returns a constant reference to member name_hash
 * @return Constant reference to member name_hash
 */
const eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::MinimalMemberDetail::name_hash() const
{
    return m_name_hash;
}

/*!
 * @brief This function returns a reference to member name_hash
 * @return Reference to member name_hash
 */
eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::MinimalMemberDetail::name_hash()
{
    return m_name_hash;
}


size_t eprosima::fastrtps::types::MinimalMemberDetail::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalMemberDetail_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalMemberDetail::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalMemberDetail::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteStructMember::CompleteStructMember()
{
    // eprosima::fastrtps::types::CommonStructMember m_common

    // eprosima::fastrtps::types::CompleteMemberDetail m_detail


}

eprosima::fastrtps::types::CompleteStructMember::~CompleteStructMember()
{


}

eprosima::fastrtps::types::CompleteStructMember::CompleteStructMember(
        const CompleteStructMember& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteStructMember::CompleteStructMember(
        CompleteStructMember&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteStructMember& eprosima::fastrtps::types::CompleteStructMember::operator =(
        const CompleteStructMember& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteStructMember& eprosima::fastrtps::types::CompleteStructMember::operator =(
        CompleteStructMember&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteStructMember::operator ==(
        const CompleteStructMember& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteStructMember::operator !=(
        const CompleteStructMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteStructMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteStructMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonStructMember::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteStructMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteStructMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteStructMember::common(
        const eprosima::fastrtps::types::CommonStructMember& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteStructMember::common(
        eprosima::fastrtps::types::CommonStructMember&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonStructMember& eprosima::fastrtps::types::CompleteStructMember::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonStructMember& eprosima::fastrtps::types::CompleteStructMember::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteStructMember::detail(
        const eprosima::fastrtps::types::CompleteMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteStructMember::detail(
        eprosima::fastrtps::types::CompleteMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteStructMember::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteStructMember::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteStructMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteStructMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteStructMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteStructMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::MinimalStructMember::MinimalStructMember()
{
    // eprosima::fastrtps::types::CommonStructMember m_common

    // eprosima::fastrtps::types::MinimalMemberDetail m_detail


}

eprosima::fastrtps::types::MinimalStructMember::~MinimalStructMember()
{


}

eprosima::fastrtps::types::MinimalStructMember::MinimalStructMember(
        const MinimalStructMember& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::MinimalStructMember::MinimalStructMember(
        MinimalStructMember&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::MinimalStructMember& eprosima::fastrtps::types::MinimalStructMember::operator =(
        const MinimalStructMember& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::MinimalStructMember& eprosima::fastrtps::types::MinimalStructMember::operator =(
        MinimalStructMember&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::MinimalStructMember::operator ==(
        const MinimalStructMember& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::MinimalStructMember::operator !=(
        const MinimalStructMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalStructMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalStructMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonStructMember::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalStructMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::MinimalStructMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalStructMember::common(
        const eprosima::fastrtps::types::CommonStructMember& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalStructMember::common(
        eprosima::fastrtps::types::CommonStructMember&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonStructMember& eprosima::fastrtps::types::MinimalStructMember::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonStructMember& eprosima::fastrtps::types::MinimalStructMember::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::MinimalStructMember::detail(
        const eprosima::fastrtps::types::MinimalMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::MinimalStructMember::detail(
        eprosima::fastrtps::types::MinimalMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalStructMember::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalStructMember::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::MinimalStructMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalStructMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalStructMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalStructMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::AppliedBuiltinTypeAnnotations()
{
    // eprosima::fastrtps::types::AppliedVerbatimAnnotation m_verbatim


}

eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::~AppliedBuiltinTypeAnnotations()
{
}

eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::AppliedBuiltinTypeAnnotations(
        const AppliedBuiltinTypeAnnotations& x)
{
    m_verbatim = x.m_verbatim;
}

eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::AppliedBuiltinTypeAnnotations(
        AppliedBuiltinTypeAnnotations&& x) noexcept 
{
    m_verbatim = std::move(x.m_verbatim);
}

eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::operator =(
        const AppliedBuiltinTypeAnnotations& x)
{

    m_verbatim = x.m_verbatim;

    return *this;
}

eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::operator =(
        AppliedBuiltinTypeAnnotations&& x) noexcept
{

    m_verbatim = std::move(x.m_verbatim);

    return *this;
}

bool eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::operator ==(
        const AppliedBuiltinTypeAnnotations& x) const
{

    return (m_verbatim == x.m_verbatim);
}

bool eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::operator !=(
        const AppliedBuiltinTypeAnnotations& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedBuiltinTypeAnnotations_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::getCdrSerializedSize(
        const eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::AppliedVerbatimAnnotation::getCdrSerializedSize(data.verbatim(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_verbatim;
}

void eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_verbatim;
}

/*!
 * @brief This function copies the value in member verbatim
 * @param _verbatim New value to be copied in member verbatim
 */
void eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::verbatim(
        const eprosima::fastrtps::types::AppliedVerbatimAnnotation& _verbatim)
{
    m_verbatim = _verbatim;
}

/*!
 * @brief This function moves the value in member verbatim
 * @param _verbatim New value to be moved in member verbatim
 */
void eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::verbatim(
        eprosima::fastrtps::types::AppliedVerbatimAnnotation&& _verbatim)
{
    m_verbatim = std::move(_verbatim);
}

/*!
 * @brief This function returns a constant reference to member verbatim
 * @return Constant reference to member verbatim
 */
const eprosima::fastrtps::types::AppliedVerbatimAnnotation& eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::verbatim() const
{
    return m_verbatim;
}

/*!
 * @brief This function returns a reference to member verbatim
 * @return Reference to member verbatim
 */
eprosima::fastrtps::types::AppliedVerbatimAnnotation& eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::verbatim()
{
    return m_verbatim;
}


size_t eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_AppliedBuiltinTypeAnnotations_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalTypeDetail::MinimalTypeDetail()
{

}

eprosima::fastrtps::types::MinimalTypeDetail::~MinimalTypeDetail()
{
}

eprosima::fastrtps::types::MinimalTypeDetail::MinimalTypeDetail(
        const MinimalTypeDetail& /*x*/)
{
}

eprosima::fastrtps::types::MinimalTypeDetail::MinimalTypeDetail(
        MinimalTypeDetail&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::MinimalTypeDetail& eprosima::fastrtps::types::MinimalTypeDetail::operator =(
        const MinimalTypeDetail& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::MinimalTypeDetail& eprosima::fastrtps::types::MinimalTypeDetail::operator =(
        MinimalTypeDetail&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::MinimalTypeDetail::operator ==(
        const MinimalTypeDetail& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::MinimalTypeDetail::operator !=(
        const MinimalTypeDetail& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalTypeDetail::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalTypeDetail_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalTypeDetail::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalTypeDetail& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalTypeDetail::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::MinimalTypeDetail::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::MinimalTypeDetail::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalTypeDetail_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalTypeDetail::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalTypeDetail::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteTypeDetail::CompleteTypeDetail()
{
    // eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations m_ann_builtin

    // eprosima::fastrtps::types::AppliedAnnotationSeq m_ann_custom

    // eprosima::fastrtps::types::QualifiedTypeName m_type_name
    m_type_name ="";

}

eprosima::fastrtps::types::CompleteTypeDetail::~CompleteTypeDetail()
{



}

eprosima::fastrtps::types::CompleteTypeDetail::CompleteTypeDetail(
        const CompleteTypeDetail& x)
{
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;
    m_type_name = x.m_type_name;
}

eprosima::fastrtps::types::CompleteTypeDetail::CompleteTypeDetail(
        CompleteTypeDetail&& x) noexcept 
{
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);
    m_type_name = std::move(x.m_type_name);
}

eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteTypeDetail::operator =(
        const CompleteTypeDetail& x)
{

    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;
    m_type_name = x.m_type_name;

    return *this;
}

eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteTypeDetail::operator =(
        CompleteTypeDetail&& x) noexcept
{

    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);
    m_type_name = std::move(x.m_type_name);

    return *this;
}

bool eprosima::fastrtps::types::CompleteTypeDetail::operator ==(
        const CompleteTypeDetail& x) const
{

    return (m_ann_builtin == x.m_ann_builtin && m_ann_custom == x.m_ann_custom && m_type_name == x.m_type_name);
}

bool eprosima::fastrtps::types::CompleteTypeDetail::operator !=(
        const CompleteTypeDetail& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteTypeDetail::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteTypeDetail_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteTypeDetail& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::getCdrSerializedSize(data.ann_builtin(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.ann_custom().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::AppliedAnnotation::getCdrSerializedSize(data.ann_custom().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type_name().size() + 1;


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteTypeDetail::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_ann_builtin;scdr << m_ann_custom;
    scdr << m_type_name.c_str();
}

void eprosima::fastrtps::types::CompleteTypeDetail::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_ann_builtin;
    dcdr >> m_ann_custom;
    {
        std::string aux;
        dcdr >> aux;
        m_type_name = aux.c_str();
    }
}

/*!
 * @brief This function copies the value in member ann_builtin
 * @param _ann_builtin New value to be copied in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteTypeDetail::ann_builtin(
        const eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& _ann_builtin)
{
    m_ann_builtin = _ann_builtin;
}

/*!
 * @brief This function moves the value in member ann_builtin
 * @param _ann_builtin New value to be moved in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteTypeDetail::ann_builtin(
        eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations&& _ann_builtin)
{
    m_ann_builtin = std::move(_ann_builtin);
}

/*!
 * @brief This function returns a constant reference to member ann_builtin
 * @return Constant reference to member ann_builtin
 */
const eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& eprosima::fastrtps::types::CompleteTypeDetail::ann_builtin() const
{
    return m_ann_builtin;
}

/*!
 * @brief This function returns a reference to member ann_builtin
 * @return Reference to member ann_builtin
 */
eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& eprosima::fastrtps::types::CompleteTypeDetail::ann_builtin()
{
    return m_ann_builtin;
}
/*!
 * @brief This function copies the value in member ann_custom
 * @param _ann_custom New value to be copied in member ann_custom
 */
void eprosima::fastrtps::types::CompleteTypeDetail::ann_custom(
        const eprosima::fastrtps::types::AppliedAnnotationSeq& _ann_custom)
{
    m_ann_custom = _ann_custom;
}

/*!
 * @brief This function moves the value in member ann_custom
 * @param _ann_custom New value to be moved in member ann_custom
 */
void eprosima::fastrtps::types::CompleteTypeDetail::ann_custom(
        eprosima::fastrtps::types::AppliedAnnotationSeq&& _ann_custom)
{
    m_ann_custom = std::move(_ann_custom);
}

/*!
 * @brief This function returns a constant reference to member ann_custom
 * @return Constant reference to member ann_custom
 */
const eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteTypeDetail::ann_custom() const
{
    return m_ann_custom;
}

/*!
 * @brief This function returns a reference to member ann_custom
 * @return Reference to member ann_custom
 */
eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteTypeDetail::ann_custom()
{
    return m_ann_custom;
}
/*!
 * @brief This function copies the value in member type_name
 * @param _type_name New value to be copied in member type_name
 */
void eprosima::fastrtps::types::CompleteTypeDetail::type_name(
        const eprosima::fastrtps::types::QualifiedTypeName& _type_name)
{
    m_type_name = _type_name;
}

/*!
 * @brief This function moves the value in member type_name
 * @param _type_name New value to be moved in member type_name
 */
void eprosima::fastrtps::types::CompleteTypeDetail::type_name(
        eprosima::fastrtps::types::QualifiedTypeName&& _type_name)
{
    m_type_name = std::move(_type_name);
}

/*!
 * @brief This function returns a constant reference to member type_name
 * @return Constant reference to member type_name
 */
const eprosima::fastrtps::types::QualifiedTypeName& eprosima::fastrtps::types::CompleteTypeDetail::type_name() const
{
    return m_type_name;
}

/*!
 * @brief This function returns a reference to member type_name
 * @return Reference to member type_name
 */
eprosima::fastrtps::types::QualifiedTypeName& eprosima::fastrtps::types::CompleteTypeDetail::type_name()
{
    return m_type_name;
}


size_t eprosima::fastrtps::types::CompleteTypeDetail::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteTypeDetail_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteTypeDetail::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteTypeDetail::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteStructHeader::CompleteStructHeader()
{
    // eprosima::fastrtps::types::TypeIdentifier m_base_type

    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteStructHeader::~CompleteStructHeader()
{


}

eprosima::fastrtps::types::CompleteStructHeader::CompleteStructHeader(
        const CompleteStructHeader& x)
{
    m_base_type = x.m_base_type;

    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteStructHeader::CompleteStructHeader(
        CompleteStructHeader&& x) noexcept 
{
    m_base_type = std::move(x.m_base_type);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteStructHeader& eprosima::fastrtps::types::CompleteStructHeader::operator =(
        const CompleteStructHeader& x)
{

    m_base_type = x.m_base_type;

    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteStructHeader& eprosima::fastrtps::types::CompleteStructHeader::operator =(
        CompleteStructHeader&& x) noexcept
{

    m_base_type = std::move(x.m_base_type);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteStructHeader::operator ==(
        const CompleteStructHeader& x) const
{

    return (m_base_type == x.m_base_type && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteStructHeader::operator !=(
        const CompleteStructHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteStructHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteStructHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.base_type(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteStructHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_base_type;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteStructHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_base_type;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member base_type
 * @param _base_type New value to be copied in member base_type
 */
void eprosima::fastrtps::types::CompleteStructHeader::base_type(
        const eprosima::fastrtps::types::TypeIdentifier& _base_type)
{
    m_base_type = _base_type;
}

/*!
 * @brief This function moves the value in member base_type
 * @param _base_type New value to be moved in member base_type
 */
void eprosima::fastrtps::types::CompleteStructHeader::base_type(
        eprosima::fastrtps::types::TypeIdentifier&& _base_type)
{
    m_base_type = std::move(_base_type);
}

/*!
 * @brief This function returns a constant reference to member base_type
 * @return Constant reference to member base_type
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CompleteStructHeader::base_type() const
{
    return m_base_type;
}

/*!
 * @brief This function returns a reference to member base_type
 * @return Reference to member base_type
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CompleteStructHeader::base_type()
{
    return m_base_type;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteStructHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteStructHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteStructHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteStructHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteStructHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteStructHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteStructHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteStructHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalStructHeader::MinimalStructHeader()
{
    // eprosima::fastrtps::types::TypeIdentifier m_base_type

    // eprosima::fastrtps::types::MinimalTypeDetail m_detail


}

eprosima::fastrtps::types::MinimalStructHeader::~MinimalStructHeader()
{


}

eprosima::fastrtps::types::MinimalStructHeader::MinimalStructHeader(
        const MinimalStructHeader& x)
{
    m_base_type = x.m_base_type;

    m_detail = x.m_detail;
}

eprosima::fastrtps::types::MinimalStructHeader::MinimalStructHeader(
        MinimalStructHeader&& x) noexcept 
{
    m_base_type = std::move(x.m_base_type);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::MinimalStructHeader& eprosima::fastrtps::types::MinimalStructHeader::operator =(
        const MinimalStructHeader& x)
{

    m_base_type = x.m_base_type;

    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::MinimalStructHeader& eprosima::fastrtps::types::MinimalStructHeader::operator =(
        MinimalStructHeader&& x) noexcept
{

    m_base_type = std::move(x.m_base_type);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::MinimalStructHeader::operator ==(
        const MinimalStructHeader& x) const
{

    return (m_base_type == x.m_base_type && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::MinimalStructHeader::operator !=(
        const MinimalStructHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalStructHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalStructHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.base_type(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalStructHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_base_type;scdr << m_detail;
}

void eprosima::fastrtps::types::MinimalStructHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_base_type;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member base_type
 * @param _base_type New value to be copied in member base_type
 */
void eprosima::fastrtps::types::MinimalStructHeader::base_type(
        const eprosima::fastrtps::types::TypeIdentifier& _base_type)
{
    m_base_type = _base_type;
}

/*!
 * @brief This function moves the value in member base_type
 * @param _base_type New value to be moved in member base_type
 */
void eprosima::fastrtps::types::MinimalStructHeader::base_type(
        eprosima::fastrtps::types::TypeIdentifier&& _base_type)
{
    m_base_type = std::move(_base_type);
}

/*!
 * @brief This function returns a constant reference to member base_type
 * @return Constant reference to member base_type
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::MinimalStructHeader::base_type() const
{
    return m_base_type;
}

/*!
 * @brief This function returns a reference to member base_type
 * @return Reference to member base_type
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::MinimalStructHeader::base_type()
{
    return m_base_type;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::MinimalStructHeader::detail(
        const eprosima::fastrtps::types::MinimalTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::MinimalStructHeader::detail(
        eprosima::fastrtps::types::MinimalTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::MinimalTypeDetail& eprosima::fastrtps::types::MinimalStructHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::MinimalTypeDetail& eprosima::fastrtps::types::MinimalStructHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::MinimalStructHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalStructHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalStructHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalStructHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteStructType::CompleteStructType()
{
    // eprosima::fastrtps::types::StructTypeFlag m_struct_flags
    m_struct_flags = static_cast<eprosima::fastrtps::types::StructTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteStructHeader m_header

    // eprosima::fastrtps::types::CompleteStructMemberSeq m_member_seq


}

eprosima::fastrtps::types::CompleteStructType::~CompleteStructType()
{



}

eprosima::fastrtps::types::CompleteStructType::CompleteStructType(
        const CompleteStructType& x)
{
    m_struct_flags = x.m_struct_flags;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;
}

eprosima::fastrtps::types::CompleteStructType::CompleteStructType(
        CompleteStructType&& x) noexcept 
{
    m_struct_flags = x.m_struct_flags;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);
}

eprosima::fastrtps::types::CompleteStructType& eprosima::fastrtps::types::CompleteStructType::operator =(
        const CompleteStructType& x)
{

    m_struct_flags = x.m_struct_flags;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;

    return *this;
}

eprosima::fastrtps::types::CompleteStructType& eprosima::fastrtps::types::CompleteStructType::operator =(
        CompleteStructType&& x) noexcept
{

    m_struct_flags = x.m_struct_flags;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);

    return *this;
}

bool eprosima::fastrtps::types::CompleteStructType::operator ==(
        const CompleteStructType& x) const
{

    return (m_struct_flags == x.m_struct_flags && m_header == x.m_header && m_member_seq == x.m_member_seq);
}

bool eprosima::fastrtps::types::CompleteStructType::operator !=(
        const CompleteStructType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteStructType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteStructType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteStructHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.member_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::CompleteStructMember::getCdrSerializedSize(data.member_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteStructType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_struct_flags;scdr << m_header;scdr << m_member_seq;

}

void eprosima::fastrtps::types::CompleteStructType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_struct_flags = (eprosima::fastrtps::types::StructTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_member_seq;
}

/*!
 * @brief This function sets a value in member struct_flags
 * @param _struct_flags New value for member struct_flags
 */
void eprosima::fastrtps::types::CompleteStructType::struct_flags(
        eprosima::fastrtps::types::StructTypeFlag _struct_flags)
{
    m_struct_flags = _struct_flags;
}

/*!
 * @brief This function returns the value of member struct_flags
 * @return Value of member struct_flags
 */
eprosima::fastrtps::types::StructTypeFlag eprosima::fastrtps::types::CompleteStructType::struct_flags() const
{
    return m_struct_flags;
}

/*!
 * @brief This function returns a reference to member struct_flags
 * @return Reference to member struct_flags
 */
eprosima::fastrtps::types::StructTypeFlag& eprosima::fastrtps::types::CompleteStructType::struct_flags()
{
    return m_struct_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteStructType::header(
        const eprosima::fastrtps::types::CompleteStructHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteStructType::header(
        eprosima::fastrtps::types::CompleteStructHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteStructHeader& eprosima::fastrtps::types::CompleteStructType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteStructHeader& eprosima::fastrtps::types::CompleteStructType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member member_seq
 * @param _member_seq New value to be copied in member member_seq
 */
void eprosima::fastrtps::types::CompleteStructType::member_seq(
        const eprosima::fastrtps::types::CompleteStructMemberSeq& _member_seq)
{
    m_member_seq = _member_seq;
}

/*!
 * @brief This function moves the value in member member_seq
 * @param _member_seq New value to be moved in member member_seq
 */
void eprosima::fastrtps::types::CompleteStructType::member_seq(
        eprosima::fastrtps::types::CompleteStructMemberSeq&& _member_seq)
{
    m_member_seq = std::move(_member_seq);
}

/*!
 * @brief This function returns a constant reference to member member_seq
 * @return Constant reference to member member_seq
 */
const eprosima::fastrtps::types::CompleteStructMemberSeq& eprosima::fastrtps::types::CompleteStructType::member_seq() const
{
    return m_member_seq;
}

/*!
 * @brief This function returns a reference to member member_seq
 * @return Reference to member member_seq
 */
eprosima::fastrtps::types::CompleteStructMemberSeq& eprosima::fastrtps::types::CompleteStructType::member_seq()
{
    return m_member_seq;
}


size_t eprosima::fastrtps::types::CompleteStructType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteStructType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteStructType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteStructType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalStructType::MinimalStructType()
{
    // eprosima::fastrtps::types::StructTypeFlag m_struct_flags
    m_struct_flags = static_cast<eprosima::fastrtps::types::StructTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalStructHeader m_header

    // eprosima::fastrtps::types::MinimalStructMemberSeq m_member_seq


}

eprosima::fastrtps::types::MinimalStructType::~MinimalStructType()
{



}

eprosima::fastrtps::types::MinimalStructType::MinimalStructType(
        const MinimalStructType& x)
{
    m_struct_flags = x.m_struct_flags;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;
}

eprosima::fastrtps::types::MinimalStructType::MinimalStructType(
        MinimalStructType&& x) noexcept 
{
    m_struct_flags = x.m_struct_flags;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);
}

eprosima::fastrtps::types::MinimalStructType& eprosima::fastrtps::types::MinimalStructType::operator =(
        const MinimalStructType& x)
{

    m_struct_flags = x.m_struct_flags;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;

    return *this;
}

eprosima::fastrtps::types::MinimalStructType& eprosima::fastrtps::types::MinimalStructType::operator =(
        MinimalStructType&& x) noexcept
{

    m_struct_flags = x.m_struct_flags;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);

    return *this;
}

bool eprosima::fastrtps::types::MinimalStructType::operator ==(
        const MinimalStructType& x) const
{

    return (m_struct_flags == x.m_struct_flags && m_header == x.m_header && m_member_seq == x.m_member_seq);
}

bool eprosima::fastrtps::types::MinimalStructType::operator !=(
        const MinimalStructType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalStructType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalStructType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalStructHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.member_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::MinimalStructMember::getCdrSerializedSize(data.member_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalStructType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_struct_flags;scdr << m_header;scdr << m_member_seq;

}

void eprosima::fastrtps::types::MinimalStructType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_struct_flags = (eprosima::fastrtps::types::StructTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_member_seq;
}

/*!
 * @brief This function sets a value in member struct_flags
 * @param _struct_flags New value for member struct_flags
 */
void eprosima::fastrtps::types::MinimalStructType::struct_flags(
        eprosima::fastrtps::types::StructTypeFlag _struct_flags)
{
    m_struct_flags = _struct_flags;
}

/*!
 * @brief This function returns the value of member struct_flags
 * @return Value of member struct_flags
 */
eprosima::fastrtps::types::StructTypeFlag eprosima::fastrtps::types::MinimalStructType::struct_flags() const
{
    return m_struct_flags;
}

/*!
 * @brief This function returns a reference to member struct_flags
 * @return Reference to member struct_flags
 */
eprosima::fastrtps::types::StructTypeFlag& eprosima::fastrtps::types::MinimalStructType::struct_flags()
{
    return m_struct_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalStructType::header(
        const eprosima::fastrtps::types::MinimalStructHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalStructType::header(
        eprosima::fastrtps::types::MinimalStructHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalStructHeader& eprosima::fastrtps::types::MinimalStructType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalStructHeader& eprosima::fastrtps::types::MinimalStructType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member member_seq
 * @param _member_seq New value to be copied in member member_seq
 */
void eprosima::fastrtps::types::MinimalStructType::member_seq(
        const eprosima::fastrtps::types::MinimalStructMemberSeq& _member_seq)
{
    m_member_seq = _member_seq;
}

/*!
 * @brief This function moves the value in member member_seq
 * @param _member_seq New value to be moved in member member_seq
 */
void eprosima::fastrtps::types::MinimalStructType::member_seq(
        eprosima::fastrtps::types::MinimalStructMemberSeq&& _member_seq)
{
    m_member_seq = std::move(_member_seq);
}

/*!
 * @brief This function returns a constant reference to member member_seq
 * @return Constant reference to member member_seq
 */
const eprosima::fastrtps::types::MinimalStructMemberSeq& eprosima::fastrtps::types::MinimalStructType::member_seq() const
{
    return m_member_seq;
}

/*!
 * @brief This function returns a reference to member member_seq
 * @return Reference to member member_seq
 */
eprosima::fastrtps::types::MinimalStructMemberSeq& eprosima::fastrtps::types::MinimalStructType::member_seq()
{
    return m_member_seq;
}


size_t eprosima::fastrtps::types::MinimalStructType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalStructType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalStructType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalStructType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CommonUnionMember::CommonUnionMember()
{
    // eprosima::fastrtps::types::MemberId m_member_id
    m_member_id = 0;
    // eprosima::fastrtps::types::UnionMemberFlag m_member_flags
    m_member_flags = static_cast<eprosima::fastrtps::types::UnionMemberFlag>(0);
    // eprosima::fastrtps::types::TypeIdentifier m_type_id

    // eprosima::fastrtps::types::UnionCaseLabelSeq m_label_seq


}

eprosima::fastrtps::types::CommonUnionMember::~CommonUnionMember()
{




}

eprosima::fastrtps::types::CommonUnionMember::CommonUnionMember(
        const CommonUnionMember& x)
{
    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_type_id = x.m_type_id;

    m_label_seq = x.m_label_seq;
}

eprosima::fastrtps::types::CommonUnionMember::CommonUnionMember(
        CommonUnionMember&& x) noexcept 
{
    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_type_id = std::move(x.m_type_id);
    m_label_seq = std::move(x.m_label_seq);
}

eprosima::fastrtps::types::CommonUnionMember& eprosima::fastrtps::types::CommonUnionMember::operator =(
        const CommonUnionMember& x)
{

    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_type_id = x.m_type_id;

    m_label_seq = x.m_label_seq;

    return *this;
}

eprosima::fastrtps::types::CommonUnionMember& eprosima::fastrtps::types::CommonUnionMember::operator =(
        CommonUnionMember&& x) noexcept
{

    m_member_id = x.m_member_id;
    m_member_flags = x.m_member_flags;
    m_type_id = std::move(x.m_type_id);
    m_label_seq = std::move(x.m_label_seq);

    return *this;
}

bool eprosima::fastrtps::types::CommonUnionMember::operator ==(
        const CommonUnionMember& x) const
{

    return (m_member_id == x.m_member_id && m_member_flags == x.m_member_flags && m_type_id == x.m_type_id && m_label_seq == x.m_label_seq);
}

bool eprosima::fastrtps::types::CommonUnionMember::operator !=(
        const CommonUnionMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonUnionMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonUnionMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.label_seq().size() > 0)
    {
        current_alignment += (data.label_seq().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }




    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonUnionMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_member_id;scdr << (uint16_t)m_member_flags;scdr << m_type_id;scdr << m_label_seq;

}

void eprosima::fastrtps::types::CommonUnionMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_member_id;
    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_member_flags = (eprosima::fastrtps::types::UnionMemberFlag)bitmask_value;
    }


    dcdr >> m_type_id;
    dcdr >> m_label_seq;
}

/*!
 * @brief This function sets a value in member member_id
 * @param _member_id New value for member member_id
 */
void eprosima::fastrtps::types::CommonUnionMember::member_id(
        eprosima::fastrtps::types::MemberId _member_id)
{
    m_member_id = _member_id;
}

/*!
 * @brief This function returns the value of member member_id
 * @return Value of member member_id
 */
eprosima::fastrtps::types::MemberId eprosima::fastrtps::types::CommonUnionMember::member_id() const
{
    return m_member_id;
}

/*!
 * @brief This function returns a reference to member member_id
 * @return Reference to member member_id
 */
eprosima::fastrtps::types::MemberId& eprosima::fastrtps::types::CommonUnionMember::member_id()
{
    return m_member_id;
}

/*!
 * @brief This function sets a value in member member_flags
 * @param _member_flags New value for member member_flags
 */
void eprosima::fastrtps::types::CommonUnionMember::member_flags(
        eprosima::fastrtps::types::UnionMemberFlag _member_flags)
{
    m_member_flags = _member_flags;
}

/*!
 * @brief This function returns the value of member member_flags
 * @return Value of member member_flags
 */
eprosima::fastrtps::types::UnionMemberFlag eprosima::fastrtps::types::CommonUnionMember::member_flags() const
{
    return m_member_flags;
}

/*!
 * @brief This function returns a reference to member member_flags
 * @return Reference to member member_flags
 */
eprosima::fastrtps::types::UnionMemberFlag& eprosima::fastrtps::types::CommonUnionMember::member_flags()
{
    return m_member_flags;
}

/*!
 * @brief This function copies the value in member type_id
 * @param _type_id New value to be copied in member type_id
 */
void eprosima::fastrtps::types::CommonUnionMember::type_id(
        const eprosima::fastrtps::types::TypeIdentifier& _type_id)
{
    m_type_id = _type_id;
}

/*!
 * @brief This function moves the value in member type_id
 * @param _type_id New value to be moved in member type_id
 */
void eprosima::fastrtps::types::CommonUnionMember::type_id(
        eprosima::fastrtps::types::TypeIdentifier&& _type_id)
{
    m_type_id = std::move(_type_id);
}

/*!
 * @brief This function returns a constant reference to member type_id
 * @return Constant reference to member type_id
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonUnionMember::type_id() const
{
    return m_type_id;
}

/*!
 * @brief This function returns a reference to member type_id
 * @return Reference to member type_id
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonUnionMember::type_id()
{
    return m_type_id;
}
/*!
 * @brief This function copies the value in member label_seq
 * @param _label_seq New value to be copied in member label_seq
 */
void eprosima::fastrtps::types::CommonUnionMember::label_seq(
        const eprosima::fastrtps::types::UnionCaseLabelSeq& _label_seq)
{
    m_label_seq = _label_seq;
}

/*!
 * @brief This function moves the value in member label_seq
 * @param _label_seq New value to be moved in member label_seq
 */
void eprosima::fastrtps::types::CommonUnionMember::label_seq(
        eprosima::fastrtps::types::UnionCaseLabelSeq&& _label_seq)
{
    m_label_seq = std::move(_label_seq);
}

/*!
 * @brief This function returns a constant reference to member label_seq
 * @return Constant reference to member label_seq
 */
const eprosima::fastrtps::types::UnionCaseLabelSeq& eprosima::fastrtps::types::CommonUnionMember::label_seq() const
{
    return m_label_seq;
}

/*!
 * @brief This function returns a reference to member label_seq
 * @return Reference to member label_seq
 */
eprosima::fastrtps::types::UnionCaseLabelSeq& eprosima::fastrtps::types::CommonUnionMember::label_seq()
{
    return m_label_seq;
}


size_t eprosima::fastrtps::types::CommonUnionMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonUnionMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonUnionMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonUnionMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteUnionMember::CompleteUnionMember()
{
    // eprosima::fastrtps::types::CommonUnionMember m_common

    // eprosima::fastrtps::types::CompleteMemberDetail m_detail


}

eprosima::fastrtps::types::CompleteUnionMember::~CompleteUnionMember()
{


}

eprosima::fastrtps::types::CompleteUnionMember::CompleteUnionMember(
        const CompleteUnionMember& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteUnionMember::CompleteUnionMember(
        CompleteUnionMember&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteUnionMember& eprosima::fastrtps::types::CompleteUnionMember::operator =(
        const CompleteUnionMember& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteUnionMember& eprosima::fastrtps::types::CompleteUnionMember::operator =(
        CompleteUnionMember&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteUnionMember::operator ==(
        const CompleteUnionMember& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteUnionMember::operator !=(
        const CompleteUnionMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteUnionMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteUnionMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonUnionMember::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteUnionMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteUnionMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteUnionMember::common(
        const eprosima::fastrtps::types::CommonUnionMember& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteUnionMember::common(
        eprosima::fastrtps::types::CommonUnionMember&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonUnionMember& eprosima::fastrtps::types::CompleteUnionMember::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonUnionMember& eprosima::fastrtps::types::CompleteUnionMember::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteUnionMember::detail(
        const eprosima::fastrtps::types::CompleteMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteUnionMember::detail(
        eprosima::fastrtps::types::CompleteMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteUnionMember::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteUnionMember::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteUnionMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteUnionMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteUnionMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteUnionMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::MinimalUnionMember::MinimalUnionMember()
{
    // eprosima::fastrtps::types::CommonUnionMember m_common

    // eprosima::fastrtps::types::MinimalMemberDetail m_detail


}

eprosima::fastrtps::types::MinimalUnionMember::~MinimalUnionMember()
{


}

eprosima::fastrtps::types::MinimalUnionMember::MinimalUnionMember(
        const MinimalUnionMember& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::MinimalUnionMember::MinimalUnionMember(
        MinimalUnionMember&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::MinimalUnionMember& eprosima::fastrtps::types::MinimalUnionMember::operator =(
        const MinimalUnionMember& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::MinimalUnionMember& eprosima::fastrtps::types::MinimalUnionMember::operator =(
        MinimalUnionMember&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::MinimalUnionMember::operator ==(
        const MinimalUnionMember& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::MinimalUnionMember::operator !=(
        const MinimalUnionMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalUnionMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalUnionMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonUnionMember::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalUnionMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::MinimalUnionMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalUnionMember::common(
        const eprosima::fastrtps::types::CommonUnionMember& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalUnionMember::common(
        eprosima::fastrtps::types::CommonUnionMember&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonUnionMember& eprosima::fastrtps::types::MinimalUnionMember::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonUnionMember& eprosima::fastrtps::types::MinimalUnionMember::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::MinimalUnionMember::detail(
        const eprosima::fastrtps::types::MinimalMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::MinimalUnionMember::detail(
        eprosima::fastrtps::types::MinimalMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalUnionMember::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalUnionMember::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::MinimalUnionMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalUnionMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalUnionMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalUnionMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CommonDiscriminatorMember::CommonDiscriminatorMember()
{
    // eprosima::fastrtps::types::UnionDiscriminatorFlag m_member_flags
    m_member_flags = static_cast<eprosima::fastrtps::types::UnionDiscriminatorFlag>(0);
    // eprosima::fastrtps::types::TypeIdentifier m_type_id


}

eprosima::fastrtps::types::CommonDiscriminatorMember::~CommonDiscriminatorMember()
{


}

eprosima::fastrtps::types::CommonDiscriminatorMember::CommonDiscriminatorMember(
        const CommonDiscriminatorMember& x)
{
    m_member_flags = x.m_member_flags;
    m_type_id = x.m_type_id;

}

eprosima::fastrtps::types::CommonDiscriminatorMember::CommonDiscriminatorMember(
        CommonDiscriminatorMember&& x) noexcept 
{
    m_member_flags = x.m_member_flags;
    m_type_id = std::move(x.m_type_id);
}

eprosima::fastrtps::types::CommonDiscriminatorMember& eprosima::fastrtps::types::CommonDiscriminatorMember::operator =(
        const CommonDiscriminatorMember& x)
{

    m_member_flags = x.m_member_flags;
    m_type_id = x.m_type_id;


    return *this;
}

eprosima::fastrtps::types::CommonDiscriminatorMember& eprosima::fastrtps::types::CommonDiscriminatorMember::operator =(
        CommonDiscriminatorMember&& x) noexcept
{

    m_member_flags = x.m_member_flags;
    m_type_id = std::move(x.m_type_id);

    return *this;
}

bool eprosima::fastrtps::types::CommonDiscriminatorMember::operator ==(
        const CommonDiscriminatorMember& x) const
{

    return (m_member_flags == x.m_member_flags && m_type_id == x.m_type_id);
}

bool eprosima::fastrtps::types::CommonDiscriminatorMember::operator !=(
        const CommonDiscriminatorMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonDiscriminatorMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonDiscriminatorMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type_id(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonDiscriminatorMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_member_flags;scdr << m_type_id;
}

void eprosima::fastrtps::types::CommonDiscriminatorMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_member_flags = (eprosima::fastrtps::types::UnionDiscriminatorFlag)bitmask_value;
    }


    dcdr >> m_type_id;
}

/*!
 * @brief This function sets a value in member member_flags
 * @param _member_flags New value for member member_flags
 */
void eprosima::fastrtps::types::CommonDiscriminatorMember::member_flags(
        eprosima::fastrtps::types::UnionDiscriminatorFlag _member_flags)
{
    m_member_flags = _member_flags;
}

/*!
 * @brief This function returns the value of member member_flags
 * @return Value of member member_flags
 */
eprosima::fastrtps::types::UnionDiscriminatorFlag eprosima::fastrtps::types::CommonDiscriminatorMember::member_flags() const
{
    return m_member_flags;
}

/*!
 * @brief This function returns a reference to member member_flags
 * @return Reference to member member_flags
 */
eprosima::fastrtps::types::UnionDiscriminatorFlag& eprosima::fastrtps::types::CommonDiscriminatorMember::member_flags()
{
    return m_member_flags;
}

/*!
 * @brief This function copies the value in member type_id
 * @param _type_id New value to be copied in member type_id
 */
void eprosima::fastrtps::types::CommonDiscriminatorMember::type_id(
        const eprosima::fastrtps::types::TypeIdentifier& _type_id)
{
    m_type_id = _type_id;
}

/*!
 * @brief This function moves the value in member type_id
 * @param _type_id New value to be moved in member type_id
 */
void eprosima::fastrtps::types::CommonDiscriminatorMember::type_id(
        eprosima::fastrtps::types::TypeIdentifier&& _type_id)
{
    m_type_id = std::move(_type_id);
}

/*!
 * @brief This function returns a constant reference to member type_id
 * @return Constant reference to member type_id
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonDiscriminatorMember::type_id() const
{
    return m_type_id;
}

/*!
 * @brief This function returns a reference to member type_id
 * @return Reference to member type_id
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonDiscriminatorMember::type_id()
{
    return m_type_id;
}


size_t eprosima::fastrtps::types::CommonDiscriminatorMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonDiscriminatorMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonDiscriminatorMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonDiscriminatorMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteDiscriminatorMember::CompleteDiscriminatorMember()
{
    // eprosima::fastrtps::types::CommonDiscriminatorMember m_common

    // eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations m_ann_builtin

    // eprosima::fastrtps::types::AppliedAnnotationSeq m_ann_custom


}

eprosima::fastrtps::types::CompleteDiscriminatorMember::~CompleteDiscriminatorMember()
{



}

eprosima::fastrtps::types::CompleteDiscriminatorMember::CompleteDiscriminatorMember(
        const CompleteDiscriminatorMember& x)
{
    m_common = x.m_common;
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;
}

eprosima::fastrtps::types::CompleteDiscriminatorMember::CompleteDiscriminatorMember(
        CompleteDiscriminatorMember&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);
}

eprosima::fastrtps::types::CompleteDiscriminatorMember& eprosima::fastrtps::types::CompleteDiscriminatorMember::operator =(
        const CompleteDiscriminatorMember& x)
{

    m_common = x.m_common;
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;

    return *this;
}

eprosima::fastrtps::types::CompleteDiscriminatorMember& eprosima::fastrtps::types::CompleteDiscriminatorMember::operator =(
        CompleteDiscriminatorMember&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);

    return *this;
}

bool eprosima::fastrtps::types::CompleteDiscriminatorMember::operator ==(
        const CompleteDiscriminatorMember& x) const
{

    return (m_common == x.m_common && m_ann_builtin == x.m_ann_builtin && m_ann_custom == x.m_ann_custom);
}

bool eprosima::fastrtps::types::CompleteDiscriminatorMember::operator !=(
        const CompleteDiscriminatorMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteDiscriminatorMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteDiscriminatorMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonDiscriminatorMember::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations::getCdrSerializedSize(data.ann_builtin(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.ann_custom().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::AppliedAnnotation::getCdrSerializedSize(data.ann_custom().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteDiscriminatorMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_ann_builtin;scdr << m_ann_custom;

}

void eprosima::fastrtps::types::CompleteDiscriminatorMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_ann_builtin;
    dcdr >> m_ann_custom;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteDiscriminatorMember::common(
        const eprosima::fastrtps::types::CommonDiscriminatorMember& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteDiscriminatorMember::common(
        eprosima::fastrtps::types::CommonDiscriminatorMember&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonDiscriminatorMember& eprosima::fastrtps::types::CompleteDiscriminatorMember::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonDiscriminatorMember& eprosima::fastrtps::types::CompleteDiscriminatorMember::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member ann_builtin
 * @param _ann_builtin New value to be copied in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_builtin(
        const eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& _ann_builtin)
{
    m_ann_builtin = _ann_builtin;
}

/*!
 * @brief This function moves the value in member ann_builtin
 * @param _ann_builtin New value to be moved in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_builtin(
        eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations&& _ann_builtin)
{
    m_ann_builtin = std::move(_ann_builtin);
}

/*!
 * @brief This function returns a constant reference to member ann_builtin
 * @return Constant reference to member ann_builtin
 */
const eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_builtin() const
{
    return m_ann_builtin;
}

/*!
 * @brief This function returns a reference to member ann_builtin
 * @return Reference to member ann_builtin
 */
eprosima::fastrtps::types::AppliedBuiltinTypeAnnotations& eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_builtin()
{
    return m_ann_builtin;
}
/*!
 * @brief This function copies the value in member ann_custom
 * @param _ann_custom New value to be copied in member ann_custom
 */
void eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_custom(
        const eprosima::fastrtps::types::AppliedAnnotationSeq& _ann_custom)
{
    m_ann_custom = _ann_custom;
}

/*!
 * @brief This function moves the value in member ann_custom
 * @param _ann_custom New value to be moved in member ann_custom
 */
void eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_custom(
        eprosima::fastrtps::types::AppliedAnnotationSeq&& _ann_custom)
{
    m_ann_custom = std::move(_ann_custom);
}

/*!
 * @brief This function returns a constant reference to member ann_custom
 * @return Constant reference to member ann_custom
 */
const eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_custom() const
{
    return m_ann_custom;
}

/*!
 * @brief This function returns a reference to member ann_custom
 * @return Reference to member ann_custom
 */
eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteDiscriminatorMember::ann_custom()
{
    return m_ann_custom;
}


size_t eprosima::fastrtps::types::CompleteDiscriminatorMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteDiscriminatorMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteDiscriminatorMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteDiscriminatorMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalDiscriminatorMember::MinimalDiscriminatorMember()
{
    // eprosima::fastrtps::types::CommonDiscriminatorMember m_common


}

eprosima::fastrtps::types::MinimalDiscriminatorMember::~MinimalDiscriminatorMember()
{
}

eprosima::fastrtps::types::MinimalDiscriminatorMember::MinimalDiscriminatorMember(
        const MinimalDiscriminatorMember& x)
{
    m_common = x.m_common;
}

eprosima::fastrtps::types::MinimalDiscriminatorMember::MinimalDiscriminatorMember(
        MinimalDiscriminatorMember&& x) noexcept 
{
    m_common = std::move(x.m_common);
}

eprosima::fastrtps::types::MinimalDiscriminatorMember& eprosima::fastrtps::types::MinimalDiscriminatorMember::operator =(
        const MinimalDiscriminatorMember& x)
{

    m_common = x.m_common;

    return *this;
}

eprosima::fastrtps::types::MinimalDiscriminatorMember& eprosima::fastrtps::types::MinimalDiscriminatorMember::operator =(
        MinimalDiscriminatorMember&& x) noexcept
{

    m_common = std::move(x.m_common);

    return *this;
}

bool eprosima::fastrtps::types::MinimalDiscriminatorMember::operator ==(
        const MinimalDiscriminatorMember& x) const
{

    return (m_common == x.m_common);
}

bool eprosima::fastrtps::types::MinimalDiscriminatorMember::operator !=(
        const MinimalDiscriminatorMember& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalDiscriminatorMember::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalDiscriminatorMember& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonDiscriminatorMember::getCdrSerializedSize(data.common(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalDiscriminatorMember::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;
}

void eprosima::fastrtps::types::MinimalDiscriminatorMember::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalDiscriminatorMember::common(
        const eprosima::fastrtps::types::CommonDiscriminatorMember& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalDiscriminatorMember::common(
        eprosima::fastrtps::types::CommonDiscriminatorMember&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonDiscriminatorMember& eprosima::fastrtps::types::MinimalDiscriminatorMember::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonDiscriminatorMember& eprosima::fastrtps::types::MinimalDiscriminatorMember::common()
{
    return m_common;
}


size_t eprosima::fastrtps::types::MinimalDiscriminatorMember::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalDiscriminatorMember_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalDiscriminatorMember::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalDiscriminatorMember::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteUnionHeader::CompleteUnionHeader()
{
    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteUnionHeader::~CompleteUnionHeader()
{
}

eprosima::fastrtps::types::CompleteUnionHeader::CompleteUnionHeader(
        const CompleteUnionHeader& x)
{
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteUnionHeader::CompleteUnionHeader(
        CompleteUnionHeader&& x) noexcept 
{
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteUnionHeader& eprosima::fastrtps::types::CompleteUnionHeader::operator =(
        const CompleteUnionHeader& x)
{

    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteUnionHeader& eprosima::fastrtps::types::CompleteUnionHeader::operator =(
        CompleteUnionHeader&& x) noexcept
{

    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteUnionHeader::operator ==(
        const CompleteUnionHeader& x) const
{

    return (m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteUnionHeader::operator !=(
        const CompleteUnionHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteUnionHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteUnionHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteUnionHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteUnionHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteUnionHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteUnionHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteUnionHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteUnionHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteUnionHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteUnionHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteUnionHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteUnionHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteUnionHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteUnionHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalUnionHeader::MinimalUnionHeader()
{
    // eprosima::fastrtps::types::MinimalTypeDetail m_detail


}

eprosima::fastrtps::types::MinimalUnionHeader::~MinimalUnionHeader()
{
}

eprosima::fastrtps::types::MinimalUnionHeader::MinimalUnionHeader(
        const MinimalUnionHeader& x)
{
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::MinimalUnionHeader::MinimalUnionHeader(
        MinimalUnionHeader&& x) noexcept 
{
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::MinimalUnionHeader& eprosima::fastrtps::types::MinimalUnionHeader::operator =(
        const MinimalUnionHeader& x)
{

    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::MinimalUnionHeader& eprosima::fastrtps::types::MinimalUnionHeader::operator =(
        MinimalUnionHeader&& x) noexcept
{

    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::MinimalUnionHeader::operator ==(
        const MinimalUnionHeader& x) const
{

    return (m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::MinimalUnionHeader::operator !=(
        const MinimalUnionHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalUnionHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalUnionHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalUnionHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalUnionHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::MinimalTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalUnionHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_detail;
}

void eprosima::fastrtps::types::MinimalUnionHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::MinimalUnionHeader::detail(
        const eprosima::fastrtps::types::MinimalTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::MinimalUnionHeader::detail(
        eprosima::fastrtps::types::MinimalTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::MinimalTypeDetail& eprosima::fastrtps::types::MinimalUnionHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::MinimalTypeDetail& eprosima::fastrtps::types::MinimalUnionHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::MinimalUnionHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalUnionHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalUnionHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalUnionHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteUnionType::CompleteUnionType()
{
    // eprosima::fastrtps::types::UnionTypeFlag m_union_flags
    m_union_flags = static_cast<eprosima::fastrtps::types::UnionTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteUnionHeader m_header

    // eprosima::fastrtps::types::CompleteDiscriminatorMember m_discriminator

    // eprosima::fastrtps::types::CompleteUnionMemberSeq m_member_seq


}

eprosima::fastrtps::types::CompleteUnionType::~CompleteUnionType()
{




}

eprosima::fastrtps::types::CompleteUnionType::CompleteUnionType(
        const CompleteUnionType& x)
{
    m_union_flags = x.m_union_flags;
    m_header = x.m_header;
    m_discriminator = x.m_discriminator;
    m_member_seq = x.m_member_seq;
}

eprosima::fastrtps::types::CompleteUnionType::CompleteUnionType(
        CompleteUnionType&& x) noexcept 
{
    m_union_flags = x.m_union_flags;
    m_header = std::move(x.m_header);
    m_discriminator = std::move(x.m_discriminator);
    m_member_seq = std::move(x.m_member_seq);
}

eprosima::fastrtps::types::CompleteUnionType& eprosima::fastrtps::types::CompleteUnionType::operator =(
        const CompleteUnionType& x)
{

    m_union_flags = x.m_union_flags;
    m_header = x.m_header;
    m_discriminator = x.m_discriminator;
    m_member_seq = x.m_member_seq;

    return *this;
}

eprosima::fastrtps::types::CompleteUnionType& eprosima::fastrtps::types::CompleteUnionType::operator =(
        CompleteUnionType&& x) noexcept
{

    m_union_flags = x.m_union_flags;
    m_header = std::move(x.m_header);
    m_discriminator = std::move(x.m_discriminator);
    m_member_seq = std::move(x.m_member_seq);

    return *this;
}

bool eprosima::fastrtps::types::CompleteUnionType::operator ==(
        const CompleteUnionType& x) const
{

    return (m_union_flags == x.m_union_flags && m_header == x.m_header && m_discriminator == x.m_discriminator && m_member_seq == x.m_member_seq);
}

bool eprosima::fastrtps::types::CompleteUnionType::operator !=(
        const CompleteUnionType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteUnionType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteUnionType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteUnionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteDiscriminatorMember::getCdrSerializedSize(data.discriminator(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.member_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::CompleteUnionMember::getCdrSerializedSize(data.member_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteUnionType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_union_flags;scdr << m_header;scdr << m_discriminator;scdr << m_member_seq;

}

void eprosima::fastrtps::types::CompleteUnionType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_union_flags = (eprosima::fastrtps::types::UnionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_discriminator;
    dcdr >> m_member_seq;
}

/*!
 * @brief This function sets a value in member union_flags
 * @param _union_flags New value for member union_flags
 */
void eprosima::fastrtps::types::CompleteUnionType::union_flags(
        eprosima::fastrtps::types::UnionTypeFlag _union_flags)
{
    m_union_flags = _union_flags;
}

/*!
 * @brief This function returns the value of member union_flags
 * @return Value of member union_flags
 */
eprosima::fastrtps::types::UnionTypeFlag eprosima::fastrtps::types::CompleteUnionType::union_flags() const
{
    return m_union_flags;
}

/*!
 * @brief This function returns a reference to member union_flags
 * @return Reference to member union_flags
 */
eprosima::fastrtps::types::UnionTypeFlag& eprosima::fastrtps::types::CompleteUnionType::union_flags()
{
    return m_union_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteUnionType::header(
        const eprosima::fastrtps::types::CompleteUnionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteUnionType::header(
        eprosima::fastrtps::types::CompleteUnionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteUnionHeader& eprosima::fastrtps::types::CompleteUnionType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteUnionHeader& eprosima::fastrtps::types::CompleteUnionType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member discriminator
 * @param _discriminator New value to be copied in member discriminator
 */
void eprosima::fastrtps::types::CompleteUnionType::discriminator(
        const eprosima::fastrtps::types::CompleteDiscriminatorMember& _discriminator)
{
    m_discriminator = _discriminator;
}

/*!
 * @brief This function moves the value in member discriminator
 * @param _discriminator New value to be moved in member discriminator
 */
void eprosima::fastrtps::types::CompleteUnionType::discriminator(
        eprosima::fastrtps::types::CompleteDiscriminatorMember&& _discriminator)
{
    m_discriminator = std::move(_discriminator);
}

/*!
 * @brief This function returns a constant reference to member discriminator
 * @return Constant reference to member discriminator
 */
const eprosima::fastrtps::types::CompleteDiscriminatorMember& eprosima::fastrtps::types::CompleteUnionType::discriminator() const
{
    return m_discriminator;
}

/*!
 * @brief This function returns a reference to member discriminator
 * @return Reference to member discriminator
 */
eprosima::fastrtps::types::CompleteDiscriminatorMember& eprosima::fastrtps::types::CompleteUnionType::discriminator()
{
    return m_discriminator;
}
/*!
 * @brief This function copies the value in member member_seq
 * @param _member_seq New value to be copied in member member_seq
 */
void eprosima::fastrtps::types::CompleteUnionType::member_seq(
        const eprosima::fastrtps::types::CompleteUnionMemberSeq& _member_seq)
{
    m_member_seq = _member_seq;
}

/*!
 * @brief This function moves the value in member member_seq
 * @param _member_seq New value to be moved in member member_seq
 */
void eprosima::fastrtps::types::CompleteUnionType::member_seq(
        eprosima::fastrtps::types::CompleteUnionMemberSeq&& _member_seq)
{
    m_member_seq = std::move(_member_seq);
}

/*!
 * @brief This function returns a constant reference to member member_seq
 * @return Constant reference to member member_seq
 */
const eprosima::fastrtps::types::CompleteUnionMemberSeq& eprosima::fastrtps::types::CompleteUnionType::member_seq() const
{
    return m_member_seq;
}

/*!
 * @brief This function returns a reference to member member_seq
 * @return Reference to member member_seq
 */
eprosima::fastrtps::types::CompleteUnionMemberSeq& eprosima::fastrtps::types::CompleteUnionType::member_seq()
{
    return m_member_seq;
}


size_t eprosima::fastrtps::types::CompleteUnionType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteUnionType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteUnionType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteUnionType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalUnionType::MinimalUnionType()
{
    // eprosima::fastrtps::types::UnionTypeFlag m_union_flags
    m_union_flags = static_cast<eprosima::fastrtps::types::UnionTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalUnionHeader m_header

    // eprosima::fastrtps::types::MinimalDiscriminatorMember m_discriminator

    // eprosima::fastrtps::types::MinimalUnionMemberSeq m_member_seq


}

eprosima::fastrtps::types::MinimalUnionType::~MinimalUnionType()
{




}

eprosima::fastrtps::types::MinimalUnionType::MinimalUnionType(
        const MinimalUnionType& x)
{
    m_union_flags = x.m_union_flags;
    m_header = x.m_header;
    m_discriminator = x.m_discriminator;
    m_member_seq = x.m_member_seq;
}

eprosima::fastrtps::types::MinimalUnionType::MinimalUnionType(
        MinimalUnionType&& x) noexcept 
{
    m_union_flags = x.m_union_flags;
    m_header = std::move(x.m_header);
    m_discriminator = std::move(x.m_discriminator);
    m_member_seq = std::move(x.m_member_seq);
}

eprosima::fastrtps::types::MinimalUnionType& eprosima::fastrtps::types::MinimalUnionType::operator =(
        const MinimalUnionType& x)
{

    m_union_flags = x.m_union_flags;
    m_header = x.m_header;
    m_discriminator = x.m_discriminator;
    m_member_seq = x.m_member_seq;

    return *this;
}

eprosima::fastrtps::types::MinimalUnionType& eprosima::fastrtps::types::MinimalUnionType::operator =(
        MinimalUnionType&& x) noexcept
{

    m_union_flags = x.m_union_flags;
    m_header = std::move(x.m_header);
    m_discriminator = std::move(x.m_discriminator);
    m_member_seq = std::move(x.m_member_seq);

    return *this;
}

bool eprosima::fastrtps::types::MinimalUnionType::operator ==(
        const MinimalUnionType& x) const
{

    return (m_union_flags == x.m_union_flags && m_header == x.m_header && m_discriminator == x.m_discriminator && m_member_seq == x.m_member_seq);
}

bool eprosima::fastrtps::types::MinimalUnionType::operator !=(
        const MinimalUnionType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalUnionType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalUnionType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalUnionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalDiscriminatorMember::getCdrSerializedSize(data.discriminator(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.member_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::MinimalUnionMember::getCdrSerializedSize(data.member_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalUnionType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_union_flags;scdr << m_header;scdr << m_discriminator;scdr << m_member_seq;

}

void eprosima::fastrtps::types::MinimalUnionType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_union_flags = (eprosima::fastrtps::types::UnionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_discriminator;
    dcdr >> m_member_seq;
}

/*!
 * @brief This function sets a value in member union_flags
 * @param _union_flags New value for member union_flags
 */
void eprosima::fastrtps::types::MinimalUnionType::union_flags(
        eprosima::fastrtps::types::UnionTypeFlag _union_flags)
{
    m_union_flags = _union_flags;
}

/*!
 * @brief This function returns the value of member union_flags
 * @return Value of member union_flags
 */
eprosima::fastrtps::types::UnionTypeFlag eprosima::fastrtps::types::MinimalUnionType::union_flags() const
{
    return m_union_flags;
}

/*!
 * @brief This function returns a reference to member union_flags
 * @return Reference to member union_flags
 */
eprosima::fastrtps::types::UnionTypeFlag& eprosima::fastrtps::types::MinimalUnionType::union_flags()
{
    return m_union_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalUnionType::header(
        const eprosima::fastrtps::types::MinimalUnionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalUnionType::header(
        eprosima::fastrtps::types::MinimalUnionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalUnionHeader& eprosima::fastrtps::types::MinimalUnionType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalUnionHeader& eprosima::fastrtps::types::MinimalUnionType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member discriminator
 * @param _discriminator New value to be copied in member discriminator
 */
void eprosima::fastrtps::types::MinimalUnionType::discriminator(
        const eprosima::fastrtps::types::MinimalDiscriminatorMember& _discriminator)
{
    m_discriminator = _discriminator;
}

/*!
 * @brief This function moves the value in member discriminator
 * @param _discriminator New value to be moved in member discriminator
 */
void eprosima::fastrtps::types::MinimalUnionType::discriminator(
        eprosima::fastrtps::types::MinimalDiscriminatorMember&& _discriminator)
{
    m_discriminator = std::move(_discriminator);
}

/*!
 * @brief This function returns a constant reference to member discriminator
 * @return Constant reference to member discriminator
 */
const eprosima::fastrtps::types::MinimalDiscriminatorMember& eprosima::fastrtps::types::MinimalUnionType::discriminator() const
{
    return m_discriminator;
}

/*!
 * @brief This function returns a reference to member discriminator
 * @return Reference to member discriminator
 */
eprosima::fastrtps::types::MinimalDiscriminatorMember& eprosima::fastrtps::types::MinimalUnionType::discriminator()
{
    return m_discriminator;
}
/*!
 * @brief This function copies the value in member member_seq
 * @param _member_seq New value to be copied in member member_seq
 */
void eprosima::fastrtps::types::MinimalUnionType::member_seq(
        const eprosima::fastrtps::types::MinimalUnionMemberSeq& _member_seq)
{
    m_member_seq = _member_seq;
}

/*!
 * @brief This function moves the value in member member_seq
 * @param _member_seq New value to be moved in member member_seq
 */
void eprosima::fastrtps::types::MinimalUnionType::member_seq(
        eprosima::fastrtps::types::MinimalUnionMemberSeq&& _member_seq)
{
    m_member_seq = std::move(_member_seq);
}

/*!
 * @brief This function returns a constant reference to member member_seq
 * @return Constant reference to member member_seq
 */
const eprosima::fastrtps::types::MinimalUnionMemberSeq& eprosima::fastrtps::types::MinimalUnionType::member_seq() const
{
    return m_member_seq;
}

/*!
 * @brief This function returns a reference to member member_seq
 * @return Reference to member member_seq
 */
eprosima::fastrtps::types::MinimalUnionMemberSeq& eprosima::fastrtps::types::MinimalUnionType::member_seq()
{
    return m_member_seq;
}


size_t eprosima::fastrtps::types::MinimalUnionType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalUnionType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalUnionType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalUnionType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonAnnotationParameter::CommonAnnotationParameter()
{
    // eprosima::fastrtps::types::AnnotationParameterFlag m_member_flags
    m_member_flags = static_cast<eprosima::fastrtps::types::AnnotationParameterFlag>(0);
    // eprosima::fastrtps::types::TypeIdentifier m_member_type_id


}

eprosima::fastrtps::types::CommonAnnotationParameter::~CommonAnnotationParameter()
{


}

eprosima::fastrtps::types::CommonAnnotationParameter::CommonAnnotationParameter(
        const CommonAnnotationParameter& x)
{
    m_member_flags = x.m_member_flags;
    m_member_type_id = x.m_member_type_id;

}

eprosima::fastrtps::types::CommonAnnotationParameter::CommonAnnotationParameter(
        CommonAnnotationParameter&& x) noexcept 
{
    m_member_flags = x.m_member_flags;
    m_member_type_id = std::move(x.m_member_type_id);
}

eprosima::fastrtps::types::CommonAnnotationParameter& eprosima::fastrtps::types::CommonAnnotationParameter::operator =(
        const CommonAnnotationParameter& x)
{

    m_member_flags = x.m_member_flags;
    m_member_type_id = x.m_member_type_id;


    return *this;
}

eprosima::fastrtps::types::CommonAnnotationParameter& eprosima::fastrtps::types::CommonAnnotationParameter::operator =(
        CommonAnnotationParameter&& x) noexcept
{

    m_member_flags = x.m_member_flags;
    m_member_type_id = std::move(x.m_member_type_id);

    return *this;
}

bool eprosima::fastrtps::types::CommonAnnotationParameter::operator ==(
        const CommonAnnotationParameter& x) const
{

    return (m_member_flags == x.m_member_flags && m_member_type_id == x.m_member_type_id);
}

bool eprosima::fastrtps::types::CommonAnnotationParameter::operator !=(
        const CommonAnnotationParameter& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonAnnotationParameter::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonAnnotationParameter& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.member_type_id(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonAnnotationParameter::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_member_flags;scdr << m_member_type_id;
}

void eprosima::fastrtps::types::CommonAnnotationParameter::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_member_flags = (eprosima::fastrtps::types::AnnotationParameterFlag)bitmask_value;
    }


    dcdr >> m_member_type_id;
}

/*!
 * @brief This function sets a value in member member_flags
 * @param _member_flags New value for member member_flags
 */
void eprosima::fastrtps::types::CommonAnnotationParameter::member_flags(
        eprosima::fastrtps::types::AnnotationParameterFlag _member_flags)
{
    m_member_flags = _member_flags;
}

/*!
 * @brief This function returns the value of member member_flags
 * @return Value of member member_flags
 */
eprosima::fastrtps::types::AnnotationParameterFlag eprosima::fastrtps::types::CommonAnnotationParameter::member_flags() const
{
    return m_member_flags;
}

/*!
 * @brief This function returns a reference to member member_flags
 * @return Reference to member member_flags
 */
eprosima::fastrtps::types::AnnotationParameterFlag& eprosima::fastrtps::types::CommonAnnotationParameter::member_flags()
{
    return m_member_flags;
}

/*!
 * @brief This function copies the value in member member_type_id
 * @param _member_type_id New value to be copied in member member_type_id
 */
void eprosima::fastrtps::types::CommonAnnotationParameter::member_type_id(
        const eprosima::fastrtps::types::TypeIdentifier& _member_type_id)
{
    m_member_type_id = _member_type_id;
}

/*!
 * @brief This function moves the value in member member_type_id
 * @param _member_type_id New value to be moved in member member_type_id
 */
void eprosima::fastrtps::types::CommonAnnotationParameter::member_type_id(
        eprosima::fastrtps::types::TypeIdentifier&& _member_type_id)
{
    m_member_type_id = std::move(_member_type_id);
}

/*!
 * @brief This function returns a constant reference to member member_type_id
 * @return Constant reference to member member_type_id
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonAnnotationParameter::member_type_id() const
{
    return m_member_type_id;
}

/*!
 * @brief This function returns a reference to member member_type_id
 * @return Reference to member member_type_id
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonAnnotationParameter::member_type_id()
{
    return m_member_type_id;
}


size_t eprosima::fastrtps::types::CommonAnnotationParameter::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonAnnotationParameter_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonAnnotationParameter::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonAnnotationParameter::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteAnnotationParameter::CompleteAnnotationParameter()
{
    // eprosima::fastrtps::types::CommonAnnotationParameter m_common

    // eprosima::fastrtps::types::MemberName m_name
    m_name ="";
    // eprosima::fastrtps::types::AnnotationParameterValue m_default_value


}

eprosima::fastrtps::types::CompleteAnnotationParameter::~CompleteAnnotationParameter()
{



}

eprosima::fastrtps::types::CompleteAnnotationParameter::CompleteAnnotationParameter(
        const CompleteAnnotationParameter& x)
{
    m_common = x.m_common;
    m_name = x.m_name;
    m_default_value = x.m_default_value;
}

eprosima::fastrtps::types::CompleteAnnotationParameter::CompleteAnnotationParameter(
        CompleteAnnotationParameter&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_name = std::move(x.m_name);
    m_default_value = std::move(x.m_default_value);
}

eprosima::fastrtps::types::CompleteAnnotationParameter& eprosima::fastrtps::types::CompleteAnnotationParameter::operator =(
        const CompleteAnnotationParameter& x)
{

    m_common = x.m_common;
    m_name = x.m_name;
    m_default_value = x.m_default_value;

    return *this;
}

eprosima::fastrtps::types::CompleteAnnotationParameter& eprosima::fastrtps::types::CompleteAnnotationParameter::operator =(
        CompleteAnnotationParameter&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_name = std::move(x.m_name);
    m_default_value = std::move(x.m_default_value);

    return *this;
}

bool eprosima::fastrtps::types::CompleteAnnotationParameter::operator ==(
        const CompleteAnnotationParameter& x) const
{

    return (m_common == x.m_common && m_name == x.m_name && m_default_value == x.m_default_value);
}

bool eprosima::fastrtps::types::CompleteAnnotationParameter::operator !=(
        const CompleteAnnotationParameter& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteAnnotationParameter::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteAnnotationParameter& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonAnnotationParameter::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += eprosima::fastrtps::types::AnnotationParameterValue::getCdrSerializedSize(data.default_value(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteAnnotationParameter::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_name.c_str();scdr << m_default_value;
}

void eprosima::fastrtps::types::CompleteAnnotationParameter::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    {
        std::string aux;
        dcdr >> aux;
        m_name = aux.c_str();
    }
    dcdr >> m_default_value;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteAnnotationParameter::common(
        const eprosima::fastrtps::types::CommonAnnotationParameter& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteAnnotationParameter::common(
        eprosima::fastrtps::types::CommonAnnotationParameter&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonAnnotationParameter& eprosima::fastrtps::types::CompleteAnnotationParameter::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonAnnotationParameter& eprosima::fastrtps::types::CompleteAnnotationParameter::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void eprosima::fastrtps::types::CompleteAnnotationParameter::name(
        const eprosima::fastrtps::types::MemberName& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void eprosima::fastrtps::types::CompleteAnnotationParameter::name(
        eprosima::fastrtps::types::MemberName&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const eprosima::fastrtps::types::MemberName& eprosima::fastrtps::types::CompleteAnnotationParameter::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
eprosima::fastrtps::types::MemberName& eprosima::fastrtps::types::CompleteAnnotationParameter::name()
{
    return m_name;
}
/*!
 * @brief This function copies the value in member default_value
 * @param _default_value New value to be copied in member default_value
 */
void eprosima::fastrtps::types::CompleteAnnotationParameter::default_value(
        const eprosima::fastrtps::types::AnnotationParameterValue& _default_value)
{
    m_default_value = _default_value;
}

/*!
 * @brief This function moves the value in member default_value
 * @param _default_value New value to be moved in member default_value
 */
void eprosima::fastrtps::types::CompleteAnnotationParameter::default_value(
        eprosima::fastrtps::types::AnnotationParameterValue&& _default_value)
{
    m_default_value = std::move(_default_value);
}

/*!
 * @brief This function returns a constant reference to member default_value
 * @return Constant reference to member default_value
 */
const eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::CompleteAnnotationParameter::default_value() const
{
    return m_default_value;
}

/*!
 * @brief This function returns a reference to member default_value
 * @return Reference to member default_value
 */
eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::CompleteAnnotationParameter::default_value()
{
    return m_default_value;
}


size_t eprosima::fastrtps::types::CompleteAnnotationParameter::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAnnotationParameter_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteAnnotationParameter::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteAnnotationParameter::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::MinimalAnnotationParameter::MinimalAnnotationParameter()
{
    // eprosima::fastrtps::types::CommonAnnotationParameter m_common

    // eprosima::fastrtps::types::NameHash m_name_hash
    memset(&m_name_hash, 0, (4) * 1);
    // eprosima::fastrtps::types::AnnotationParameterValue m_default_value


}

eprosima::fastrtps::types::MinimalAnnotationParameter::~MinimalAnnotationParameter()
{



}

eprosima::fastrtps::types::MinimalAnnotationParameter::MinimalAnnotationParameter(
        const MinimalAnnotationParameter& x)
{
    m_common = x.m_common;
    m_name_hash = x.m_name_hash;
    m_default_value = x.m_default_value;
}

eprosima::fastrtps::types::MinimalAnnotationParameter::MinimalAnnotationParameter(
        MinimalAnnotationParameter&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_name_hash = std::move(x.m_name_hash);
    m_default_value = std::move(x.m_default_value);
}

eprosima::fastrtps::types::MinimalAnnotationParameter& eprosima::fastrtps::types::MinimalAnnotationParameter::operator =(
        const MinimalAnnotationParameter& x)
{

    m_common = x.m_common;
    m_name_hash = x.m_name_hash;
    m_default_value = x.m_default_value;

    return *this;
}

eprosima::fastrtps::types::MinimalAnnotationParameter& eprosima::fastrtps::types::MinimalAnnotationParameter::operator =(
        MinimalAnnotationParameter&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_name_hash = std::move(x.m_name_hash);
    m_default_value = std::move(x.m_default_value);

    return *this;
}

bool eprosima::fastrtps::types::MinimalAnnotationParameter::operator ==(
        const MinimalAnnotationParameter& x) const
{

    return (m_common == x.m_common && m_name_hash == x.m_name_hash && m_default_value == x.m_default_value);
}

bool eprosima::fastrtps::types::MinimalAnnotationParameter::operator !=(
        const MinimalAnnotationParameter& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalAnnotationParameter::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalAnnotationParameter& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonAnnotationParameter::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += eprosima::fastrtps::types::AnnotationParameterValue::getCdrSerializedSize(data.default_value(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalAnnotationParameter::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_name_hash;
    scdr << m_default_value;
}

void eprosima::fastrtps::types::MinimalAnnotationParameter::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_name_hash;

    dcdr >> m_default_value;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalAnnotationParameter::common(
        const eprosima::fastrtps::types::CommonAnnotationParameter& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalAnnotationParameter::common(
        eprosima::fastrtps::types::CommonAnnotationParameter&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonAnnotationParameter& eprosima::fastrtps::types::MinimalAnnotationParameter::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonAnnotationParameter& eprosima::fastrtps::types::MinimalAnnotationParameter::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member name_hash
 * @param _name_hash New value to be copied in member name_hash
 */
void eprosima::fastrtps::types::MinimalAnnotationParameter::name_hash(
        const eprosima::fastrtps::types::NameHash& _name_hash)
{
    m_name_hash = _name_hash;
}

/*!
 * @brief This function moves the value in member name_hash
 * @param _name_hash New value to be moved in member name_hash
 */
void eprosima::fastrtps::types::MinimalAnnotationParameter::name_hash(
        eprosima::fastrtps::types::NameHash&& _name_hash)
{
    m_name_hash = std::move(_name_hash);
}

/*!
 * @brief This function returns a constant reference to member name_hash
 * @return Constant reference to member name_hash
 */
const eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::MinimalAnnotationParameter::name_hash() const
{
    return m_name_hash;
}

/*!
 * @brief This function returns a reference to member name_hash
 * @return Reference to member name_hash
 */
eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::MinimalAnnotationParameter::name_hash()
{
    return m_name_hash;
}
/*!
 * @brief This function copies the value in member default_value
 * @param _default_value New value to be copied in member default_value
 */
void eprosima::fastrtps::types::MinimalAnnotationParameter::default_value(
        const eprosima::fastrtps::types::AnnotationParameterValue& _default_value)
{
    m_default_value = _default_value;
}

/*!
 * @brief This function moves the value in member default_value
 * @param _default_value New value to be moved in member default_value
 */
void eprosima::fastrtps::types::MinimalAnnotationParameter::default_value(
        eprosima::fastrtps::types::AnnotationParameterValue&& _default_value)
{
    m_default_value = std::move(_default_value);
}

/*!
 * @brief This function returns a constant reference to member default_value
 * @return Constant reference to member default_value
 */
const eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::MinimalAnnotationParameter::default_value() const
{
    return m_default_value;
}

/*!
 * @brief This function returns a reference to member default_value
 * @return Reference to member default_value
 */
eprosima::fastrtps::types::AnnotationParameterValue& eprosima::fastrtps::types::MinimalAnnotationParameter::default_value()
{
    return m_default_value;
}


size_t eprosima::fastrtps::types::MinimalAnnotationParameter::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAnnotationParameter_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalAnnotationParameter::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalAnnotationParameter::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CompleteAnnotationHeader::CompleteAnnotationHeader()
{
    // eprosima::fastrtps::types::QualifiedTypeName m_annotation_name
    m_annotation_name ="";

}

eprosima::fastrtps::types::CompleteAnnotationHeader::~CompleteAnnotationHeader()
{
}

eprosima::fastrtps::types::CompleteAnnotationHeader::CompleteAnnotationHeader(
        const CompleteAnnotationHeader& x)
{
    m_annotation_name = x.m_annotation_name;
}

eprosima::fastrtps::types::CompleteAnnotationHeader::CompleteAnnotationHeader(
        CompleteAnnotationHeader&& x) noexcept 
{
    m_annotation_name = std::move(x.m_annotation_name);
}

eprosima::fastrtps::types::CompleteAnnotationHeader& eprosima::fastrtps::types::CompleteAnnotationHeader::operator =(
        const CompleteAnnotationHeader& x)
{

    m_annotation_name = x.m_annotation_name;

    return *this;
}

eprosima::fastrtps::types::CompleteAnnotationHeader& eprosima::fastrtps::types::CompleteAnnotationHeader::operator =(
        CompleteAnnotationHeader&& x) noexcept
{

    m_annotation_name = std::move(x.m_annotation_name);

    return *this;
}

bool eprosima::fastrtps::types::CompleteAnnotationHeader::operator ==(
        const CompleteAnnotationHeader& x) const
{

    return (m_annotation_name == x.m_annotation_name);
}

bool eprosima::fastrtps::types::CompleteAnnotationHeader::operator !=(
        const CompleteAnnotationHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteAnnotationHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAnnotationHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteAnnotationHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteAnnotationHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.annotation_name().size() + 1;

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteAnnotationHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_annotation_name.c_str();
}

void eprosima::fastrtps::types::CompleteAnnotationHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        std::string aux;
        dcdr >> aux;
        m_annotation_name = aux.c_str();
    }}

/*!
 * @brief This function copies the value in member annotation_name
 * @param _annotation_name New value to be copied in member annotation_name
 */
void eprosima::fastrtps::types::CompleteAnnotationHeader::annotation_name(
        const eprosima::fastrtps::types::QualifiedTypeName& _annotation_name)
{
    m_annotation_name = _annotation_name;
}

/*!
 * @brief This function moves the value in member annotation_name
 * @param _annotation_name New value to be moved in member annotation_name
 */
void eprosima::fastrtps::types::CompleteAnnotationHeader::annotation_name(
        eprosima::fastrtps::types::QualifiedTypeName&& _annotation_name)
{
    m_annotation_name = std::move(_annotation_name);
}

/*!
 * @brief This function returns a constant reference to member annotation_name
 * @return Constant reference to member annotation_name
 */
const eprosima::fastrtps::types::QualifiedTypeName& eprosima::fastrtps::types::CompleteAnnotationHeader::annotation_name() const
{
    return m_annotation_name;
}

/*!
 * @brief This function returns a reference to member annotation_name
 * @return Reference to member annotation_name
 */
eprosima::fastrtps::types::QualifiedTypeName& eprosima::fastrtps::types::CompleteAnnotationHeader::annotation_name()
{
    return m_annotation_name;
}


size_t eprosima::fastrtps::types::CompleteAnnotationHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAnnotationHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteAnnotationHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteAnnotationHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalAnnotationHeader::MinimalAnnotationHeader()
{

}

eprosima::fastrtps::types::MinimalAnnotationHeader::~MinimalAnnotationHeader()
{
}

eprosima::fastrtps::types::MinimalAnnotationHeader::MinimalAnnotationHeader(
        const MinimalAnnotationHeader& /*x*/)
{
}

eprosima::fastrtps::types::MinimalAnnotationHeader::MinimalAnnotationHeader(
        MinimalAnnotationHeader&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::MinimalAnnotationHeader& eprosima::fastrtps::types::MinimalAnnotationHeader::operator =(
        const MinimalAnnotationHeader& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::MinimalAnnotationHeader& eprosima::fastrtps::types::MinimalAnnotationHeader::operator =(
        MinimalAnnotationHeader&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::MinimalAnnotationHeader::operator ==(
        const MinimalAnnotationHeader& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::MinimalAnnotationHeader::operator !=(
        const MinimalAnnotationHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalAnnotationHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAnnotationHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalAnnotationHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalAnnotationHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalAnnotationHeader::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::MinimalAnnotationHeader::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::MinimalAnnotationHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAnnotationHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalAnnotationHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalAnnotationHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteAnnotationType::CompleteAnnotationType()
{
    // eprosima::fastrtps::types::AnnotationTypeFlag m_annotation_flag
    m_annotation_flag = static_cast<eprosima::fastrtps::types::AnnotationTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteAnnotationHeader m_header

    // eprosima::fastrtps::types::CompleteAnnotationParameterSeq m_member_seq


}

eprosima::fastrtps::types::CompleteAnnotationType::~CompleteAnnotationType()
{



}

eprosima::fastrtps::types::CompleteAnnotationType::CompleteAnnotationType(
        const CompleteAnnotationType& x)
{
    m_annotation_flag = x.m_annotation_flag;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;
}

eprosima::fastrtps::types::CompleteAnnotationType::CompleteAnnotationType(
        CompleteAnnotationType&& x) noexcept 
{
    m_annotation_flag = x.m_annotation_flag;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);
}

eprosima::fastrtps::types::CompleteAnnotationType& eprosima::fastrtps::types::CompleteAnnotationType::operator =(
        const CompleteAnnotationType& x)
{

    m_annotation_flag = x.m_annotation_flag;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;

    return *this;
}

eprosima::fastrtps::types::CompleteAnnotationType& eprosima::fastrtps::types::CompleteAnnotationType::operator =(
        CompleteAnnotationType&& x) noexcept
{

    m_annotation_flag = x.m_annotation_flag;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);

    return *this;
}

bool eprosima::fastrtps::types::CompleteAnnotationType::operator ==(
        const CompleteAnnotationType& x) const
{

    return (m_annotation_flag == x.m_annotation_flag && m_header == x.m_header && m_member_seq == x.m_member_seq);
}

bool eprosima::fastrtps::types::CompleteAnnotationType::operator !=(
        const CompleteAnnotationType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteAnnotationType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteAnnotationType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteAnnotationHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.member_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::CompleteAnnotationParameter::getCdrSerializedSize(data.member_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteAnnotationType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_annotation_flag;scdr << m_header;scdr << m_member_seq;

}

void eprosima::fastrtps::types::CompleteAnnotationType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_annotation_flag = (eprosima::fastrtps::types::AnnotationTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_member_seq;
}

/*!
 * @brief This function sets a value in member annotation_flag
 * @param _annotation_flag New value for member annotation_flag
 */
void eprosima::fastrtps::types::CompleteAnnotationType::annotation_flag(
        eprosima::fastrtps::types::AnnotationTypeFlag _annotation_flag)
{
    m_annotation_flag = _annotation_flag;
}

/*!
 * @brief This function returns the value of member annotation_flag
 * @return Value of member annotation_flag
 */
eprosima::fastrtps::types::AnnotationTypeFlag eprosima::fastrtps::types::CompleteAnnotationType::annotation_flag() const
{
    return m_annotation_flag;
}

/*!
 * @brief This function returns a reference to member annotation_flag
 * @return Reference to member annotation_flag
 */
eprosima::fastrtps::types::AnnotationTypeFlag& eprosima::fastrtps::types::CompleteAnnotationType::annotation_flag()
{
    return m_annotation_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteAnnotationType::header(
        const eprosima::fastrtps::types::CompleteAnnotationHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteAnnotationType::header(
        eprosima::fastrtps::types::CompleteAnnotationHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteAnnotationHeader& eprosima::fastrtps::types::CompleteAnnotationType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteAnnotationHeader& eprosima::fastrtps::types::CompleteAnnotationType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member member_seq
 * @param _member_seq New value to be copied in member member_seq
 */
void eprosima::fastrtps::types::CompleteAnnotationType::member_seq(
        const eprosima::fastrtps::types::CompleteAnnotationParameterSeq& _member_seq)
{
    m_member_seq = _member_seq;
}

/*!
 * @brief This function moves the value in member member_seq
 * @param _member_seq New value to be moved in member member_seq
 */
void eprosima::fastrtps::types::CompleteAnnotationType::member_seq(
        eprosima::fastrtps::types::CompleteAnnotationParameterSeq&& _member_seq)
{
    m_member_seq = std::move(_member_seq);
}

/*!
 * @brief This function returns a constant reference to member member_seq
 * @return Constant reference to member member_seq
 */
const eprosima::fastrtps::types::CompleteAnnotationParameterSeq& eprosima::fastrtps::types::CompleteAnnotationType::member_seq() const
{
    return m_member_seq;
}

/*!
 * @brief This function returns a reference to member member_seq
 * @return Reference to member member_seq
 */
eprosima::fastrtps::types::CompleteAnnotationParameterSeq& eprosima::fastrtps::types::CompleteAnnotationType::member_seq()
{
    return m_member_seq;
}


size_t eprosima::fastrtps::types::CompleteAnnotationType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAnnotationType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteAnnotationType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteAnnotationType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalAnnotationType::MinimalAnnotationType()
{
    // eprosima::fastrtps::types::AnnotationTypeFlag m_annotation_flag
    m_annotation_flag = static_cast<eprosima::fastrtps::types::AnnotationTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalAnnotationHeader m_header

    // eprosima::fastrtps::types::MinimalAnnotationParameterSeq m_member_seq


}

eprosima::fastrtps::types::MinimalAnnotationType::~MinimalAnnotationType()
{



}

eprosima::fastrtps::types::MinimalAnnotationType::MinimalAnnotationType(
        const MinimalAnnotationType& x)
{
    m_annotation_flag = x.m_annotation_flag;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;
}

eprosima::fastrtps::types::MinimalAnnotationType::MinimalAnnotationType(
        MinimalAnnotationType&& x) noexcept 
{
    m_annotation_flag = x.m_annotation_flag;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);
}

eprosima::fastrtps::types::MinimalAnnotationType& eprosima::fastrtps::types::MinimalAnnotationType::operator =(
        const MinimalAnnotationType& x)
{

    m_annotation_flag = x.m_annotation_flag;
    m_header = x.m_header;
    m_member_seq = x.m_member_seq;

    return *this;
}

eprosima::fastrtps::types::MinimalAnnotationType& eprosima::fastrtps::types::MinimalAnnotationType::operator =(
        MinimalAnnotationType&& x) noexcept
{

    m_annotation_flag = x.m_annotation_flag;
    m_header = std::move(x.m_header);
    m_member_seq = std::move(x.m_member_seq);

    return *this;
}

bool eprosima::fastrtps::types::MinimalAnnotationType::operator ==(
        const MinimalAnnotationType& x) const
{

    return (m_annotation_flag == x.m_annotation_flag && m_header == x.m_header && m_member_seq == x.m_member_seq);
}

bool eprosima::fastrtps::types::MinimalAnnotationType::operator !=(
        const MinimalAnnotationType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalAnnotationType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalAnnotationType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalAnnotationHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.member_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::MinimalAnnotationParameter::getCdrSerializedSize(data.member_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalAnnotationType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_annotation_flag;scdr << m_header;scdr << m_member_seq;

}

void eprosima::fastrtps::types::MinimalAnnotationType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_annotation_flag = (eprosima::fastrtps::types::AnnotationTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_member_seq;
}

/*!
 * @brief This function sets a value in member annotation_flag
 * @param _annotation_flag New value for member annotation_flag
 */
void eprosima::fastrtps::types::MinimalAnnotationType::annotation_flag(
        eprosima::fastrtps::types::AnnotationTypeFlag _annotation_flag)
{
    m_annotation_flag = _annotation_flag;
}

/*!
 * @brief This function returns the value of member annotation_flag
 * @return Value of member annotation_flag
 */
eprosima::fastrtps::types::AnnotationTypeFlag eprosima::fastrtps::types::MinimalAnnotationType::annotation_flag() const
{
    return m_annotation_flag;
}

/*!
 * @brief This function returns a reference to member annotation_flag
 * @return Reference to member annotation_flag
 */
eprosima::fastrtps::types::AnnotationTypeFlag& eprosima::fastrtps::types::MinimalAnnotationType::annotation_flag()
{
    return m_annotation_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalAnnotationType::header(
        const eprosima::fastrtps::types::MinimalAnnotationHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalAnnotationType::header(
        eprosima::fastrtps::types::MinimalAnnotationHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalAnnotationHeader& eprosima::fastrtps::types::MinimalAnnotationType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalAnnotationHeader& eprosima::fastrtps::types::MinimalAnnotationType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member member_seq
 * @param _member_seq New value to be copied in member member_seq
 */
void eprosima::fastrtps::types::MinimalAnnotationType::member_seq(
        const eprosima::fastrtps::types::MinimalAnnotationParameterSeq& _member_seq)
{
    m_member_seq = _member_seq;
}

/*!
 * @brief This function moves the value in member member_seq
 * @param _member_seq New value to be moved in member member_seq
 */
void eprosima::fastrtps::types::MinimalAnnotationType::member_seq(
        eprosima::fastrtps::types::MinimalAnnotationParameterSeq&& _member_seq)
{
    m_member_seq = std::move(_member_seq);
}

/*!
 * @brief This function returns a constant reference to member member_seq
 * @return Constant reference to member member_seq
 */
const eprosima::fastrtps::types::MinimalAnnotationParameterSeq& eprosima::fastrtps::types::MinimalAnnotationType::member_seq() const
{
    return m_member_seq;
}

/*!
 * @brief This function returns a reference to member member_seq
 * @return Reference to member member_seq
 */
eprosima::fastrtps::types::MinimalAnnotationParameterSeq& eprosima::fastrtps::types::MinimalAnnotationType::member_seq()
{
    return m_member_seq;
}


size_t eprosima::fastrtps::types::MinimalAnnotationType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAnnotationType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalAnnotationType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalAnnotationType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonAliasBody::CommonAliasBody()
{
    // eprosima::fastrtps::types::AliasMemberFlag m_related_flags
    m_related_flags = static_cast<eprosima::fastrtps::types::AliasMemberFlag>(0);
    // eprosima::fastrtps::types::TypeIdentifier m_related_type


}

eprosima::fastrtps::types::CommonAliasBody::~CommonAliasBody()
{


}

eprosima::fastrtps::types::CommonAliasBody::CommonAliasBody(
        const CommonAliasBody& x)
{
    m_related_flags = x.m_related_flags;
    m_related_type = x.m_related_type;

}

eprosima::fastrtps::types::CommonAliasBody::CommonAliasBody(
        CommonAliasBody&& x) noexcept 
{
    m_related_flags = x.m_related_flags;
    m_related_type = std::move(x.m_related_type);
}

eprosima::fastrtps::types::CommonAliasBody& eprosima::fastrtps::types::CommonAliasBody::operator =(
        const CommonAliasBody& x)
{

    m_related_flags = x.m_related_flags;
    m_related_type = x.m_related_type;


    return *this;
}

eprosima::fastrtps::types::CommonAliasBody& eprosima::fastrtps::types::CommonAliasBody::operator =(
        CommonAliasBody&& x) noexcept
{

    m_related_flags = x.m_related_flags;
    m_related_type = std::move(x.m_related_type);

    return *this;
}

bool eprosima::fastrtps::types::CommonAliasBody::operator ==(
        const CommonAliasBody& x) const
{

    return (m_related_flags == x.m_related_flags && m_related_type == x.m_related_type);
}

bool eprosima::fastrtps::types::CommonAliasBody::operator !=(
        const CommonAliasBody& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonAliasBody::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonAliasBody& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.related_type(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonAliasBody::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_related_flags;scdr << m_related_type;
}

void eprosima::fastrtps::types::CommonAliasBody::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_related_flags = (eprosima::fastrtps::types::AliasMemberFlag)bitmask_value;
    }


    dcdr >> m_related_type;
}

/*!
 * @brief This function sets a value in member related_flags
 * @param _related_flags New value for member related_flags
 */
void eprosima::fastrtps::types::CommonAliasBody::related_flags(
        eprosima::fastrtps::types::AliasMemberFlag _related_flags)
{
    m_related_flags = _related_flags;
}

/*!
 * @brief This function returns the value of member related_flags
 * @return Value of member related_flags
 */
eprosima::fastrtps::types::AliasMemberFlag eprosima::fastrtps::types::CommonAliasBody::related_flags() const
{
    return m_related_flags;
}

/*!
 * @brief This function returns a reference to member related_flags
 * @return Reference to member related_flags
 */
eprosima::fastrtps::types::AliasMemberFlag& eprosima::fastrtps::types::CommonAliasBody::related_flags()
{
    return m_related_flags;
}

/*!
 * @brief This function copies the value in member related_type
 * @param _related_type New value to be copied in member related_type
 */
void eprosima::fastrtps::types::CommonAliasBody::related_type(
        const eprosima::fastrtps::types::TypeIdentifier& _related_type)
{
    m_related_type = _related_type;
}

/*!
 * @brief This function moves the value in member related_type
 * @param _related_type New value to be moved in member related_type
 */
void eprosima::fastrtps::types::CommonAliasBody::related_type(
        eprosima::fastrtps::types::TypeIdentifier&& _related_type)
{
    m_related_type = std::move(_related_type);
}

/*!
 * @brief This function returns a constant reference to member related_type
 * @return Constant reference to member related_type
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonAliasBody::related_type() const
{
    return m_related_type;
}

/*!
 * @brief This function returns a reference to member related_type
 * @return Reference to member related_type
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonAliasBody::related_type()
{
    return m_related_type;
}


size_t eprosima::fastrtps::types::CommonAliasBody::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonAliasBody_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonAliasBody::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonAliasBody::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteAliasBody::CompleteAliasBody()
{
    // eprosima::fastrtps::types::CommonAliasBody m_common

    // eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations m_ann_builtin

    // eprosima::fastrtps::types::AppliedAnnotationSeq m_ann_custom


}

eprosima::fastrtps::types::CompleteAliasBody::~CompleteAliasBody()
{



}

eprosima::fastrtps::types::CompleteAliasBody::CompleteAliasBody(
        const CompleteAliasBody& x)
{
    m_common = x.m_common;
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;
}

eprosima::fastrtps::types::CompleteAliasBody::CompleteAliasBody(
        CompleteAliasBody&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);
}

eprosima::fastrtps::types::CompleteAliasBody& eprosima::fastrtps::types::CompleteAliasBody::operator =(
        const CompleteAliasBody& x)
{

    m_common = x.m_common;
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;

    return *this;
}

eprosima::fastrtps::types::CompleteAliasBody& eprosima::fastrtps::types::CompleteAliasBody::operator =(
        CompleteAliasBody&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);

    return *this;
}

bool eprosima::fastrtps::types::CompleteAliasBody::operator ==(
        const CompleteAliasBody& x) const
{

    return (m_common == x.m_common && m_ann_builtin == x.m_ann_builtin && m_ann_custom == x.m_ann_custom);
}

bool eprosima::fastrtps::types::CompleteAliasBody::operator !=(
        const CompleteAliasBody& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteAliasBody::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteAliasBody& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonAliasBody::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::getCdrSerializedSize(data.ann_builtin(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.ann_custom().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::AppliedAnnotation::getCdrSerializedSize(data.ann_custom().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteAliasBody::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_ann_builtin;scdr << m_ann_custom;

}

void eprosima::fastrtps::types::CompleteAliasBody::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_ann_builtin;
    dcdr >> m_ann_custom;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteAliasBody::common(
        const eprosima::fastrtps::types::CommonAliasBody& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteAliasBody::common(
        eprosima::fastrtps::types::CommonAliasBody&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonAliasBody& eprosima::fastrtps::types::CompleteAliasBody::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonAliasBody& eprosima::fastrtps::types::CompleteAliasBody::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member ann_builtin
 * @param _ann_builtin New value to be copied in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteAliasBody::ann_builtin(
        const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& _ann_builtin)
{
    m_ann_builtin = _ann_builtin;
}

/*!
 * @brief This function moves the value in member ann_builtin
 * @param _ann_builtin New value to be moved in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteAliasBody::ann_builtin(
        eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations&& _ann_builtin)
{
    m_ann_builtin = std::move(_ann_builtin);
}

/*!
 * @brief This function returns a constant reference to member ann_builtin
 * @return Constant reference to member ann_builtin
 */
const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::CompleteAliasBody::ann_builtin() const
{
    return m_ann_builtin;
}

/*!
 * @brief This function returns a reference to member ann_builtin
 * @return Reference to member ann_builtin
 */
eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::CompleteAliasBody::ann_builtin()
{
    return m_ann_builtin;
}
/*!
 * @brief This function copies the value in member ann_custom
 * @param _ann_custom New value to be copied in member ann_custom
 */
void eprosima::fastrtps::types::CompleteAliasBody::ann_custom(
        const eprosima::fastrtps::types::AppliedAnnotationSeq& _ann_custom)
{
    m_ann_custom = _ann_custom;
}

/*!
 * @brief This function moves the value in member ann_custom
 * @param _ann_custom New value to be moved in member ann_custom
 */
void eprosima::fastrtps::types::CompleteAliasBody::ann_custom(
        eprosima::fastrtps::types::AppliedAnnotationSeq&& _ann_custom)
{
    m_ann_custom = std::move(_ann_custom);
}

/*!
 * @brief This function returns a constant reference to member ann_custom
 * @return Constant reference to member ann_custom
 */
const eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteAliasBody::ann_custom() const
{
    return m_ann_custom;
}

/*!
 * @brief This function returns a reference to member ann_custom
 * @return Reference to member ann_custom
 */
eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteAliasBody::ann_custom()
{
    return m_ann_custom;
}


size_t eprosima::fastrtps::types::CompleteAliasBody::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAliasBody_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteAliasBody::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteAliasBody::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalAliasBody::MinimalAliasBody()
{
    // eprosima::fastrtps::types::CommonAliasBody m_common


}

eprosima::fastrtps::types::MinimalAliasBody::~MinimalAliasBody()
{
}

eprosima::fastrtps::types::MinimalAliasBody::MinimalAliasBody(
        const MinimalAliasBody& x)
{
    m_common = x.m_common;
}

eprosima::fastrtps::types::MinimalAliasBody::MinimalAliasBody(
        MinimalAliasBody&& x) noexcept 
{
    m_common = std::move(x.m_common);
}

eprosima::fastrtps::types::MinimalAliasBody& eprosima::fastrtps::types::MinimalAliasBody::operator =(
        const MinimalAliasBody& x)
{

    m_common = x.m_common;

    return *this;
}

eprosima::fastrtps::types::MinimalAliasBody& eprosima::fastrtps::types::MinimalAliasBody::operator =(
        MinimalAliasBody&& x) noexcept
{

    m_common = std::move(x.m_common);

    return *this;
}

bool eprosima::fastrtps::types::MinimalAliasBody::operator ==(
        const MinimalAliasBody& x) const
{

    return (m_common == x.m_common);
}

bool eprosima::fastrtps::types::MinimalAliasBody::operator !=(
        const MinimalAliasBody& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalAliasBody::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalAliasBody& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonAliasBody::getCdrSerializedSize(data.common(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalAliasBody::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;
}

void eprosima::fastrtps::types::MinimalAliasBody::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalAliasBody::common(
        const eprosima::fastrtps::types::CommonAliasBody& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalAliasBody::common(
        eprosima::fastrtps::types::CommonAliasBody&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonAliasBody& eprosima::fastrtps::types::MinimalAliasBody::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonAliasBody& eprosima::fastrtps::types::MinimalAliasBody::common()
{
    return m_common;
}


size_t eprosima::fastrtps::types::MinimalAliasBody::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAliasBody_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalAliasBody::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalAliasBody::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteAliasHeader::CompleteAliasHeader()
{
    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteAliasHeader::~CompleteAliasHeader()
{
}

eprosima::fastrtps::types::CompleteAliasHeader::CompleteAliasHeader(
        const CompleteAliasHeader& x)
{
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteAliasHeader::CompleteAliasHeader(
        CompleteAliasHeader&& x) noexcept 
{
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteAliasHeader& eprosima::fastrtps::types::CompleteAliasHeader::operator =(
        const CompleteAliasHeader& x)
{

    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteAliasHeader& eprosima::fastrtps::types::CompleteAliasHeader::operator =(
        CompleteAliasHeader&& x) noexcept
{

    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteAliasHeader::operator ==(
        const CompleteAliasHeader& x) const
{

    return (m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteAliasHeader::operator !=(
        const CompleteAliasHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteAliasHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAliasHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteAliasHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteAliasHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteAliasHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteAliasHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteAliasHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteAliasHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteAliasHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteAliasHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteAliasHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAliasHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteAliasHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteAliasHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalAliasHeader::MinimalAliasHeader()
{

}

eprosima::fastrtps::types::MinimalAliasHeader::~MinimalAliasHeader()
{
}

eprosima::fastrtps::types::MinimalAliasHeader::MinimalAliasHeader(
        const MinimalAliasHeader& /*x*/)
{
}

eprosima::fastrtps::types::MinimalAliasHeader::MinimalAliasHeader(
        MinimalAliasHeader&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::MinimalAliasHeader& eprosima::fastrtps::types::MinimalAliasHeader::operator =(
        const MinimalAliasHeader& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::MinimalAliasHeader& eprosima::fastrtps::types::MinimalAliasHeader::operator =(
        MinimalAliasHeader&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::MinimalAliasHeader::operator ==(
        const MinimalAliasHeader& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::MinimalAliasHeader::operator !=(
        const MinimalAliasHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalAliasHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAliasHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalAliasHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalAliasHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalAliasHeader::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::MinimalAliasHeader::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::MinimalAliasHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAliasHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalAliasHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalAliasHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteAliasType::CompleteAliasType()
{
    // eprosima::fastrtps::types::AliasTypeFlag m_alias_flags
    m_alias_flags = static_cast<eprosima::fastrtps::types::AliasTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteAliasHeader m_header

    // eprosima::fastrtps::types::CompleteAliasBody m_body


}

eprosima::fastrtps::types::CompleteAliasType::~CompleteAliasType()
{



}

eprosima::fastrtps::types::CompleteAliasType::CompleteAliasType(
        const CompleteAliasType& x)
{
    m_alias_flags = x.m_alias_flags;
    m_header = x.m_header;
    m_body = x.m_body;
}

eprosima::fastrtps::types::CompleteAliasType::CompleteAliasType(
        CompleteAliasType&& x) noexcept 
{
    m_alias_flags = x.m_alias_flags;
    m_header = std::move(x.m_header);
    m_body = std::move(x.m_body);
}

eprosima::fastrtps::types::CompleteAliasType& eprosima::fastrtps::types::CompleteAliasType::operator =(
        const CompleteAliasType& x)
{

    m_alias_flags = x.m_alias_flags;
    m_header = x.m_header;
    m_body = x.m_body;

    return *this;
}

eprosima::fastrtps::types::CompleteAliasType& eprosima::fastrtps::types::CompleteAliasType::operator =(
        CompleteAliasType&& x) noexcept
{

    m_alias_flags = x.m_alias_flags;
    m_header = std::move(x.m_header);
    m_body = std::move(x.m_body);

    return *this;
}

bool eprosima::fastrtps::types::CompleteAliasType::operator ==(
        const CompleteAliasType& x) const
{

    return (m_alias_flags == x.m_alias_flags && m_header == x.m_header && m_body == x.m_body);
}

bool eprosima::fastrtps::types::CompleteAliasType::operator !=(
        const CompleteAliasType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteAliasType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteAliasType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteAliasHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteAliasBody::getCdrSerializedSize(data.body(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteAliasType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_alias_flags;scdr << m_header;scdr << m_body;
}

void eprosima::fastrtps::types::CompleteAliasType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_alias_flags = (eprosima::fastrtps::types::AliasTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_body;
}

/*!
 * @brief This function sets a value in member alias_flags
 * @param _alias_flags New value for member alias_flags
 */
void eprosima::fastrtps::types::CompleteAliasType::alias_flags(
        eprosima::fastrtps::types::AliasTypeFlag _alias_flags)
{
    m_alias_flags = _alias_flags;
}

/*!
 * @brief This function returns the value of member alias_flags
 * @return Value of member alias_flags
 */
eprosima::fastrtps::types::AliasTypeFlag eprosima::fastrtps::types::CompleteAliasType::alias_flags() const
{
    return m_alias_flags;
}

/*!
 * @brief This function returns a reference to member alias_flags
 * @return Reference to member alias_flags
 */
eprosima::fastrtps::types::AliasTypeFlag& eprosima::fastrtps::types::CompleteAliasType::alias_flags()
{
    return m_alias_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteAliasType::header(
        const eprosima::fastrtps::types::CompleteAliasHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteAliasType::header(
        eprosima::fastrtps::types::CompleteAliasHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteAliasHeader& eprosima::fastrtps::types::CompleteAliasType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteAliasHeader& eprosima::fastrtps::types::CompleteAliasType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member body
 * @param _body New value to be copied in member body
 */
void eprosima::fastrtps::types::CompleteAliasType::body(
        const eprosima::fastrtps::types::CompleteAliasBody& _body)
{
    m_body = _body;
}

/*!
 * @brief This function moves the value in member body
 * @param _body New value to be moved in member body
 */
void eprosima::fastrtps::types::CompleteAliasType::body(
        eprosima::fastrtps::types::CompleteAliasBody&& _body)
{
    m_body = std::move(_body);
}

/*!
 * @brief This function returns a constant reference to member body
 * @return Constant reference to member body
 */
const eprosima::fastrtps::types::CompleteAliasBody& eprosima::fastrtps::types::CompleteAliasType::body() const
{
    return m_body;
}

/*!
 * @brief This function returns a reference to member body
 * @return Reference to member body
 */
eprosima::fastrtps::types::CompleteAliasBody& eprosima::fastrtps::types::CompleteAliasType::body()
{
    return m_body;
}


size_t eprosima::fastrtps::types::CompleteAliasType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteAliasType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteAliasType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteAliasType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalAliasType::MinimalAliasType()
{
    // eprosima::fastrtps::types::AliasTypeFlag m_alias_flags
    m_alias_flags = static_cast<eprosima::fastrtps::types::AliasTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalAliasHeader m_header

    // eprosima::fastrtps::types::MinimalAliasBody m_body


}

eprosima::fastrtps::types::MinimalAliasType::~MinimalAliasType()
{



}

eprosima::fastrtps::types::MinimalAliasType::MinimalAliasType(
        const MinimalAliasType& x)
{
    m_alias_flags = x.m_alias_flags;
    m_header = x.m_header;
    m_body = x.m_body;
}

eprosima::fastrtps::types::MinimalAliasType::MinimalAliasType(
        MinimalAliasType&& x) noexcept 
{
    m_alias_flags = x.m_alias_flags;
    m_header = std::move(x.m_header);
    m_body = std::move(x.m_body);
}

eprosima::fastrtps::types::MinimalAliasType& eprosima::fastrtps::types::MinimalAliasType::operator =(
        const MinimalAliasType& x)
{

    m_alias_flags = x.m_alias_flags;
    m_header = x.m_header;
    m_body = x.m_body;

    return *this;
}

eprosima::fastrtps::types::MinimalAliasType& eprosima::fastrtps::types::MinimalAliasType::operator =(
        MinimalAliasType&& x) noexcept
{

    m_alias_flags = x.m_alias_flags;
    m_header = std::move(x.m_header);
    m_body = std::move(x.m_body);

    return *this;
}

bool eprosima::fastrtps::types::MinimalAliasType::operator ==(
        const MinimalAliasType& x) const
{

    return (m_alias_flags == x.m_alias_flags && m_header == x.m_header && m_body == x.m_body);
}

bool eprosima::fastrtps::types::MinimalAliasType::operator !=(
        const MinimalAliasType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalAliasType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalAliasType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalAliasHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalAliasBody::getCdrSerializedSize(data.body(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalAliasType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_alias_flags;scdr << m_header;scdr << m_body;
}

void eprosima::fastrtps::types::MinimalAliasType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_alias_flags = (eprosima::fastrtps::types::AliasTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_body;
}

/*!
 * @brief This function sets a value in member alias_flags
 * @param _alias_flags New value for member alias_flags
 */
void eprosima::fastrtps::types::MinimalAliasType::alias_flags(
        eprosima::fastrtps::types::AliasTypeFlag _alias_flags)
{
    m_alias_flags = _alias_flags;
}

/*!
 * @brief This function returns the value of member alias_flags
 * @return Value of member alias_flags
 */
eprosima::fastrtps::types::AliasTypeFlag eprosima::fastrtps::types::MinimalAliasType::alias_flags() const
{
    return m_alias_flags;
}

/*!
 * @brief This function returns a reference to member alias_flags
 * @return Reference to member alias_flags
 */
eprosima::fastrtps::types::AliasTypeFlag& eprosima::fastrtps::types::MinimalAliasType::alias_flags()
{
    return m_alias_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalAliasType::header(
        const eprosima::fastrtps::types::MinimalAliasHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalAliasType::header(
        eprosima::fastrtps::types::MinimalAliasHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalAliasHeader& eprosima::fastrtps::types::MinimalAliasType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalAliasHeader& eprosima::fastrtps::types::MinimalAliasType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member body
 * @param _body New value to be copied in member body
 */
void eprosima::fastrtps::types::MinimalAliasType::body(
        const eprosima::fastrtps::types::MinimalAliasBody& _body)
{
    m_body = _body;
}

/*!
 * @brief This function moves the value in member body
 * @param _body New value to be moved in member body
 */
void eprosima::fastrtps::types::MinimalAliasType::body(
        eprosima::fastrtps::types::MinimalAliasBody&& _body)
{
    m_body = std::move(_body);
}

/*!
 * @brief This function returns a constant reference to member body
 * @return Constant reference to member body
 */
const eprosima::fastrtps::types::MinimalAliasBody& eprosima::fastrtps::types::MinimalAliasType::body() const
{
    return m_body;
}

/*!
 * @brief This function returns a reference to member body
 * @return Reference to member body
 */
eprosima::fastrtps::types::MinimalAliasBody& eprosima::fastrtps::types::MinimalAliasType::body()
{
    return m_body;
}


size_t eprosima::fastrtps::types::MinimalAliasType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalAliasType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalAliasType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalAliasType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteElementDetail::CompleteElementDetail()
{
    // eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations m_ann_builtin

    // eprosima::fastrtps::types::AppliedAnnotationSeq m_ann_custom


}

eprosima::fastrtps::types::CompleteElementDetail::~CompleteElementDetail()
{


}

eprosima::fastrtps::types::CompleteElementDetail::CompleteElementDetail(
        const CompleteElementDetail& x)
{
    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;
}

eprosima::fastrtps::types::CompleteElementDetail::CompleteElementDetail(
        CompleteElementDetail&& x) noexcept 
{
    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);
}

eprosima::fastrtps::types::CompleteElementDetail& eprosima::fastrtps::types::CompleteElementDetail::operator =(
        const CompleteElementDetail& x)
{

    m_ann_builtin = x.m_ann_builtin;
    m_ann_custom = x.m_ann_custom;

    return *this;
}

eprosima::fastrtps::types::CompleteElementDetail& eprosima::fastrtps::types::CompleteElementDetail::operator =(
        CompleteElementDetail&& x) noexcept
{

    m_ann_builtin = std::move(x.m_ann_builtin);
    m_ann_custom = std::move(x.m_ann_custom);

    return *this;
}

bool eprosima::fastrtps::types::CompleteElementDetail::operator ==(
        const CompleteElementDetail& x) const
{

    return (m_ann_builtin == x.m_ann_builtin && m_ann_custom == x.m_ann_custom);
}

bool eprosima::fastrtps::types::CompleteElementDetail::operator !=(
        const CompleteElementDetail& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteElementDetail::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteElementDetail_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteElementDetail::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteElementDetail& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations::getCdrSerializedSize(data.ann_builtin(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.ann_custom().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::AppliedAnnotation::getCdrSerializedSize(data.ann_custom().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteElementDetail::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_ann_builtin;scdr << m_ann_custom;

}

void eprosima::fastrtps::types::CompleteElementDetail::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_ann_builtin;
    dcdr >> m_ann_custom;
}

/*!
 * @brief This function copies the value in member ann_builtin
 * @param _ann_builtin New value to be copied in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteElementDetail::ann_builtin(
        const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& _ann_builtin)
{
    m_ann_builtin = _ann_builtin;
}

/*!
 * @brief This function moves the value in member ann_builtin
 * @param _ann_builtin New value to be moved in member ann_builtin
 */
void eprosima::fastrtps::types::CompleteElementDetail::ann_builtin(
        eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations&& _ann_builtin)
{
    m_ann_builtin = std::move(_ann_builtin);
}

/*!
 * @brief This function returns a constant reference to member ann_builtin
 * @return Constant reference to member ann_builtin
 */
const eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::CompleteElementDetail::ann_builtin() const
{
    return m_ann_builtin;
}

/*!
 * @brief This function returns a reference to member ann_builtin
 * @return Reference to member ann_builtin
 */
eprosima::fastrtps::types::AppliedBuiltinMemberAnnotations& eprosima::fastrtps::types::CompleteElementDetail::ann_builtin()
{
    return m_ann_builtin;
}
/*!
 * @brief This function copies the value in member ann_custom
 * @param _ann_custom New value to be copied in member ann_custom
 */
void eprosima::fastrtps::types::CompleteElementDetail::ann_custom(
        const eprosima::fastrtps::types::AppliedAnnotationSeq& _ann_custom)
{
    m_ann_custom = _ann_custom;
}

/*!
 * @brief This function moves the value in member ann_custom
 * @param _ann_custom New value to be moved in member ann_custom
 */
void eprosima::fastrtps::types::CompleteElementDetail::ann_custom(
        eprosima::fastrtps::types::AppliedAnnotationSeq&& _ann_custom)
{
    m_ann_custom = std::move(_ann_custom);
}

/*!
 * @brief This function returns a constant reference to member ann_custom
 * @return Constant reference to member ann_custom
 */
const eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteElementDetail::ann_custom() const
{
    return m_ann_custom;
}

/*!
 * @brief This function returns a reference to member ann_custom
 * @return Reference to member ann_custom
 */
eprosima::fastrtps::types::AppliedAnnotationSeq& eprosima::fastrtps::types::CompleteElementDetail::ann_custom()
{
    return m_ann_custom;
}


size_t eprosima::fastrtps::types::CompleteElementDetail::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteElementDetail_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteElementDetail::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteElementDetail::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonCollectionElement::CommonCollectionElement()
{
    // eprosima::fastrtps::types::CollectionElementFlag m_element_flags
    m_element_flags = static_cast<eprosima::fastrtps::types::CollectionElementFlag>(0);
    // eprosima::fastrtps::types::TypeIdentifier m_type


}

eprosima::fastrtps::types::CommonCollectionElement::~CommonCollectionElement()
{


}

eprosima::fastrtps::types::CommonCollectionElement::CommonCollectionElement(
        const CommonCollectionElement& x)
{
    m_element_flags = x.m_element_flags;
    m_type = x.m_type;

}

eprosima::fastrtps::types::CommonCollectionElement::CommonCollectionElement(
        CommonCollectionElement&& x) noexcept 
{
    m_element_flags = x.m_element_flags;
    m_type = std::move(x.m_type);
}

eprosima::fastrtps::types::CommonCollectionElement& eprosima::fastrtps::types::CommonCollectionElement::operator =(
        const CommonCollectionElement& x)
{

    m_element_flags = x.m_element_flags;
    m_type = x.m_type;


    return *this;
}

eprosima::fastrtps::types::CommonCollectionElement& eprosima::fastrtps::types::CommonCollectionElement::operator =(
        CommonCollectionElement&& x) noexcept
{

    m_element_flags = x.m_element_flags;
    m_type = std::move(x.m_type);

    return *this;
}

bool eprosima::fastrtps::types::CommonCollectionElement::operator ==(
        const CommonCollectionElement& x) const
{

    return (m_element_flags == x.m_element_flags && m_type == x.m_type);
}

bool eprosima::fastrtps::types::CommonCollectionElement::operator !=(
        const CommonCollectionElement& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonCollectionElement::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonCollectionElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonCollectionElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_element_flags;scdr << m_type;
}

void eprosima::fastrtps::types::CommonCollectionElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_element_flags = (eprosima::fastrtps::types::CollectionElementFlag)bitmask_value;
    }


    dcdr >> m_type;
}

/*!
 * @brief This function sets a value in member element_flags
 * @param _element_flags New value for member element_flags
 */
void eprosima::fastrtps::types::CommonCollectionElement::element_flags(
        eprosima::fastrtps::types::CollectionElementFlag _element_flags)
{
    m_element_flags = _element_flags;
}

/*!
 * @brief This function returns the value of member element_flags
 * @return Value of member element_flags
 */
eprosima::fastrtps::types::CollectionElementFlag eprosima::fastrtps::types::CommonCollectionElement::element_flags() const
{
    return m_element_flags;
}

/*!
 * @brief This function returns a reference to member element_flags
 * @return Reference to member element_flags
 */
eprosima::fastrtps::types::CollectionElementFlag& eprosima::fastrtps::types::CommonCollectionElement::element_flags()
{
    return m_element_flags;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void eprosima::fastrtps::types::CommonCollectionElement::type(
        const eprosima::fastrtps::types::TypeIdentifier& _type)
{
    m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void eprosima::fastrtps::types::CommonCollectionElement::type(
        eprosima::fastrtps::types::TypeIdentifier&& _type)
{
    m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonCollectionElement::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::CommonCollectionElement::type()
{
    return m_type;
}


size_t eprosima::fastrtps::types::CommonCollectionElement::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonCollectionElement_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonCollectionElement::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonCollectionElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteCollectionElement::CompleteCollectionElement()
{
    // eprosima::fastrtps::types::CommonCollectionElement m_common

    // eprosima::fastrtps::types::CompleteElementDetail m_detail


}

eprosima::fastrtps::types::CompleteCollectionElement::~CompleteCollectionElement()
{


}

eprosima::fastrtps::types::CompleteCollectionElement::CompleteCollectionElement(
        const CompleteCollectionElement& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteCollectionElement::CompleteCollectionElement(
        CompleteCollectionElement&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteCollectionElement::operator =(
        const CompleteCollectionElement& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteCollectionElement::operator =(
        CompleteCollectionElement&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteCollectionElement::operator ==(
        const CompleteCollectionElement& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteCollectionElement::operator !=(
        const CompleteCollectionElement& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteCollectionElement::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteCollectionElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonCollectionElement::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteElementDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteCollectionElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteCollectionElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteCollectionElement::common(
        const eprosima::fastrtps::types::CommonCollectionElement& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteCollectionElement::common(
        eprosima::fastrtps::types::CommonCollectionElement&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonCollectionElement& eprosima::fastrtps::types::CompleteCollectionElement::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonCollectionElement& eprosima::fastrtps::types::CompleteCollectionElement::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteCollectionElement::detail(
        const eprosima::fastrtps::types::CompleteElementDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteCollectionElement::detail(
        eprosima::fastrtps::types::CompleteElementDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteElementDetail& eprosima::fastrtps::types::CompleteCollectionElement::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteElementDetail& eprosima::fastrtps::types::CompleteCollectionElement::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteCollectionElement::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteCollectionElement_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteCollectionElement::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteCollectionElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalCollectionElement::MinimalCollectionElement()
{
    // eprosima::fastrtps::types::CommonCollectionElement m_common


}

eprosima::fastrtps::types::MinimalCollectionElement::~MinimalCollectionElement()
{
}

eprosima::fastrtps::types::MinimalCollectionElement::MinimalCollectionElement(
        const MinimalCollectionElement& x)
{
    m_common = x.m_common;
}

eprosima::fastrtps::types::MinimalCollectionElement::MinimalCollectionElement(
        MinimalCollectionElement&& x) noexcept 
{
    m_common = std::move(x.m_common);
}

eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalCollectionElement::operator =(
        const MinimalCollectionElement& x)
{

    m_common = x.m_common;

    return *this;
}

eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalCollectionElement::operator =(
        MinimalCollectionElement&& x) noexcept
{

    m_common = std::move(x.m_common);

    return *this;
}

bool eprosima::fastrtps::types::MinimalCollectionElement::operator ==(
        const MinimalCollectionElement& x) const
{

    return (m_common == x.m_common);
}

bool eprosima::fastrtps::types::MinimalCollectionElement::operator !=(
        const MinimalCollectionElement& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalCollectionElement::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalCollectionElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonCollectionElement::getCdrSerializedSize(data.common(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalCollectionElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;
}

void eprosima::fastrtps::types::MinimalCollectionElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalCollectionElement::common(
        const eprosima::fastrtps::types::CommonCollectionElement& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalCollectionElement::common(
        eprosima::fastrtps::types::CommonCollectionElement&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonCollectionElement& eprosima::fastrtps::types::MinimalCollectionElement::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonCollectionElement& eprosima::fastrtps::types::MinimalCollectionElement::common()
{
    return m_common;
}


size_t eprosima::fastrtps::types::MinimalCollectionElement::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalCollectionElement_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalCollectionElement::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalCollectionElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonCollectionHeader::CommonCollectionHeader()
{
    // eprosima::fastrtps::types::LBound m_bound
    m_bound = 0;

}

eprosima::fastrtps::types::CommonCollectionHeader::~CommonCollectionHeader()
{
}

eprosima::fastrtps::types::CommonCollectionHeader::CommonCollectionHeader(
        const CommonCollectionHeader& x)
{
    m_bound = x.m_bound;
}

eprosima::fastrtps::types::CommonCollectionHeader::CommonCollectionHeader(
        CommonCollectionHeader&& x) noexcept 
{
    m_bound = x.m_bound;
}

eprosima::fastrtps::types::CommonCollectionHeader& eprosima::fastrtps::types::CommonCollectionHeader::operator =(
        const CommonCollectionHeader& x)
{

    m_bound = x.m_bound;

    return *this;
}

eprosima::fastrtps::types::CommonCollectionHeader& eprosima::fastrtps::types::CommonCollectionHeader::operator =(
        CommonCollectionHeader&& x) noexcept
{

    m_bound = x.m_bound;

    return *this;
}

bool eprosima::fastrtps::types::CommonCollectionHeader::operator ==(
        const CommonCollectionHeader& x) const
{

    return (m_bound == x.m_bound);
}

bool eprosima::fastrtps::types::CommonCollectionHeader::operator !=(
        const CommonCollectionHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonCollectionHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonCollectionHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonCollectionHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonCollectionHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonCollectionHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bound;
}

void eprosima::fastrtps::types::CommonCollectionHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bound;
}

/*!
 * @brief This function sets a value in member bound
 * @param _bound New value for member bound
 */
void eprosima::fastrtps::types::CommonCollectionHeader::bound(
        eprosima::fastrtps::types::LBound _bound)
{
    m_bound = _bound;
}

/*!
 * @brief This function returns the value of member bound
 * @return Value of member bound
 */
eprosima::fastrtps::types::LBound eprosima::fastrtps::types::CommonCollectionHeader::bound() const
{
    return m_bound;
}

/*!
 * @brief This function returns a reference to member bound
 * @return Reference to member bound
 */
eprosima::fastrtps::types::LBound& eprosima::fastrtps::types::CommonCollectionHeader::bound()
{
    return m_bound;
}



size_t eprosima::fastrtps::types::CommonCollectionHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonCollectionHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonCollectionHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonCollectionHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteCollectionHeader::CompleteCollectionHeader()
{
    // eprosima::fastrtps::types::CommonCollectionHeader m_common

    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteCollectionHeader::~CompleteCollectionHeader()
{


}

eprosima::fastrtps::types::CompleteCollectionHeader::CompleteCollectionHeader(
        const CompleteCollectionHeader& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteCollectionHeader::CompleteCollectionHeader(
        CompleteCollectionHeader&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteCollectionHeader& eprosima::fastrtps::types::CompleteCollectionHeader::operator =(
        const CompleteCollectionHeader& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteCollectionHeader& eprosima::fastrtps::types::CompleteCollectionHeader::operator =(
        CompleteCollectionHeader&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteCollectionHeader::operator ==(
        const CompleteCollectionHeader& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteCollectionHeader::operator !=(
        const CompleteCollectionHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteCollectionHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteCollectionHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteCollectionHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteCollectionHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonCollectionHeader::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteCollectionHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteCollectionHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteCollectionHeader::common(
        const eprosima::fastrtps::types::CommonCollectionHeader& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteCollectionHeader::common(
        eprosima::fastrtps::types::CommonCollectionHeader&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonCollectionHeader& eprosima::fastrtps::types::CompleteCollectionHeader::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonCollectionHeader& eprosima::fastrtps::types::CompleteCollectionHeader::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteCollectionHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteCollectionHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteCollectionHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteCollectionHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteCollectionHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteCollectionHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteCollectionHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteCollectionHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalCollectionHeader::MinimalCollectionHeader()
{
    // eprosima::fastrtps::types::CommonCollectionHeader m_common


}

eprosima::fastrtps::types::MinimalCollectionHeader::~MinimalCollectionHeader()
{
}

eprosima::fastrtps::types::MinimalCollectionHeader::MinimalCollectionHeader(
        const MinimalCollectionHeader& x)
{
    m_common = x.m_common;
}

eprosima::fastrtps::types::MinimalCollectionHeader::MinimalCollectionHeader(
        MinimalCollectionHeader&& x) noexcept 
{
    m_common = std::move(x.m_common);
}

eprosima::fastrtps::types::MinimalCollectionHeader& eprosima::fastrtps::types::MinimalCollectionHeader::operator =(
        const MinimalCollectionHeader& x)
{

    m_common = x.m_common;

    return *this;
}

eprosima::fastrtps::types::MinimalCollectionHeader& eprosima::fastrtps::types::MinimalCollectionHeader::operator =(
        MinimalCollectionHeader&& x) noexcept
{

    m_common = std::move(x.m_common);

    return *this;
}

bool eprosima::fastrtps::types::MinimalCollectionHeader::operator ==(
        const MinimalCollectionHeader& x) const
{

    return (m_common == x.m_common);
}

bool eprosima::fastrtps::types::MinimalCollectionHeader::operator !=(
        const MinimalCollectionHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalCollectionHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalCollectionHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalCollectionHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalCollectionHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonCollectionHeader::getCdrSerializedSize(data.common(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalCollectionHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;
}

void eprosima::fastrtps::types::MinimalCollectionHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalCollectionHeader::common(
        const eprosima::fastrtps::types::CommonCollectionHeader& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalCollectionHeader::common(
        eprosima::fastrtps::types::CommonCollectionHeader&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonCollectionHeader& eprosima::fastrtps::types::MinimalCollectionHeader::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonCollectionHeader& eprosima::fastrtps::types::MinimalCollectionHeader::common()
{
    return m_common;
}


size_t eprosima::fastrtps::types::MinimalCollectionHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalCollectionHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalCollectionHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalCollectionHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteSequenceType::CompleteSequenceType()
{
    // eprosima::fastrtps::types::CollectionTypeFlag m_collection_flag
    m_collection_flag = static_cast<eprosima::fastrtps::types::CollectionTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteCollectionHeader m_header

    // eprosima::fastrtps::types::CompleteCollectionElement m_element


}

eprosima::fastrtps::types::CompleteSequenceType::~CompleteSequenceType()
{



}

eprosima::fastrtps::types::CompleteSequenceType::CompleteSequenceType(
        const CompleteSequenceType& x)
{
    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;
}

eprosima::fastrtps::types::CompleteSequenceType::CompleteSequenceType(
        CompleteSequenceType&& x) noexcept 
{
    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);
}

eprosima::fastrtps::types::CompleteSequenceType& eprosima::fastrtps::types::CompleteSequenceType::operator =(
        const CompleteSequenceType& x)
{

    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;

    return *this;
}

eprosima::fastrtps::types::CompleteSequenceType& eprosima::fastrtps::types::CompleteSequenceType::operator =(
        CompleteSequenceType&& x) noexcept
{

    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);

    return *this;
}

bool eprosima::fastrtps::types::CompleteSequenceType::operator ==(
        const CompleteSequenceType& x) const
{

    return (m_collection_flag == x.m_collection_flag && m_header == x.m_header && m_element == x.m_element);
}

bool eprosima::fastrtps::types::CompleteSequenceType::operator !=(
        const CompleteSequenceType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteSequenceType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteSequenceType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteCollectionElement::getCdrSerializedSize(data.element(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteSequenceType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_collection_flag;scdr << m_header;scdr << m_element;
}

void eprosima::fastrtps::types::CompleteSequenceType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_collection_flag = (eprosima::fastrtps::types::CollectionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_element;
}

/*!
 * @brief This function sets a value in member collection_flag
 * @param _collection_flag New value for member collection_flag
 */
void eprosima::fastrtps::types::CompleteSequenceType::collection_flag(
        eprosima::fastrtps::types::CollectionTypeFlag _collection_flag)
{
    m_collection_flag = _collection_flag;
}

/*!
 * @brief This function returns the value of member collection_flag
 * @return Value of member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag eprosima::fastrtps::types::CompleteSequenceType::collection_flag() const
{
    return m_collection_flag;
}

/*!
 * @brief This function returns a reference to member collection_flag
 * @return Reference to member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag& eprosima::fastrtps::types::CompleteSequenceType::collection_flag()
{
    return m_collection_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteSequenceType::header(
        const eprosima::fastrtps::types::CompleteCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteSequenceType::header(
        eprosima::fastrtps::types::CompleteCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteCollectionHeader& eprosima::fastrtps::types::CompleteSequenceType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteCollectionHeader& eprosima::fastrtps::types::CompleteSequenceType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member element
 * @param _element New value to be copied in member element
 */
void eprosima::fastrtps::types::CompleteSequenceType::element(
        const eprosima::fastrtps::types::CompleteCollectionElement& _element)
{
    m_element = _element;
}

/*!
 * @brief This function moves the value in member element
 * @param _element New value to be moved in member element
 */
void eprosima::fastrtps::types::CompleteSequenceType::element(
        eprosima::fastrtps::types::CompleteCollectionElement&& _element)
{
    m_element = std::move(_element);
}

/*!
 * @brief This function returns a constant reference to member element
 * @return Constant reference to member element
 */
const eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteSequenceType::element() const
{
    return m_element;
}

/*!
 * @brief This function returns a reference to member element
 * @return Reference to member element
 */
eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteSequenceType::element()
{
    return m_element;
}


size_t eprosima::fastrtps::types::CompleteSequenceType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteSequenceType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteSequenceType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteSequenceType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalSequenceType::MinimalSequenceType()
{
    // eprosima::fastrtps::types::CollectionTypeFlag m_collection_flag
    m_collection_flag = static_cast<eprosima::fastrtps::types::CollectionTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalCollectionHeader m_header

    // eprosima::fastrtps::types::MinimalCollectionElement m_element


}

eprosima::fastrtps::types::MinimalSequenceType::~MinimalSequenceType()
{



}

eprosima::fastrtps::types::MinimalSequenceType::MinimalSequenceType(
        const MinimalSequenceType& x)
{
    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;
}

eprosima::fastrtps::types::MinimalSequenceType::MinimalSequenceType(
        MinimalSequenceType&& x) noexcept 
{
    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);
}

eprosima::fastrtps::types::MinimalSequenceType& eprosima::fastrtps::types::MinimalSequenceType::operator =(
        const MinimalSequenceType& x)
{

    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;

    return *this;
}

eprosima::fastrtps::types::MinimalSequenceType& eprosima::fastrtps::types::MinimalSequenceType::operator =(
        MinimalSequenceType&& x) noexcept
{

    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);

    return *this;
}

bool eprosima::fastrtps::types::MinimalSequenceType::operator ==(
        const MinimalSequenceType& x) const
{

    return (m_collection_flag == x.m_collection_flag && m_header == x.m_header && m_element == x.m_element);
}

bool eprosima::fastrtps::types::MinimalSequenceType::operator !=(
        const MinimalSequenceType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalSequenceType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalSequenceType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalCollectionElement::getCdrSerializedSize(data.element(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalSequenceType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_collection_flag;scdr << m_header;scdr << m_element;
}

void eprosima::fastrtps::types::MinimalSequenceType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_collection_flag = (eprosima::fastrtps::types::CollectionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_element;
}

/*!
 * @brief This function sets a value in member collection_flag
 * @param _collection_flag New value for member collection_flag
 */
void eprosima::fastrtps::types::MinimalSequenceType::collection_flag(
        eprosima::fastrtps::types::CollectionTypeFlag _collection_flag)
{
    m_collection_flag = _collection_flag;
}

/*!
 * @brief This function returns the value of member collection_flag
 * @return Value of member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag eprosima::fastrtps::types::MinimalSequenceType::collection_flag() const
{
    return m_collection_flag;
}

/*!
 * @brief This function returns a reference to member collection_flag
 * @return Reference to member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag& eprosima::fastrtps::types::MinimalSequenceType::collection_flag()
{
    return m_collection_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalSequenceType::header(
        const eprosima::fastrtps::types::MinimalCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalSequenceType::header(
        eprosima::fastrtps::types::MinimalCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalCollectionHeader& eprosima::fastrtps::types::MinimalSequenceType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalCollectionHeader& eprosima::fastrtps::types::MinimalSequenceType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member element
 * @param _element New value to be copied in member element
 */
void eprosima::fastrtps::types::MinimalSequenceType::element(
        const eprosima::fastrtps::types::MinimalCollectionElement& _element)
{
    m_element = _element;
}

/*!
 * @brief This function moves the value in member element
 * @param _element New value to be moved in member element
 */
void eprosima::fastrtps::types::MinimalSequenceType::element(
        eprosima::fastrtps::types::MinimalCollectionElement&& _element)
{
    m_element = std::move(_element);
}

/*!
 * @brief This function returns a constant reference to member element
 * @return Constant reference to member element
 */
const eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalSequenceType::element() const
{
    return m_element;
}

/*!
 * @brief This function returns a reference to member element
 * @return Reference to member element
 */
eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalSequenceType::element()
{
    return m_element;
}


size_t eprosima::fastrtps::types::MinimalSequenceType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalSequenceType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalSequenceType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalSequenceType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonArrayHeader::CommonArrayHeader()
{
    // eprosima::fastrtps::types::LBoundSeq m_bound_seq


}

eprosima::fastrtps::types::CommonArrayHeader::~CommonArrayHeader()
{
}

eprosima::fastrtps::types::CommonArrayHeader::CommonArrayHeader(
        const CommonArrayHeader& x)
{
    m_bound_seq = x.m_bound_seq;
}

eprosima::fastrtps::types::CommonArrayHeader::CommonArrayHeader(
        CommonArrayHeader&& x) noexcept 
{
    m_bound_seq = std::move(x.m_bound_seq);
}

eprosima::fastrtps::types::CommonArrayHeader& eprosima::fastrtps::types::CommonArrayHeader::operator =(
        const CommonArrayHeader& x)
{

    m_bound_seq = x.m_bound_seq;

    return *this;
}

eprosima::fastrtps::types::CommonArrayHeader& eprosima::fastrtps::types::CommonArrayHeader::operator =(
        CommonArrayHeader&& x) noexcept
{

    m_bound_seq = std::move(x.m_bound_seq);

    return *this;
}

bool eprosima::fastrtps::types::CommonArrayHeader::operator ==(
        const CommonArrayHeader& x) const
{

    return (m_bound_seq == x.m_bound_seq);
}

bool eprosima::fastrtps::types::CommonArrayHeader::operator !=(
        const CommonArrayHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonArrayHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonArrayHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonArrayHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonArrayHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.bound_seq().size() > 0)
    {
        current_alignment += (data.bound_seq().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonArrayHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bound_seq;
}

void eprosima::fastrtps::types::CommonArrayHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bound_seq;}

/*!
 * @brief This function copies the value in member bound_seq
 * @param _bound_seq New value to be copied in member bound_seq
 */
void eprosima::fastrtps::types::CommonArrayHeader::bound_seq(
        const eprosima::fastrtps::types::LBoundSeq& _bound_seq)
{
    m_bound_seq = _bound_seq;
}

/*!
 * @brief This function moves the value in member bound_seq
 * @param _bound_seq New value to be moved in member bound_seq
 */
void eprosima::fastrtps::types::CommonArrayHeader::bound_seq(
        eprosima::fastrtps::types::LBoundSeq&& _bound_seq)
{
    m_bound_seq = std::move(_bound_seq);
}

/*!
 * @brief This function returns a constant reference to member bound_seq
 * @return Constant reference to member bound_seq
 */
const eprosima::fastrtps::types::LBoundSeq& eprosima::fastrtps::types::CommonArrayHeader::bound_seq() const
{
    return m_bound_seq;
}

/*!
 * @brief This function returns a reference to member bound_seq
 * @return Reference to member bound_seq
 */
eprosima::fastrtps::types::LBoundSeq& eprosima::fastrtps::types::CommonArrayHeader::bound_seq()
{
    return m_bound_seq;
}


size_t eprosima::fastrtps::types::CommonArrayHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonArrayHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonArrayHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonArrayHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteArrayHeader::CompleteArrayHeader()
{
    // eprosima::fastrtps::types::CommonArrayHeader m_common

    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteArrayHeader::~CompleteArrayHeader()
{


}

eprosima::fastrtps::types::CompleteArrayHeader::CompleteArrayHeader(
        const CompleteArrayHeader& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteArrayHeader::CompleteArrayHeader(
        CompleteArrayHeader&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteArrayHeader& eprosima::fastrtps::types::CompleteArrayHeader::operator =(
        const CompleteArrayHeader& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteArrayHeader& eprosima::fastrtps::types::CompleteArrayHeader::operator =(
        CompleteArrayHeader&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteArrayHeader::operator ==(
        const CompleteArrayHeader& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteArrayHeader::operator !=(
        const CompleteArrayHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteArrayHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteArrayHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteArrayHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteArrayHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonArrayHeader::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteArrayHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteArrayHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteArrayHeader::common(
        const eprosima::fastrtps::types::CommonArrayHeader& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteArrayHeader::common(
        eprosima::fastrtps::types::CommonArrayHeader&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonArrayHeader& eprosima::fastrtps::types::CompleteArrayHeader::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonArrayHeader& eprosima::fastrtps::types::CompleteArrayHeader::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteArrayHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteArrayHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteArrayHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteArrayHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteArrayHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteArrayHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteArrayHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteArrayHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalArrayHeader::MinimalArrayHeader()
{
    // eprosima::fastrtps::types::CommonArrayHeader m_common


}

eprosima::fastrtps::types::MinimalArrayHeader::~MinimalArrayHeader()
{
}

eprosima::fastrtps::types::MinimalArrayHeader::MinimalArrayHeader(
        const MinimalArrayHeader& x)
{
    m_common = x.m_common;
}

eprosima::fastrtps::types::MinimalArrayHeader::MinimalArrayHeader(
        MinimalArrayHeader&& x) noexcept 
{
    m_common = std::move(x.m_common);
}

eprosima::fastrtps::types::MinimalArrayHeader& eprosima::fastrtps::types::MinimalArrayHeader::operator =(
        const MinimalArrayHeader& x)
{

    m_common = x.m_common;

    return *this;
}

eprosima::fastrtps::types::MinimalArrayHeader& eprosima::fastrtps::types::MinimalArrayHeader::operator =(
        MinimalArrayHeader&& x) noexcept
{

    m_common = std::move(x.m_common);

    return *this;
}

bool eprosima::fastrtps::types::MinimalArrayHeader::operator ==(
        const MinimalArrayHeader& x) const
{

    return (m_common == x.m_common);
}

bool eprosima::fastrtps::types::MinimalArrayHeader::operator !=(
        const MinimalArrayHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalArrayHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalArrayHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalArrayHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalArrayHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonArrayHeader::getCdrSerializedSize(data.common(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalArrayHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;
}

void eprosima::fastrtps::types::MinimalArrayHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalArrayHeader::common(
        const eprosima::fastrtps::types::CommonArrayHeader& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalArrayHeader::common(
        eprosima::fastrtps::types::CommonArrayHeader&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonArrayHeader& eprosima::fastrtps::types::MinimalArrayHeader::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonArrayHeader& eprosima::fastrtps::types::MinimalArrayHeader::common()
{
    return m_common;
}


size_t eprosima::fastrtps::types::MinimalArrayHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalArrayHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalArrayHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalArrayHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteArrayType::CompleteArrayType()
{
    // eprosima::fastrtps::types::CollectionTypeFlag m_collection_flag
    m_collection_flag = static_cast<eprosima::fastrtps::types::CollectionTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteArrayHeader m_header

    // eprosima::fastrtps::types::CompleteCollectionElement m_element


}

eprosima::fastrtps::types::CompleteArrayType::~CompleteArrayType()
{



}

eprosima::fastrtps::types::CompleteArrayType::CompleteArrayType(
        const CompleteArrayType& x)
{
    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;
}

eprosima::fastrtps::types::CompleteArrayType::CompleteArrayType(
        CompleteArrayType&& x) noexcept 
{
    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);
}

eprosima::fastrtps::types::CompleteArrayType& eprosima::fastrtps::types::CompleteArrayType::operator =(
        const CompleteArrayType& x)
{

    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;

    return *this;
}

eprosima::fastrtps::types::CompleteArrayType& eprosima::fastrtps::types::CompleteArrayType::operator =(
        CompleteArrayType&& x) noexcept
{

    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);

    return *this;
}

bool eprosima::fastrtps::types::CompleteArrayType::operator ==(
        const CompleteArrayType& x) const
{

    return (m_collection_flag == x.m_collection_flag && m_header == x.m_header && m_element == x.m_element);
}

bool eprosima::fastrtps::types::CompleteArrayType::operator !=(
        const CompleteArrayType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteArrayType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteArrayType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteArrayHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteCollectionElement::getCdrSerializedSize(data.element(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteArrayType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_collection_flag;scdr << m_header;scdr << m_element;
}

void eprosima::fastrtps::types::CompleteArrayType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_collection_flag = (eprosima::fastrtps::types::CollectionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_element;
}

/*!
 * @brief This function sets a value in member collection_flag
 * @param _collection_flag New value for member collection_flag
 */
void eprosima::fastrtps::types::CompleteArrayType::collection_flag(
        eprosima::fastrtps::types::CollectionTypeFlag _collection_flag)
{
    m_collection_flag = _collection_flag;
}

/*!
 * @brief This function returns the value of member collection_flag
 * @return Value of member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag eprosima::fastrtps::types::CompleteArrayType::collection_flag() const
{
    return m_collection_flag;
}

/*!
 * @brief This function returns a reference to member collection_flag
 * @return Reference to member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag& eprosima::fastrtps::types::CompleteArrayType::collection_flag()
{
    return m_collection_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteArrayType::header(
        const eprosima::fastrtps::types::CompleteArrayHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteArrayType::header(
        eprosima::fastrtps::types::CompleteArrayHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteArrayHeader& eprosima::fastrtps::types::CompleteArrayType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteArrayHeader& eprosima::fastrtps::types::CompleteArrayType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member element
 * @param _element New value to be copied in member element
 */
void eprosima::fastrtps::types::CompleteArrayType::element(
        const eprosima::fastrtps::types::CompleteCollectionElement& _element)
{
    m_element = _element;
}

/*!
 * @brief This function moves the value in member element
 * @param _element New value to be moved in member element
 */
void eprosima::fastrtps::types::CompleteArrayType::element(
        eprosima::fastrtps::types::CompleteCollectionElement&& _element)
{
    m_element = std::move(_element);
}

/*!
 * @brief This function returns a constant reference to member element
 * @return Constant reference to member element
 */
const eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteArrayType::element() const
{
    return m_element;
}

/*!
 * @brief This function returns a reference to member element
 * @return Reference to member element
 */
eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteArrayType::element()
{
    return m_element;
}


size_t eprosima::fastrtps::types::CompleteArrayType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteArrayType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteArrayType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteArrayType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalArrayType::MinimalArrayType()
{
    // eprosima::fastrtps::types::CollectionTypeFlag m_collection_flag
    m_collection_flag = static_cast<eprosima::fastrtps::types::CollectionTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalArrayHeader m_header

    // eprosima::fastrtps::types::MinimalCollectionElement m_element


}

eprosima::fastrtps::types::MinimalArrayType::~MinimalArrayType()
{



}

eprosima::fastrtps::types::MinimalArrayType::MinimalArrayType(
        const MinimalArrayType& x)
{
    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;
}

eprosima::fastrtps::types::MinimalArrayType::MinimalArrayType(
        MinimalArrayType&& x) noexcept 
{
    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);
}

eprosima::fastrtps::types::MinimalArrayType& eprosima::fastrtps::types::MinimalArrayType::operator =(
        const MinimalArrayType& x)
{

    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_element = x.m_element;

    return *this;
}

eprosima::fastrtps::types::MinimalArrayType& eprosima::fastrtps::types::MinimalArrayType::operator =(
        MinimalArrayType&& x) noexcept
{

    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_element = std::move(x.m_element);

    return *this;
}

bool eprosima::fastrtps::types::MinimalArrayType::operator ==(
        const MinimalArrayType& x) const
{

    return (m_collection_flag == x.m_collection_flag && m_header == x.m_header && m_element == x.m_element);
}

bool eprosima::fastrtps::types::MinimalArrayType::operator !=(
        const MinimalArrayType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalArrayType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalArrayType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalArrayHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalCollectionElement::getCdrSerializedSize(data.element(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalArrayType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_collection_flag;scdr << m_header;scdr << m_element;
}

void eprosima::fastrtps::types::MinimalArrayType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_collection_flag = (eprosima::fastrtps::types::CollectionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_element;
}

/*!
 * @brief This function sets a value in member collection_flag
 * @param _collection_flag New value for member collection_flag
 */
void eprosima::fastrtps::types::MinimalArrayType::collection_flag(
        eprosima::fastrtps::types::CollectionTypeFlag _collection_flag)
{
    m_collection_flag = _collection_flag;
}

/*!
 * @brief This function returns the value of member collection_flag
 * @return Value of member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag eprosima::fastrtps::types::MinimalArrayType::collection_flag() const
{
    return m_collection_flag;
}

/*!
 * @brief This function returns a reference to member collection_flag
 * @return Reference to member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag& eprosima::fastrtps::types::MinimalArrayType::collection_flag()
{
    return m_collection_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalArrayType::header(
        const eprosima::fastrtps::types::MinimalArrayHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalArrayType::header(
        eprosima::fastrtps::types::MinimalArrayHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalArrayHeader& eprosima::fastrtps::types::MinimalArrayType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalArrayHeader& eprosima::fastrtps::types::MinimalArrayType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member element
 * @param _element New value to be copied in member element
 */
void eprosima::fastrtps::types::MinimalArrayType::element(
        const eprosima::fastrtps::types::MinimalCollectionElement& _element)
{
    m_element = _element;
}

/*!
 * @brief This function moves the value in member element
 * @param _element New value to be moved in member element
 */
void eprosima::fastrtps::types::MinimalArrayType::element(
        eprosima::fastrtps::types::MinimalCollectionElement&& _element)
{
    m_element = std::move(_element);
}

/*!
 * @brief This function returns a constant reference to member element
 * @return Constant reference to member element
 */
const eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalArrayType::element() const
{
    return m_element;
}

/*!
 * @brief This function returns a reference to member element
 * @return Reference to member element
 */
eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalArrayType::element()
{
    return m_element;
}


size_t eprosima::fastrtps::types::MinimalArrayType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalArrayType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalArrayType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalArrayType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteMapType::CompleteMapType()
{
    // eprosima::fastrtps::types::CollectionTypeFlag m_collection_flag
    m_collection_flag = static_cast<eprosima::fastrtps::types::CollectionTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteCollectionHeader m_header

    // eprosima::fastrtps::types::CompleteCollectionElement m_key

    // eprosima::fastrtps::types::CompleteCollectionElement m_element


}

eprosima::fastrtps::types::CompleteMapType::~CompleteMapType()
{




}

eprosima::fastrtps::types::CompleteMapType::CompleteMapType(
        const CompleteMapType& x)
{
    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_key = x.m_key;
    m_element = x.m_element;
}

eprosima::fastrtps::types::CompleteMapType::CompleteMapType(
        CompleteMapType&& x) noexcept 
{
    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_key = std::move(x.m_key);
    m_element = std::move(x.m_element);
}

eprosima::fastrtps::types::CompleteMapType& eprosima::fastrtps::types::CompleteMapType::operator =(
        const CompleteMapType& x)
{

    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_key = x.m_key;
    m_element = x.m_element;

    return *this;
}

eprosima::fastrtps::types::CompleteMapType& eprosima::fastrtps::types::CompleteMapType::operator =(
        CompleteMapType&& x) noexcept
{

    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_key = std::move(x.m_key);
    m_element = std::move(x.m_element);

    return *this;
}

bool eprosima::fastrtps::types::CompleteMapType::operator ==(
        const CompleteMapType& x) const
{

    return (m_collection_flag == x.m_collection_flag && m_header == x.m_header && m_key == x.m_key && m_element == x.m_element);
}

bool eprosima::fastrtps::types::CompleteMapType::operator !=(
        const CompleteMapType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteMapType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteMapType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteCollectionElement::getCdrSerializedSize(data.key(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteCollectionElement::getCdrSerializedSize(data.element(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteMapType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_collection_flag;scdr << m_header;scdr << m_key;scdr << m_element;
}

void eprosima::fastrtps::types::CompleteMapType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_collection_flag = (eprosima::fastrtps::types::CollectionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_key;
    dcdr >> m_element;
}

/*!
 * @brief This function sets a value in member collection_flag
 * @param _collection_flag New value for member collection_flag
 */
void eprosima::fastrtps::types::CompleteMapType::collection_flag(
        eprosima::fastrtps::types::CollectionTypeFlag _collection_flag)
{
    m_collection_flag = _collection_flag;
}

/*!
 * @brief This function returns the value of member collection_flag
 * @return Value of member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag eprosima::fastrtps::types::CompleteMapType::collection_flag() const
{
    return m_collection_flag;
}

/*!
 * @brief This function returns a reference to member collection_flag
 * @return Reference to member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag& eprosima::fastrtps::types::CompleteMapType::collection_flag()
{
    return m_collection_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteMapType::header(
        const eprosima::fastrtps::types::CompleteCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteMapType::header(
        eprosima::fastrtps::types::CompleteCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteCollectionHeader& eprosima::fastrtps::types::CompleteMapType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteCollectionHeader& eprosima::fastrtps::types::CompleteMapType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member key
 * @param _key New value to be copied in member key
 */
void eprosima::fastrtps::types::CompleteMapType::key(
        const eprosima::fastrtps::types::CompleteCollectionElement& _key)
{
    m_key = _key;
}

/*!
 * @brief This function moves the value in member key
 * @param _key New value to be moved in member key
 */
void eprosima::fastrtps::types::CompleteMapType::key(
        eprosima::fastrtps::types::CompleteCollectionElement&& _key)
{
    m_key = std::move(_key);
}

/*!
 * @brief This function returns a constant reference to member key
 * @return Constant reference to member key
 */
const eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteMapType::key() const
{
    return m_key;
}

/*!
 * @brief This function returns a reference to member key
 * @return Reference to member key
 */
eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteMapType::key()
{
    return m_key;
}
/*!
 * @brief This function copies the value in member element
 * @param _element New value to be copied in member element
 */
void eprosima::fastrtps::types::CompleteMapType::element(
        const eprosima::fastrtps::types::CompleteCollectionElement& _element)
{
    m_element = _element;
}

/*!
 * @brief This function moves the value in member element
 * @param _element New value to be moved in member element
 */
void eprosima::fastrtps::types::CompleteMapType::element(
        eprosima::fastrtps::types::CompleteCollectionElement&& _element)
{
    m_element = std::move(_element);
}

/*!
 * @brief This function returns a constant reference to member element
 * @return Constant reference to member element
 */
const eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteMapType::element() const
{
    return m_element;
}

/*!
 * @brief This function returns a reference to member element
 * @return Reference to member element
 */
eprosima::fastrtps::types::CompleteCollectionElement& eprosima::fastrtps::types::CompleteMapType::element()
{
    return m_element;
}


size_t eprosima::fastrtps::types::CompleteMapType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteMapType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteMapType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteMapType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalMapType::MinimalMapType()
{
    // eprosima::fastrtps::types::CollectionTypeFlag m_collection_flag
    m_collection_flag = static_cast<eprosima::fastrtps::types::CollectionTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalCollectionHeader m_header

    // eprosima::fastrtps::types::MinimalCollectionElement m_key

    // eprosima::fastrtps::types::MinimalCollectionElement m_element


}

eprosima::fastrtps::types::MinimalMapType::~MinimalMapType()
{




}

eprosima::fastrtps::types::MinimalMapType::MinimalMapType(
        const MinimalMapType& x)
{
    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_key = x.m_key;
    m_element = x.m_element;
}

eprosima::fastrtps::types::MinimalMapType::MinimalMapType(
        MinimalMapType&& x) noexcept 
{
    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_key = std::move(x.m_key);
    m_element = std::move(x.m_element);
}

eprosima::fastrtps::types::MinimalMapType& eprosima::fastrtps::types::MinimalMapType::operator =(
        const MinimalMapType& x)
{

    m_collection_flag = x.m_collection_flag;
    m_header = x.m_header;
    m_key = x.m_key;
    m_element = x.m_element;

    return *this;
}

eprosima::fastrtps::types::MinimalMapType& eprosima::fastrtps::types::MinimalMapType::operator =(
        MinimalMapType&& x) noexcept
{

    m_collection_flag = x.m_collection_flag;
    m_header = std::move(x.m_header);
    m_key = std::move(x.m_key);
    m_element = std::move(x.m_element);

    return *this;
}

bool eprosima::fastrtps::types::MinimalMapType::operator ==(
        const MinimalMapType& x) const
{

    return (m_collection_flag == x.m_collection_flag && m_header == x.m_header && m_key == x.m_key && m_element == x.m_element);
}

bool eprosima::fastrtps::types::MinimalMapType::operator !=(
        const MinimalMapType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalMapType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalMapType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalCollectionHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalCollectionElement::getCdrSerializedSize(data.key(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalCollectionElement::getCdrSerializedSize(data.element(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalMapType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_collection_flag;scdr << m_header;scdr << m_key;scdr << m_element;
}

void eprosima::fastrtps::types::MinimalMapType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_collection_flag = (eprosima::fastrtps::types::CollectionTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_key;
    dcdr >> m_element;
}

/*!
 * @brief This function sets a value in member collection_flag
 * @param _collection_flag New value for member collection_flag
 */
void eprosima::fastrtps::types::MinimalMapType::collection_flag(
        eprosima::fastrtps::types::CollectionTypeFlag _collection_flag)
{
    m_collection_flag = _collection_flag;
}

/*!
 * @brief This function returns the value of member collection_flag
 * @return Value of member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag eprosima::fastrtps::types::MinimalMapType::collection_flag() const
{
    return m_collection_flag;
}

/*!
 * @brief This function returns a reference to member collection_flag
 * @return Reference to member collection_flag
 */
eprosima::fastrtps::types::CollectionTypeFlag& eprosima::fastrtps::types::MinimalMapType::collection_flag()
{
    return m_collection_flag;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalMapType::header(
        const eprosima::fastrtps::types::MinimalCollectionHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalMapType::header(
        eprosima::fastrtps::types::MinimalCollectionHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalCollectionHeader& eprosima::fastrtps::types::MinimalMapType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalCollectionHeader& eprosima::fastrtps::types::MinimalMapType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member key
 * @param _key New value to be copied in member key
 */
void eprosima::fastrtps::types::MinimalMapType::key(
        const eprosima::fastrtps::types::MinimalCollectionElement& _key)
{
    m_key = _key;
}

/*!
 * @brief This function moves the value in member key
 * @param _key New value to be moved in member key
 */
void eprosima::fastrtps::types::MinimalMapType::key(
        eprosima::fastrtps::types::MinimalCollectionElement&& _key)
{
    m_key = std::move(_key);
}

/*!
 * @brief This function returns a constant reference to member key
 * @return Constant reference to member key
 */
const eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalMapType::key() const
{
    return m_key;
}

/*!
 * @brief This function returns a reference to member key
 * @return Reference to member key
 */
eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalMapType::key()
{
    return m_key;
}
/*!
 * @brief This function copies the value in member element
 * @param _element New value to be copied in member element
 */
void eprosima::fastrtps::types::MinimalMapType::element(
        const eprosima::fastrtps::types::MinimalCollectionElement& _element)
{
    m_element = _element;
}

/*!
 * @brief This function moves the value in member element
 * @param _element New value to be moved in member element
 */
void eprosima::fastrtps::types::MinimalMapType::element(
        eprosima::fastrtps::types::MinimalCollectionElement&& _element)
{
    m_element = std::move(_element);
}

/*!
 * @brief This function returns a constant reference to member element
 * @return Constant reference to member element
 */
const eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalMapType::element() const
{
    return m_element;
}

/*!
 * @brief This function returns a reference to member element
 * @return Reference to member element
 */
eprosima::fastrtps::types::MinimalCollectionElement& eprosima::fastrtps::types::MinimalMapType::element()
{
    return m_element;
}


size_t eprosima::fastrtps::types::MinimalMapType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalMapType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalMapType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalMapType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CommonEnumeratedLiteral::CommonEnumeratedLiteral()
{
    // long m_value
    m_value = 0;
    // eprosima::fastrtps::types::EnumeratedLiteralFlag m_flags
    m_flags = static_cast<eprosima::fastrtps::types::EnumeratedLiteralFlag>(0);

}

eprosima::fastrtps::types::CommonEnumeratedLiteral::~CommonEnumeratedLiteral()
{


}

eprosima::fastrtps::types::CommonEnumeratedLiteral::CommonEnumeratedLiteral(
        const CommonEnumeratedLiteral& x)
{
    m_value = x.m_value;
    m_flags = x.m_flags;
}

eprosima::fastrtps::types::CommonEnumeratedLiteral::CommonEnumeratedLiteral(
        CommonEnumeratedLiteral&& x) noexcept 
{
    m_value = x.m_value;
    m_flags = x.m_flags;
}

eprosima::fastrtps::types::CommonEnumeratedLiteral& eprosima::fastrtps::types::CommonEnumeratedLiteral::operator =(
        const CommonEnumeratedLiteral& x)
{

    m_value = x.m_value;
    m_flags = x.m_flags;

    return *this;
}

eprosima::fastrtps::types::CommonEnumeratedLiteral& eprosima::fastrtps::types::CommonEnumeratedLiteral::operator =(
        CommonEnumeratedLiteral&& x) noexcept
{

    m_value = x.m_value;
    m_flags = x.m_flags;

    return *this;
}

bool eprosima::fastrtps::types::CommonEnumeratedLiteral::operator ==(
        const CommonEnumeratedLiteral& x) const
{

    return (m_value == x.m_value && m_flags == x.m_flags);
}

bool eprosima::fastrtps::types::CommonEnumeratedLiteral::operator !=(
        const CommonEnumeratedLiteral& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonEnumeratedLiteral::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonEnumeratedLiteral_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonEnumeratedLiteral::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonEnumeratedLiteral& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonEnumeratedLiteral::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;scdr << (uint16_t)m_flags;
}

void eprosima::fastrtps::types::CommonEnumeratedLiteral::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_flags = (eprosima::fastrtps::types::EnumeratedLiteralFlag)bitmask_value;
    }


}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void eprosima::fastrtps::types::CommonEnumeratedLiteral::value(
        int32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int32_t eprosima::fastrtps::types::CommonEnumeratedLiteral::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int32_t& eprosima::fastrtps::types::CommonEnumeratedLiteral::value()
{
    return m_value;
}

/*!
 * @brief This function sets a value in member flags
 * @param _flags New value for member flags
 */
void eprosima::fastrtps::types::CommonEnumeratedLiteral::flags(
        eprosima::fastrtps::types::EnumeratedLiteralFlag _flags)
{
    m_flags = _flags;
}

/*!
 * @brief This function returns the value of member flags
 * @return Value of member flags
 */
eprosima::fastrtps::types::EnumeratedLiteralFlag eprosima::fastrtps::types::CommonEnumeratedLiteral::flags() const
{
    return m_flags;
}

/*!
 * @brief This function returns a reference to member flags
 * @return Reference to member flags
 */
eprosima::fastrtps::types::EnumeratedLiteralFlag& eprosima::fastrtps::types::CommonEnumeratedLiteral::flags()
{
    return m_flags;
}



size_t eprosima::fastrtps::types::CommonEnumeratedLiteral::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonEnumeratedLiteral_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonEnumeratedLiteral::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonEnumeratedLiteral::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteEnumeratedLiteral::CompleteEnumeratedLiteral()
{
    // eprosima::fastrtps::types::CommonEnumeratedLiteral m_common

    // eprosima::fastrtps::types::CompleteMemberDetail m_detail


}

eprosima::fastrtps::types::CompleteEnumeratedLiteral::~CompleteEnumeratedLiteral()
{


}

eprosima::fastrtps::types::CompleteEnumeratedLiteral::CompleteEnumeratedLiteral(
        const CompleteEnumeratedLiteral& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteEnumeratedLiteral::CompleteEnumeratedLiteral(
        CompleteEnumeratedLiteral&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteEnumeratedLiteral& eprosima::fastrtps::types::CompleteEnumeratedLiteral::operator =(
        const CompleteEnumeratedLiteral& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteEnumeratedLiteral& eprosima::fastrtps::types::CompleteEnumeratedLiteral::operator =(
        CompleteEnumeratedLiteral&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteEnumeratedLiteral::operator ==(
        const CompleteEnumeratedLiteral& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteEnumeratedLiteral::operator !=(
        const CompleteEnumeratedLiteral& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteEnumeratedLiteral::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteEnumeratedLiteral_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteEnumeratedLiteral::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteEnumeratedLiteral& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonEnumeratedLiteral::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteEnumeratedLiteral::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteEnumeratedLiteral::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteEnumeratedLiteral::common(
        const eprosima::fastrtps::types::CommonEnumeratedLiteral& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteEnumeratedLiteral::common(
        eprosima::fastrtps::types::CommonEnumeratedLiteral&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonEnumeratedLiteral& eprosima::fastrtps::types::CompleteEnumeratedLiteral::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonEnumeratedLiteral& eprosima::fastrtps::types::CompleteEnumeratedLiteral::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteEnumeratedLiteral::detail(
        const eprosima::fastrtps::types::CompleteMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteEnumeratedLiteral::detail(
        eprosima::fastrtps::types::CompleteMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteEnumeratedLiteral::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteEnumeratedLiteral::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteEnumeratedLiteral::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteEnumeratedLiteral_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteEnumeratedLiteral::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteEnumeratedLiteral::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::MinimalEnumeratedLiteral::MinimalEnumeratedLiteral()
{
    // eprosima::fastrtps::types::CommonEnumeratedLiteral m_common

    // eprosima::fastrtps::types::MinimalMemberDetail m_detail


}

eprosima::fastrtps::types::MinimalEnumeratedLiteral::~MinimalEnumeratedLiteral()
{


}

eprosima::fastrtps::types::MinimalEnumeratedLiteral::MinimalEnumeratedLiteral(
        const MinimalEnumeratedLiteral& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::MinimalEnumeratedLiteral::MinimalEnumeratedLiteral(
        MinimalEnumeratedLiteral&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::MinimalEnumeratedLiteral& eprosima::fastrtps::types::MinimalEnumeratedLiteral::operator =(
        const MinimalEnumeratedLiteral& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::MinimalEnumeratedLiteral& eprosima::fastrtps::types::MinimalEnumeratedLiteral::operator =(
        MinimalEnumeratedLiteral&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::MinimalEnumeratedLiteral::operator ==(
        const MinimalEnumeratedLiteral& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::MinimalEnumeratedLiteral::operator !=(
        const MinimalEnumeratedLiteral& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalEnumeratedLiteral::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalEnumeratedLiteral_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalEnumeratedLiteral::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalEnumeratedLiteral& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonEnumeratedLiteral::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalEnumeratedLiteral::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::MinimalEnumeratedLiteral::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalEnumeratedLiteral::common(
        const eprosima::fastrtps::types::CommonEnumeratedLiteral& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalEnumeratedLiteral::common(
        eprosima::fastrtps::types::CommonEnumeratedLiteral&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonEnumeratedLiteral& eprosima::fastrtps::types::MinimalEnumeratedLiteral::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonEnumeratedLiteral& eprosima::fastrtps::types::MinimalEnumeratedLiteral::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::MinimalEnumeratedLiteral::detail(
        const eprosima::fastrtps::types::MinimalMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::MinimalEnumeratedLiteral::detail(
        eprosima::fastrtps::types::MinimalMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalEnumeratedLiteral::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalEnumeratedLiteral::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::MinimalEnumeratedLiteral::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalEnumeratedLiteral_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalEnumeratedLiteral::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalEnumeratedLiteral::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CommonEnumeratedHeader::CommonEnumeratedHeader()
{
    // eprosima::fastrtps::types::BitBound m_bit_bound
    m_bit_bound = 0;

}

eprosima::fastrtps::types::CommonEnumeratedHeader::~CommonEnumeratedHeader()
{
}

eprosima::fastrtps::types::CommonEnumeratedHeader::CommonEnumeratedHeader(
        const CommonEnumeratedHeader& x)
{
    m_bit_bound = x.m_bit_bound;
}

eprosima::fastrtps::types::CommonEnumeratedHeader::CommonEnumeratedHeader(
        CommonEnumeratedHeader&& x) noexcept 
{
    m_bit_bound = x.m_bit_bound;
}

eprosima::fastrtps::types::CommonEnumeratedHeader& eprosima::fastrtps::types::CommonEnumeratedHeader::operator =(
        const CommonEnumeratedHeader& x)
{

    m_bit_bound = x.m_bit_bound;

    return *this;
}

eprosima::fastrtps::types::CommonEnumeratedHeader& eprosima::fastrtps::types::CommonEnumeratedHeader::operator =(
        CommonEnumeratedHeader&& x) noexcept
{

    m_bit_bound = x.m_bit_bound;

    return *this;
}

bool eprosima::fastrtps::types::CommonEnumeratedHeader::operator ==(
        const CommonEnumeratedHeader& x) const
{

    return (m_bit_bound == x.m_bit_bound);
}

bool eprosima::fastrtps::types::CommonEnumeratedHeader::operator !=(
        const CommonEnumeratedHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonEnumeratedHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonEnumeratedHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonEnumeratedHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonEnumeratedHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonEnumeratedHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bit_bound;
}

void eprosima::fastrtps::types::CommonEnumeratedHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bit_bound;
}

/*!
 * @brief This function sets a value in member bit_bound
 * @param _bit_bound New value for member bit_bound
 */
void eprosima::fastrtps::types::CommonEnumeratedHeader::bit_bound(
        eprosima::fastrtps::types::BitBound _bit_bound)
{
    m_bit_bound = _bit_bound;
}

/*!
 * @brief This function returns the value of member bit_bound
 * @return Value of member bit_bound
 */
eprosima::fastrtps::types::BitBound eprosima::fastrtps::types::CommonEnumeratedHeader::bit_bound() const
{
    return m_bit_bound;
}

/*!
 * @brief This function returns a reference to member bit_bound
 * @return Reference to member bit_bound
 */
eprosima::fastrtps::types::BitBound& eprosima::fastrtps::types::CommonEnumeratedHeader::bit_bound()
{
    return m_bit_bound;
}



size_t eprosima::fastrtps::types::CommonEnumeratedHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonEnumeratedHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonEnumeratedHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonEnumeratedHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteEnumeratedHeader::CompleteEnumeratedHeader()
{
    // eprosima::fastrtps::types::CommonEnumeratedHeader m_common

    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteEnumeratedHeader::~CompleteEnumeratedHeader()
{


}

eprosima::fastrtps::types::CompleteEnumeratedHeader::CompleteEnumeratedHeader(
        const CompleteEnumeratedHeader& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteEnumeratedHeader::CompleteEnumeratedHeader(
        CompleteEnumeratedHeader&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteEnumeratedHeader& eprosima::fastrtps::types::CompleteEnumeratedHeader::operator =(
        const CompleteEnumeratedHeader& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteEnumeratedHeader& eprosima::fastrtps::types::CompleteEnumeratedHeader::operator =(
        CompleteEnumeratedHeader&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteEnumeratedHeader::operator ==(
        const CompleteEnumeratedHeader& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteEnumeratedHeader::operator !=(
        const CompleteEnumeratedHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteEnumeratedHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteEnumeratedHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteEnumeratedHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteEnumeratedHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonEnumeratedHeader::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteEnumeratedHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteEnumeratedHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteEnumeratedHeader::common(
        const eprosima::fastrtps::types::CommonEnumeratedHeader& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteEnumeratedHeader::common(
        eprosima::fastrtps::types::CommonEnumeratedHeader&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonEnumeratedHeader& eprosima::fastrtps::types::CompleteEnumeratedHeader::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonEnumeratedHeader& eprosima::fastrtps::types::CompleteEnumeratedHeader::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteEnumeratedHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteEnumeratedHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteEnumeratedHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteEnumeratedHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteEnumeratedHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteEnumeratedHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteEnumeratedHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteEnumeratedHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalEnumeratedHeader::MinimalEnumeratedHeader()
{
    // eprosima::fastrtps::types::CommonEnumeratedHeader m_common


}

eprosima::fastrtps::types::MinimalEnumeratedHeader::~MinimalEnumeratedHeader()
{
}

eprosima::fastrtps::types::MinimalEnumeratedHeader::MinimalEnumeratedHeader(
        const MinimalEnumeratedHeader& x)
{
    m_common = x.m_common;
}

eprosima::fastrtps::types::MinimalEnumeratedHeader::MinimalEnumeratedHeader(
        MinimalEnumeratedHeader&& x) noexcept 
{
    m_common = std::move(x.m_common);
}

eprosima::fastrtps::types::MinimalEnumeratedHeader& eprosima::fastrtps::types::MinimalEnumeratedHeader::operator =(
        const MinimalEnumeratedHeader& x)
{

    m_common = x.m_common;

    return *this;
}

eprosima::fastrtps::types::MinimalEnumeratedHeader& eprosima::fastrtps::types::MinimalEnumeratedHeader::operator =(
        MinimalEnumeratedHeader&& x) noexcept
{

    m_common = std::move(x.m_common);

    return *this;
}

bool eprosima::fastrtps::types::MinimalEnumeratedHeader::operator ==(
        const MinimalEnumeratedHeader& x) const
{

    return (m_common == x.m_common);
}

bool eprosima::fastrtps::types::MinimalEnumeratedHeader::operator !=(
        const MinimalEnumeratedHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalEnumeratedHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalEnumeratedHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalEnumeratedHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalEnumeratedHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonEnumeratedHeader::getCdrSerializedSize(data.common(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalEnumeratedHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;
}

void eprosima::fastrtps::types::MinimalEnumeratedHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalEnumeratedHeader::common(
        const eprosima::fastrtps::types::CommonEnumeratedHeader& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalEnumeratedHeader::common(
        eprosima::fastrtps::types::CommonEnumeratedHeader&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonEnumeratedHeader& eprosima::fastrtps::types::MinimalEnumeratedHeader::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonEnumeratedHeader& eprosima::fastrtps::types::MinimalEnumeratedHeader::common()
{
    return m_common;
}


size_t eprosima::fastrtps::types::MinimalEnumeratedHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalEnumeratedHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalEnumeratedHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalEnumeratedHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteEnumeratedType::CompleteEnumeratedType()
{
    // eprosima::fastrtps::types::EnumTypeFlag m_enum_flags
    m_enum_flags = static_cast<eprosima::fastrtps::types::EnumTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteEnumeratedHeader m_header

    // eprosima::fastrtps::types::CompleteEnumeratedLiteralSeq m_literal_seq


}

eprosima::fastrtps::types::CompleteEnumeratedType::~CompleteEnumeratedType()
{



}

eprosima::fastrtps::types::CompleteEnumeratedType::CompleteEnumeratedType(
        const CompleteEnumeratedType& x)
{
    m_enum_flags = x.m_enum_flags;
    m_header = x.m_header;
    m_literal_seq = x.m_literal_seq;
}

eprosima::fastrtps::types::CompleteEnumeratedType::CompleteEnumeratedType(
        CompleteEnumeratedType&& x) noexcept 
{
    m_enum_flags = x.m_enum_flags;
    m_header = std::move(x.m_header);
    m_literal_seq = std::move(x.m_literal_seq);
}

eprosima::fastrtps::types::CompleteEnumeratedType& eprosima::fastrtps::types::CompleteEnumeratedType::operator =(
        const CompleteEnumeratedType& x)
{

    m_enum_flags = x.m_enum_flags;
    m_header = x.m_header;
    m_literal_seq = x.m_literal_seq;

    return *this;
}

eprosima::fastrtps::types::CompleteEnumeratedType& eprosima::fastrtps::types::CompleteEnumeratedType::operator =(
        CompleteEnumeratedType&& x) noexcept
{

    m_enum_flags = x.m_enum_flags;
    m_header = std::move(x.m_header);
    m_literal_seq = std::move(x.m_literal_seq);

    return *this;
}

bool eprosima::fastrtps::types::CompleteEnumeratedType::operator ==(
        const CompleteEnumeratedType& x) const
{

    return (m_enum_flags == x.m_enum_flags && m_header == x.m_header && m_literal_seq == x.m_literal_seq);
}

bool eprosima::fastrtps::types::CompleteEnumeratedType::operator !=(
        const CompleteEnumeratedType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteEnumeratedType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteEnumeratedType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteEnumeratedType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteEnumeratedType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteEnumeratedHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.literal_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::CompleteEnumeratedLiteral::getCdrSerializedSize(data.literal_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteEnumeratedType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_enum_flags;scdr << m_header;scdr << m_literal_seq;

}

void eprosima::fastrtps::types::CompleteEnumeratedType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_enum_flags = (eprosima::fastrtps::types::EnumTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_literal_seq;
}

/*!
 * @brief This function sets a value in member enum_flags
 * @param _enum_flags New value for member enum_flags
 */
void eprosima::fastrtps::types::CompleteEnumeratedType::enum_flags(
        eprosima::fastrtps::types::EnumTypeFlag _enum_flags)
{
    m_enum_flags = _enum_flags;
}

/*!
 * @brief This function returns the value of member enum_flags
 * @return Value of member enum_flags
 */
eprosima::fastrtps::types::EnumTypeFlag eprosima::fastrtps::types::CompleteEnumeratedType::enum_flags() const
{
    return m_enum_flags;
}

/*!
 * @brief This function returns a reference to member enum_flags
 * @return Reference to member enum_flags
 */
eprosima::fastrtps::types::EnumTypeFlag& eprosima::fastrtps::types::CompleteEnumeratedType::enum_flags()
{
    return m_enum_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteEnumeratedType::header(
        const eprosima::fastrtps::types::CompleteEnumeratedHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteEnumeratedType::header(
        eprosima::fastrtps::types::CompleteEnumeratedHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteEnumeratedHeader& eprosima::fastrtps::types::CompleteEnumeratedType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteEnumeratedHeader& eprosima::fastrtps::types::CompleteEnumeratedType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member literal_seq
 * @param _literal_seq New value to be copied in member literal_seq
 */
void eprosima::fastrtps::types::CompleteEnumeratedType::literal_seq(
        const eprosima::fastrtps::types::CompleteEnumeratedLiteralSeq& _literal_seq)
{
    m_literal_seq = _literal_seq;
}

/*!
 * @brief This function moves the value in member literal_seq
 * @param _literal_seq New value to be moved in member literal_seq
 */
void eprosima::fastrtps::types::CompleteEnumeratedType::literal_seq(
        eprosima::fastrtps::types::CompleteEnumeratedLiteralSeq&& _literal_seq)
{
    m_literal_seq = std::move(_literal_seq);
}

/*!
 * @brief This function returns a constant reference to member literal_seq
 * @return Constant reference to member literal_seq
 */
const eprosima::fastrtps::types::CompleteEnumeratedLiteralSeq& eprosima::fastrtps::types::CompleteEnumeratedType::literal_seq() const
{
    return m_literal_seq;
}

/*!
 * @brief This function returns a reference to member literal_seq
 * @return Reference to member literal_seq
 */
eprosima::fastrtps::types::CompleteEnumeratedLiteralSeq& eprosima::fastrtps::types::CompleteEnumeratedType::literal_seq()
{
    return m_literal_seq;
}


size_t eprosima::fastrtps::types::CompleteEnumeratedType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteEnumeratedType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteEnumeratedType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteEnumeratedType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalEnumeratedType::MinimalEnumeratedType()
{
    // eprosima::fastrtps::types::EnumTypeFlag m_enum_flags
    m_enum_flags = static_cast<eprosima::fastrtps::types::EnumTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalEnumeratedHeader m_header

    // eprosima::fastrtps::types::MinimalEnumeratedLiteralSeq m_literal_seq


}

eprosima::fastrtps::types::MinimalEnumeratedType::~MinimalEnumeratedType()
{



}

eprosima::fastrtps::types::MinimalEnumeratedType::MinimalEnumeratedType(
        const MinimalEnumeratedType& x)
{
    m_enum_flags = x.m_enum_flags;
    m_header = x.m_header;
    m_literal_seq = x.m_literal_seq;
}

eprosima::fastrtps::types::MinimalEnumeratedType::MinimalEnumeratedType(
        MinimalEnumeratedType&& x) noexcept 
{
    m_enum_flags = x.m_enum_flags;
    m_header = std::move(x.m_header);
    m_literal_seq = std::move(x.m_literal_seq);
}

eprosima::fastrtps::types::MinimalEnumeratedType& eprosima::fastrtps::types::MinimalEnumeratedType::operator =(
        const MinimalEnumeratedType& x)
{

    m_enum_flags = x.m_enum_flags;
    m_header = x.m_header;
    m_literal_seq = x.m_literal_seq;

    return *this;
}

eprosima::fastrtps::types::MinimalEnumeratedType& eprosima::fastrtps::types::MinimalEnumeratedType::operator =(
        MinimalEnumeratedType&& x) noexcept
{

    m_enum_flags = x.m_enum_flags;
    m_header = std::move(x.m_header);
    m_literal_seq = std::move(x.m_literal_seq);

    return *this;
}

bool eprosima::fastrtps::types::MinimalEnumeratedType::operator ==(
        const MinimalEnumeratedType& x) const
{

    return (m_enum_flags == x.m_enum_flags && m_header == x.m_header && m_literal_seq == x.m_literal_seq);
}

bool eprosima::fastrtps::types::MinimalEnumeratedType::operator !=(
        const MinimalEnumeratedType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalEnumeratedType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalEnumeratedType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalEnumeratedType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalEnumeratedType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalEnumeratedHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.literal_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::MinimalEnumeratedLiteral::getCdrSerializedSize(data.literal_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalEnumeratedType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_enum_flags;scdr << m_header;scdr << m_literal_seq;

}

void eprosima::fastrtps::types::MinimalEnumeratedType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_enum_flags = (eprosima::fastrtps::types::EnumTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_literal_seq;
}

/*!
 * @brief This function sets a value in member enum_flags
 * @param _enum_flags New value for member enum_flags
 */
void eprosima::fastrtps::types::MinimalEnumeratedType::enum_flags(
        eprosima::fastrtps::types::EnumTypeFlag _enum_flags)
{
    m_enum_flags = _enum_flags;
}

/*!
 * @brief This function returns the value of member enum_flags
 * @return Value of member enum_flags
 */
eprosima::fastrtps::types::EnumTypeFlag eprosima::fastrtps::types::MinimalEnumeratedType::enum_flags() const
{
    return m_enum_flags;
}

/*!
 * @brief This function returns a reference to member enum_flags
 * @return Reference to member enum_flags
 */
eprosima::fastrtps::types::EnumTypeFlag& eprosima::fastrtps::types::MinimalEnumeratedType::enum_flags()
{
    return m_enum_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalEnumeratedType::header(
        const eprosima::fastrtps::types::MinimalEnumeratedHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalEnumeratedType::header(
        eprosima::fastrtps::types::MinimalEnumeratedHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalEnumeratedHeader& eprosima::fastrtps::types::MinimalEnumeratedType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalEnumeratedHeader& eprosima::fastrtps::types::MinimalEnumeratedType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member literal_seq
 * @param _literal_seq New value to be copied in member literal_seq
 */
void eprosima::fastrtps::types::MinimalEnumeratedType::literal_seq(
        const eprosima::fastrtps::types::MinimalEnumeratedLiteralSeq& _literal_seq)
{
    m_literal_seq = _literal_seq;
}

/*!
 * @brief This function moves the value in member literal_seq
 * @param _literal_seq New value to be moved in member literal_seq
 */
void eprosima::fastrtps::types::MinimalEnumeratedType::literal_seq(
        eprosima::fastrtps::types::MinimalEnumeratedLiteralSeq&& _literal_seq)
{
    m_literal_seq = std::move(_literal_seq);
}

/*!
 * @brief This function returns a constant reference to member literal_seq
 * @return Constant reference to member literal_seq
 */
const eprosima::fastrtps::types::MinimalEnumeratedLiteralSeq& eprosima::fastrtps::types::MinimalEnumeratedType::literal_seq() const
{
    return m_literal_seq;
}

/*!
 * @brief This function returns a reference to member literal_seq
 * @return Reference to member literal_seq
 */
eprosima::fastrtps::types::MinimalEnumeratedLiteralSeq& eprosima::fastrtps::types::MinimalEnumeratedType::literal_seq()
{
    return m_literal_seq;
}


size_t eprosima::fastrtps::types::MinimalEnumeratedType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalEnumeratedType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalEnumeratedType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalEnumeratedType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonBitflag::CommonBitflag()
{
    // unsigned short m_position
    m_position = 0;
    // eprosima::fastrtps::types::BitflagFlag m_flags
    m_flags = static_cast<eprosima::fastrtps::types::BitflagFlag>(0);

}

eprosima::fastrtps::types::CommonBitflag::~CommonBitflag()
{


}

eprosima::fastrtps::types::CommonBitflag::CommonBitflag(
        const CommonBitflag& x)
{
    m_position = x.m_position;
    m_flags = x.m_flags;
}

eprosima::fastrtps::types::CommonBitflag::CommonBitflag(
        CommonBitflag&& x) noexcept 
{
    m_position = x.m_position;
    m_flags = x.m_flags;
}

eprosima::fastrtps::types::CommonBitflag& eprosima::fastrtps::types::CommonBitflag::operator =(
        const CommonBitflag& x)
{

    m_position = x.m_position;
    m_flags = x.m_flags;

    return *this;
}

eprosima::fastrtps::types::CommonBitflag& eprosima::fastrtps::types::CommonBitflag::operator =(
        CommonBitflag&& x) noexcept
{

    m_position = x.m_position;
    m_flags = x.m_flags;

    return *this;
}

bool eprosima::fastrtps::types::CommonBitflag::operator ==(
        const CommonBitflag& x) const
{

    return (m_position == x.m_position && m_flags == x.m_flags);
}

bool eprosima::fastrtps::types::CommonBitflag::operator !=(
        const CommonBitflag& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonBitflag::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonBitflag_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonBitflag::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonBitflag& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonBitflag::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_position;scdr << (uint16_t)m_flags;
}

void eprosima::fastrtps::types::CommonBitflag::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_position;
    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_flags = (eprosima::fastrtps::types::BitflagFlag)bitmask_value;
    }


}

/*!
 * @brief This function sets a value in member position
 * @param _position New value for member position
 */
void eprosima::fastrtps::types::CommonBitflag::position(
        uint16_t _position)
{
    m_position = _position;
}

/*!
 * @brief This function returns the value of member position
 * @return Value of member position
 */
uint16_t eprosima::fastrtps::types::CommonBitflag::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
uint16_t& eprosima::fastrtps::types::CommonBitflag::position()
{
    return m_position;
}

/*!
 * @brief This function sets a value in member flags
 * @param _flags New value for member flags
 */
void eprosima::fastrtps::types::CommonBitflag::flags(
        eprosima::fastrtps::types::BitflagFlag _flags)
{
    m_flags = _flags;
}

/*!
 * @brief This function returns the value of member flags
 * @return Value of member flags
 */
eprosima::fastrtps::types::BitflagFlag eprosima::fastrtps::types::CommonBitflag::flags() const
{
    return m_flags;
}

/*!
 * @brief This function returns a reference to member flags
 * @return Reference to member flags
 */
eprosima::fastrtps::types::BitflagFlag& eprosima::fastrtps::types::CommonBitflag::flags()
{
    return m_flags;
}



size_t eprosima::fastrtps::types::CommonBitflag::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonBitflag_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonBitflag::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonBitflag::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteBitflag::CompleteBitflag()
{
    // eprosima::fastrtps::types::CommonBitflag m_common

    // eprosima::fastrtps::types::CompleteMemberDetail m_detail


}

eprosima::fastrtps::types::CompleteBitflag::~CompleteBitflag()
{


}

eprosima::fastrtps::types::CompleteBitflag::CompleteBitflag(
        const CompleteBitflag& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteBitflag::CompleteBitflag(
        CompleteBitflag&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteBitflag& eprosima::fastrtps::types::CompleteBitflag::operator =(
        const CompleteBitflag& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteBitflag& eprosima::fastrtps::types::CompleteBitflag::operator =(
        CompleteBitflag&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteBitflag::operator ==(
        const CompleteBitflag& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteBitflag::operator !=(
        const CompleteBitflag& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteBitflag::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitflag_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteBitflag::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteBitflag& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonBitflag::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteBitflag::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteBitflag::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteBitflag::common(
        const eprosima::fastrtps::types::CommonBitflag& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteBitflag::common(
        eprosima::fastrtps::types::CommonBitflag&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonBitflag& eprosima::fastrtps::types::CompleteBitflag::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonBitflag& eprosima::fastrtps::types::CompleteBitflag::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteBitflag::detail(
        const eprosima::fastrtps::types::CompleteMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteBitflag::detail(
        eprosima::fastrtps::types::CompleteMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteBitflag::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteBitflag::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteBitflag::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitflag_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteBitflag::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteBitflag::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::MinimalBitflag::MinimalBitflag()
{
    // eprosima::fastrtps::types::CommonBitflag m_common

    // eprosima::fastrtps::types::MinimalMemberDetail m_detail


}

eprosima::fastrtps::types::MinimalBitflag::~MinimalBitflag()
{


}

eprosima::fastrtps::types::MinimalBitflag::MinimalBitflag(
        const MinimalBitflag& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::MinimalBitflag::MinimalBitflag(
        MinimalBitflag&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::MinimalBitflag& eprosima::fastrtps::types::MinimalBitflag::operator =(
        const MinimalBitflag& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::MinimalBitflag& eprosima::fastrtps::types::MinimalBitflag::operator =(
        MinimalBitflag&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::MinimalBitflag::operator ==(
        const MinimalBitflag& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::MinimalBitflag::operator !=(
        const MinimalBitflag& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalBitflag::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitflag_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalBitflag::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalBitflag& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonBitflag::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::MinimalMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalBitflag::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::MinimalBitflag::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalBitflag::common(
        const eprosima::fastrtps::types::CommonBitflag& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalBitflag::common(
        eprosima::fastrtps::types::CommonBitflag&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonBitflag& eprosima::fastrtps::types::MinimalBitflag::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonBitflag& eprosima::fastrtps::types::MinimalBitflag::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::MinimalBitflag::detail(
        const eprosima::fastrtps::types::MinimalMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::MinimalBitflag::detail(
        eprosima::fastrtps::types::MinimalMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalBitflag::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::MinimalMemberDetail& eprosima::fastrtps::types::MinimalBitflag::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::MinimalBitflag::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitflag_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalBitflag::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalBitflag::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CommonBitmaskHeader::CommonBitmaskHeader()
{
    // eprosima::fastrtps::types::BitBound m_bit_bound
    m_bit_bound = 0;

}

eprosima::fastrtps::types::CommonBitmaskHeader::~CommonBitmaskHeader()
{
}

eprosima::fastrtps::types::CommonBitmaskHeader::CommonBitmaskHeader(
        const CommonBitmaskHeader& x)
{
    m_bit_bound = x.m_bit_bound;
}

eprosima::fastrtps::types::CommonBitmaskHeader::CommonBitmaskHeader(
        CommonBitmaskHeader&& x) noexcept 
{
    m_bit_bound = x.m_bit_bound;
}

eprosima::fastrtps::types::CommonBitmaskHeader& eprosima::fastrtps::types::CommonBitmaskHeader::operator =(
        const CommonBitmaskHeader& x)
{

    m_bit_bound = x.m_bit_bound;

    return *this;
}

eprosima::fastrtps::types::CommonBitmaskHeader& eprosima::fastrtps::types::CommonBitmaskHeader::operator =(
        CommonBitmaskHeader&& x) noexcept
{

    m_bit_bound = x.m_bit_bound;

    return *this;
}

bool eprosima::fastrtps::types::CommonBitmaskHeader::operator ==(
        const CommonBitmaskHeader& x) const
{

    return (m_bit_bound == x.m_bit_bound);
}

bool eprosima::fastrtps::types::CommonBitmaskHeader::operator !=(
        const CommonBitmaskHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonBitmaskHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonBitmaskHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonBitmaskHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonBitmaskHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonBitmaskHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bit_bound;
}

void eprosima::fastrtps::types::CommonBitmaskHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bit_bound;
}

/*!
 * @brief This function sets a value in member bit_bound
 * @param _bit_bound New value for member bit_bound
 */
void eprosima::fastrtps::types::CommonBitmaskHeader::bit_bound(
        eprosima::fastrtps::types::BitBound _bit_bound)
{
    m_bit_bound = _bit_bound;
}

/*!
 * @brief This function returns the value of member bit_bound
 * @return Value of member bit_bound
 */
eprosima::fastrtps::types::BitBound eprosima::fastrtps::types::CommonBitmaskHeader::bit_bound() const
{
    return m_bit_bound;
}

/*!
 * @brief This function returns a reference to member bit_bound
 * @return Reference to member bit_bound
 */
eprosima::fastrtps::types::BitBound& eprosima::fastrtps::types::CommonBitmaskHeader::bit_bound()
{
    return m_bit_bound;
}



size_t eprosima::fastrtps::types::CommonBitmaskHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonBitmaskHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonBitmaskHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonBitmaskHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}




eprosima::fastrtps::types::CompleteBitmaskType::CompleteBitmaskType()
{
    // eprosima::fastrtps::types::BitmaskTypeFlag m_bitmask_flags
    m_bitmask_flags = static_cast<eprosima::fastrtps::types::BitmaskTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteBitmaskHeader m_header

    // eprosima::fastrtps::types::CompleteBitflagSeq m_flag_seq


}

eprosima::fastrtps::types::CompleteBitmaskType::~CompleteBitmaskType()
{



}

eprosima::fastrtps::types::CompleteBitmaskType::CompleteBitmaskType(
        const CompleteBitmaskType& x)
{
    m_bitmask_flags = x.m_bitmask_flags;
    m_header = x.m_header;
    m_flag_seq = x.m_flag_seq;
}

eprosima::fastrtps::types::CompleteBitmaskType::CompleteBitmaskType(
        CompleteBitmaskType&& x) noexcept 
{
    m_bitmask_flags = x.m_bitmask_flags;
    m_header = std::move(x.m_header);
    m_flag_seq = std::move(x.m_flag_seq);
}

eprosima::fastrtps::types::CompleteBitmaskType& eprosima::fastrtps::types::CompleteBitmaskType::operator =(
        const CompleteBitmaskType& x)
{

    m_bitmask_flags = x.m_bitmask_flags;
    m_header = x.m_header;
    m_flag_seq = x.m_flag_seq;

    return *this;
}

eprosima::fastrtps::types::CompleteBitmaskType& eprosima::fastrtps::types::CompleteBitmaskType::operator =(
        CompleteBitmaskType&& x) noexcept
{

    m_bitmask_flags = x.m_bitmask_flags;
    m_header = std::move(x.m_header);
    m_flag_seq = std::move(x.m_flag_seq);

    return *this;
}

bool eprosima::fastrtps::types::CompleteBitmaskType::operator ==(
        const CompleteBitmaskType& x) const
{

    return (m_bitmask_flags == x.m_bitmask_flags && m_header == x.m_header && m_flag_seq == x.m_flag_seq);
}

bool eprosima::fastrtps::types::CompleteBitmaskType::operator !=(
        const CompleteBitmaskType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteBitmaskType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitmaskType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteBitmaskType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteBitmaskType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteBitmaskHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.flag_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::CompleteBitflag::getCdrSerializedSize(data.flag_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteBitmaskType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_bitmask_flags;scdr << m_header;scdr << m_flag_seq;

}

void eprosima::fastrtps::types::CompleteBitmaskType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_bitmask_flags = (eprosima::fastrtps::types::BitmaskTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_flag_seq;
}

/*!
 * @brief This function sets a value in member bitmask_flags
 * @param _bitmask_flags New value for member bitmask_flags
 */
void eprosima::fastrtps::types::CompleteBitmaskType::bitmask_flags(
        eprosima::fastrtps::types::BitmaskTypeFlag _bitmask_flags)
{
    m_bitmask_flags = _bitmask_flags;
}

/*!
 * @brief This function returns the value of member bitmask_flags
 * @return Value of member bitmask_flags
 */
eprosima::fastrtps::types::BitmaskTypeFlag eprosima::fastrtps::types::CompleteBitmaskType::bitmask_flags() const
{
    return m_bitmask_flags;
}

/*!
 * @brief This function returns a reference to member bitmask_flags
 * @return Reference to member bitmask_flags
 */
eprosima::fastrtps::types::BitmaskTypeFlag& eprosima::fastrtps::types::CompleteBitmaskType::bitmask_flags()
{
    return m_bitmask_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteBitmaskType::header(
        const eprosima::fastrtps::types::CompleteBitmaskHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteBitmaskType::header(
        eprosima::fastrtps::types::CompleteBitmaskHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteBitmaskHeader& eprosima::fastrtps::types::CompleteBitmaskType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteBitmaskHeader& eprosima::fastrtps::types::CompleteBitmaskType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member flag_seq
 * @param _flag_seq New value to be copied in member flag_seq
 */
void eprosima::fastrtps::types::CompleteBitmaskType::flag_seq(
        const eprosima::fastrtps::types::CompleteBitflagSeq& _flag_seq)
{
    m_flag_seq = _flag_seq;
}

/*!
 * @brief This function moves the value in member flag_seq
 * @param _flag_seq New value to be moved in member flag_seq
 */
void eprosima::fastrtps::types::CompleteBitmaskType::flag_seq(
        eprosima::fastrtps::types::CompleteBitflagSeq&& _flag_seq)
{
    m_flag_seq = std::move(_flag_seq);
}

/*!
 * @brief This function returns a constant reference to member flag_seq
 * @return Constant reference to member flag_seq
 */
const eprosima::fastrtps::types::CompleteBitflagSeq& eprosima::fastrtps::types::CompleteBitmaskType::flag_seq() const
{
    return m_flag_seq;
}

/*!
 * @brief This function returns a reference to member flag_seq
 * @return Reference to member flag_seq
 */
eprosima::fastrtps::types::CompleteBitflagSeq& eprosima::fastrtps::types::CompleteBitmaskType::flag_seq()
{
    return m_flag_seq;
}


size_t eprosima::fastrtps::types::CompleteBitmaskType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitmaskType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteBitmaskType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteBitmaskType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalBitmaskType::MinimalBitmaskType()
{
    // eprosima::fastrtps::types::BitmaskTypeFlag m_bitmask_flags
    m_bitmask_flags = static_cast<eprosima::fastrtps::types::BitmaskTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalBitmaskHeader m_header

    // eprosima::fastrtps::types::MinimalBitflagSeq m_flag_seq


}

eprosima::fastrtps::types::MinimalBitmaskType::~MinimalBitmaskType()
{



}

eprosima::fastrtps::types::MinimalBitmaskType::MinimalBitmaskType(
        const MinimalBitmaskType& x)
{
    m_bitmask_flags = x.m_bitmask_flags;
    m_header = x.m_header;
    m_flag_seq = x.m_flag_seq;
}

eprosima::fastrtps::types::MinimalBitmaskType::MinimalBitmaskType(
        MinimalBitmaskType&& x) noexcept 
{
    m_bitmask_flags = x.m_bitmask_flags;
    m_header = std::move(x.m_header);
    m_flag_seq = std::move(x.m_flag_seq);
}

eprosima::fastrtps::types::MinimalBitmaskType& eprosima::fastrtps::types::MinimalBitmaskType::operator =(
        const MinimalBitmaskType& x)
{

    m_bitmask_flags = x.m_bitmask_flags;
    m_header = x.m_header;
    m_flag_seq = x.m_flag_seq;

    return *this;
}

eprosima::fastrtps::types::MinimalBitmaskType& eprosima::fastrtps::types::MinimalBitmaskType::operator =(
        MinimalBitmaskType&& x) noexcept
{

    m_bitmask_flags = x.m_bitmask_flags;
    m_header = std::move(x.m_header);
    m_flag_seq = std::move(x.m_flag_seq);

    return *this;
}

bool eprosima::fastrtps::types::MinimalBitmaskType::operator ==(
        const MinimalBitmaskType& x) const
{

    return (m_bitmask_flags == x.m_bitmask_flags && m_header == x.m_header && m_flag_seq == x.m_flag_seq);
}

bool eprosima::fastrtps::types::MinimalBitmaskType::operator !=(
        const MinimalBitmaskType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalBitmaskType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitmaskType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalBitmaskType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalBitmaskType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalBitmaskHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.flag_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::MinimalBitflag::getCdrSerializedSize(data.flag_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalBitmaskType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_bitmask_flags;scdr << m_header;scdr << m_flag_seq;

}

void eprosima::fastrtps::types::MinimalBitmaskType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_bitmask_flags = (eprosima::fastrtps::types::BitmaskTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_flag_seq;
}

/*!
 * @brief This function sets a value in member bitmask_flags
 * @param _bitmask_flags New value for member bitmask_flags
 */
void eprosima::fastrtps::types::MinimalBitmaskType::bitmask_flags(
        eprosima::fastrtps::types::BitmaskTypeFlag _bitmask_flags)
{
    m_bitmask_flags = _bitmask_flags;
}

/*!
 * @brief This function returns the value of member bitmask_flags
 * @return Value of member bitmask_flags
 */
eprosima::fastrtps::types::BitmaskTypeFlag eprosima::fastrtps::types::MinimalBitmaskType::bitmask_flags() const
{
    return m_bitmask_flags;
}

/*!
 * @brief This function returns a reference to member bitmask_flags
 * @return Reference to member bitmask_flags
 */
eprosima::fastrtps::types::BitmaskTypeFlag& eprosima::fastrtps::types::MinimalBitmaskType::bitmask_flags()
{
    return m_bitmask_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalBitmaskType::header(
        const eprosima::fastrtps::types::MinimalBitmaskHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalBitmaskType::header(
        eprosima::fastrtps::types::MinimalBitmaskHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalBitmaskHeader& eprosima::fastrtps::types::MinimalBitmaskType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalBitmaskHeader& eprosima::fastrtps::types::MinimalBitmaskType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member flag_seq
 * @param _flag_seq New value to be copied in member flag_seq
 */
void eprosima::fastrtps::types::MinimalBitmaskType::flag_seq(
        const eprosima::fastrtps::types::MinimalBitflagSeq& _flag_seq)
{
    m_flag_seq = _flag_seq;
}

/*!
 * @brief This function moves the value in member flag_seq
 * @param _flag_seq New value to be moved in member flag_seq
 */
void eprosima::fastrtps::types::MinimalBitmaskType::flag_seq(
        eprosima::fastrtps::types::MinimalBitflagSeq&& _flag_seq)
{
    m_flag_seq = std::move(_flag_seq);
}

/*!
 * @brief This function returns a constant reference to member flag_seq
 * @return Constant reference to member flag_seq
 */
const eprosima::fastrtps::types::MinimalBitflagSeq& eprosima::fastrtps::types::MinimalBitmaskType::flag_seq() const
{
    return m_flag_seq;
}

/*!
 * @brief This function returns a reference to member flag_seq
 * @return Reference to member flag_seq
 */
eprosima::fastrtps::types::MinimalBitflagSeq& eprosima::fastrtps::types::MinimalBitmaskType::flag_seq()
{
    return m_flag_seq;
}


size_t eprosima::fastrtps::types::MinimalBitmaskType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitmaskType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalBitmaskType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalBitmaskType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CommonBitfield::CommonBitfield()
{
    // unsigned short m_position
    m_position = 0;
    // eprosima::fastrtps::types::BitsetMemberFlag m_flags
    m_flags = static_cast<eprosima::fastrtps::types::BitsetMemberFlag>(0);
    // octet m_bitcount
    m_bitcount = 0;
    // eprosima::fastrtps::types::TypeKind m_holder_type
    m_holder_type = 0;

}

eprosima::fastrtps::types::CommonBitfield::~CommonBitfield()
{




}

eprosima::fastrtps::types::CommonBitfield::CommonBitfield(
        const CommonBitfield& x)
{
    m_position = x.m_position;
    m_flags = x.m_flags;
    m_bitcount = x.m_bitcount;
    m_holder_type = x.m_holder_type;
}

eprosima::fastrtps::types::CommonBitfield::CommonBitfield(
        CommonBitfield&& x) noexcept 
{
    m_position = x.m_position;
    m_flags = x.m_flags;
    m_bitcount = x.m_bitcount;
    m_holder_type = x.m_holder_type;
}

eprosima::fastrtps::types::CommonBitfield& eprosima::fastrtps::types::CommonBitfield::operator =(
        const CommonBitfield& x)
{

    m_position = x.m_position;
    m_flags = x.m_flags;
    m_bitcount = x.m_bitcount;
    m_holder_type = x.m_holder_type;

    return *this;
}

eprosima::fastrtps::types::CommonBitfield& eprosima::fastrtps::types::CommonBitfield::operator =(
        CommonBitfield&& x) noexcept
{

    m_position = x.m_position;
    m_flags = x.m_flags;
    m_bitcount = x.m_bitcount;
    m_holder_type = x.m_holder_type;

    return *this;
}

bool eprosima::fastrtps::types::CommonBitfield::operator ==(
        const CommonBitfield& x) const
{

    return (m_position == x.m_position && m_flags == x.m_flags && m_bitcount == x.m_bitcount && m_holder_type == x.m_holder_type);
}

bool eprosima::fastrtps::types::CommonBitfield::operator !=(
        const CommonBitfield& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CommonBitfield::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonBitfield_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CommonBitfield::getCdrSerializedSize(
        const eprosima::fastrtps::types::CommonBitfield& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CommonBitfield::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_position;scdr << (uint16_t)m_flags;scdr << m_bitcount;scdr << m_holder_type;
}

void eprosima::fastrtps::types::CommonBitfield::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_position;
    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_flags = (eprosima::fastrtps::types::BitsetMemberFlag)bitmask_value;
    }


    dcdr >> m_bitcount;
    dcdr >> m_holder_type;
}

/*!
 * @brief This function sets a value in member position
 * @param _position New value for member position
 */
void eprosima::fastrtps::types::CommonBitfield::position(
        uint16_t _position)
{
    m_position = _position;
}

/*!
 * @brief This function returns the value of member position
 * @return Value of member position
 */
uint16_t eprosima::fastrtps::types::CommonBitfield::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
uint16_t& eprosima::fastrtps::types::CommonBitfield::position()
{
    return m_position;
}

/*!
 * @brief This function sets a value in member flags
 * @param _flags New value for member flags
 */
void eprosima::fastrtps::types::CommonBitfield::flags(
        eprosima::fastrtps::types::BitsetMemberFlag _flags)
{
    m_flags = _flags;
}

/*!
 * @brief This function returns the value of member flags
 * @return Value of member flags
 */
eprosima::fastrtps::types::BitsetMemberFlag eprosima::fastrtps::types::CommonBitfield::flags() const
{
    return m_flags;
}

/*!
 * @brief This function returns a reference to member flags
 * @return Reference to member flags
 */
eprosima::fastrtps::types::BitsetMemberFlag& eprosima::fastrtps::types::CommonBitfield::flags()
{
    return m_flags;
}

/*!
 * @brief This function sets a value in member bitcount
 * @param _bitcount New value for member bitcount
 */
void eprosima::fastrtps::types::CommonBitfield::bitcount(
        uint8_t _bitcount)
{
    m_bitcount = _bitcount;
}

/*!
 * @brief This function returns the value of member bitcount
 * @return Value of member bitcount
 */
uint8_t eprosima::fastrtps::types::CommonBitfield::bitcount() const
{
    return m_bitcount;
}

/*!
 * @brief This function returns a reference to member bitcount
 * @return Reference to member bitcount
 */
uint8_t& eprosima::fastrtps::types::CommonBitfield::bitcount()
{
    return m_bitcount;
}

/*!
 * @brief This function sets a value in member holder_type
 * @param _holder_type New value for member holder_type
 */
void eprosima::fastrtps::types::CommonBitfield::holder_type(
        eprosima::fastrtps::types::TypeKind _holder_type)
{
    m_holder_type = _holder_type;
}

/*!
 * @brief This function returns the value of member holder_type
 * @return Value of member holder_type
 */
eprosima::fastrtps::types::TypeKind eprosima::fastrtps::types::CommonBitfield::holder_type() const
{
    return m_holder_type;
}

/*!
 * @brief This function returns a reference to member holder_type
 * @return Reference to member holder_type
 */
eprosima::fastrtps::types::TypeKind& eprosima::fastrtps::types::CommonBitfield::holder_type()
{
    return m_holder_type;
}



size_t eprosima::fastrtps::types::CommonBitfield::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CommonBitfield_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CommonBitfield::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CommonBitfield::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteBitfield::CompleteBitfield()
{
    // eprosima::fastrtps::types::CommonBitfield m_common

    // eprosima::fastrtps::types::CompleteMemberDetail m_detail


}

eprosima::fastrtps::types::CompleteBitfield::~CompleteBitfield()
{


}

eprosima::fastrtps::types::CompleteBitfield::CompleteBitfield(
        const CompleteBitfield& x)
{
    m_common = x.m_common;
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteBitfield::CompleteBitfield(
        CompleteBitfield&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteBitfield& eprosima::fastrtps::types::CompleteBitfield::operator =(
        const CompleteBitfield& x)
{

    m_common = x.m_common;
    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteBitfield& eprosima::fastrtps::types::CompleteBitfield::operator =(
        CompleteBitfield&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteBitfield::operator ==(
        const CompleteBitfield& x) const
{

    return (m_common == x.m_common && m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteBitfield::operator !=(
        const CompleteBitfield& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteBitfield::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitfield_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteBitfield::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteBitfield& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonBitfield::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += eprosima::fastrtps::types::CompleteMemberDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteBitfield::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteBitfield::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::CompleteBitfield::common(
        const eprosima::fastrtps::types::CommonBitfield& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::CompleteBitfield::common(
        eprosima::fastrtps::types::CommonBitfield&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonBitfield& eprosima::fastrtps::types::CompleteBitfield::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonBitfield& eprosima::fastrtps::types::CompleteBitfield::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteBitfield::detail(
        const eprosima::fastrtps::types::CompleteMemberDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteBitfield::detail(
        eprosima::fastrtps::types::CompleteMemberDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteBitfield::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteMemberDetail& eprosima::fastrtps::types::CompleteBitfield::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteBitfield::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitfield_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteBitfield::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteBitfield::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::MinimalBitfield::MinimalBitfield()
{
    // eprosima::fastrtps::types::CommonBitfield m_common

    // eprosima::fastrtps::types::NameHash m_name_hash
    memset(&m_name_hash, 0, (4) * 1);

}

eprosima::fastrtps::types::MinimalBitfield::~MinimalBitfield()
{


}

eprosima::fastrtps::types::MinimalBitfield::MinimalBitfield(
        const MinimalBitfield& x)
{
    m_common = x.m_common;
    m_name_hash = x.m_name_hash;
}

eprosima::fastrtps::types::MinimalBitfield::MinimalBitfield(
        MinimalBitfield&& x) noexcept 
{
    m_common = std::move(x.m_common);
    m_name_hash = std::move(x.m_name_hash);
}

eprosima::fastrtps::types::MinimalBitfield& eprosima::fastrtps::types::MinimalBitfield::operator =(
        const MinimalBitfield& x)
{

    m_common = x.m_common;
    m_name_hash = x.m_name_hash;

    return *this;
}

eprosima::fastrtps::types::MinimalBitfield& eprosima::fastrtps::types::MinimalBitfield::operator =(
        MinimalBitfield&& x) noexcept
{

    m_common = std::move(x.m_common);
    m_name_hash = std::move(x.m_name_hash);

    return *this;
}

bool eprosima::fastrtps::types::MinimalBitfield::operator ==(
        const MinimalBitfield& x) const
{

    return (m_common == x.m_common && m_name_hash == x.m_name_hash);
}

bool eprosima::fastrtps::types::MinimalBitfield::operator !=(
        const MinimalBitfield& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalBitfield::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitfield_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalBitfield::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalBitfield& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CommonBitfield::getCdrSerializedSize(data.common(), current_alignment);
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalBitfield::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_common;scdr << m_name_hash;

}

void eprosima::fastrtps::types::MinimalBitfield::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_common;
    dcdr >> m_name_hash;

}

/*!
 * @brief This function copies the value in member common
 * @param _common New value to be copied in member common
 */
void eprosima::fastrtps::types::MinimalBitfield::common(
        const eprosima::fastrtps::types::CommonBitfield& _common)
{
    m_common = _common;
}

/*!
 * @brief This function moves the value in member common
 * @param _common New value to be moved in member common
 */
void eprosima::fastrtps::types::MinimalBitfield::common(
        eprosima::fastrtps::types::CommonBitfield&& _common)
{
    m_common = std::move(_common);
}

/*!
 * @brief This function returns a constant reference to member common
 * @return Constant reference to member common
 */
const eprosima::fastrtps::types::CommonBitfield& eprosima::fastrtps::types::MinimalBitfield::common() const
{
    return m_common;
}

/*!
 * @brief This function returns a reference to member common
 * @return Reference to member common
 */
eprosima::fastrtps::types::CommonBitfield& eprosima::fastrtps::types::MinimalBitfield::common()
{
    return m_common;
}
/*!
 * @brief This function copies the value in member name_hash
 * @param _name_hash New value to be copied in member name_hash
 */
void eprosima::fastrtps::types::MinimalBitfield::name_hash(
        const eprosima::fastrtps::types::NameHash& _name_hash)
{
    m_name_hash = _name_hash;
}

/*!
 * @brief This function moves the value in member name_hash
 * @param _name_hash New value to be moved in member name_hash
 */
void eprosima::fastrtps::types::MinimalBitfield::name_hash(
        eprosima::fastrtps::types::NameHash&& _name_hash)
{
    m_name_hash = std::move(_name_hash);
}

/*!
 * @brief This function returns a constant reference to member name_hash
 * @return Constant reference to member name_hash
 */
const eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::MinimalBitfield::name_hash() const
{
    return m_name_hash;
}

/*!
 * @brief This function returns a reference to member name_hash
 * @return Reference to member name_hash
 */
eprosima::fastrtps::types::NameHash& eprosima::fastrtps::types::MinimalBitfield::name_hash()
{
    return m_name_hash;
}


size_t eprosima::fastrtps::types::MinimalBitfield::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitfield_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalBitfield::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalBitfield::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::CompleteBitsetHeader::CompleteBitsetHeader()
{
    // eprosima::fastrtps::types::CompleteTypeDetail m_detail


}

eprosima::fastrtps::types::CompleteBitsetHeader::~CompleteBitsetHeader()
{
}

eprosima::fastrtps::types::CompleteBitsetHeader::CompleteBitsetHeader(
        const CompleteBitsetHeader& x)
{
    m_detail = x.m_detail;
}

eprosima::fastrtps::types::CompleteBitsetHeader::CompleteBitsetHeader(
        CompleteBitsetHeader&& x) noexcept 
{
    m_detail = std::move(x.m_detail);
}

eprosima::fastrtps::types::CompleteBitsetHeader& eprosima::fastrtps::types::CompleteBitsetHeader::operator =(
        const CompleteBitsetHeader& x)
{

    m_detail = x.m_detail;

    return *this;
}

eprosima::fastrtps::types::CompleteBitsetHeader& eprosima::fastrtps::types::CompleteBitsetHeader::operator =(
        CompleteBitsetHeader&& x) noexcept
{

    m_detail = std::move(x.m_detail);

    return *this;
}

bool eprosima::fastrtps::types::CompleteBitsetHeader::operator ==(
        const CompleteBitsetHeader& x) const
{

    return (m_detail == x.m_detail);
}

bool eprosima::fastrtps::types::CompleteBitsetHeader::operator !=(
        const CompleteBitsetHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteBitsetHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitsetHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteBitsetHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteBitsetHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::CompleteTypeDetail::getCdrSerializedSize(data.detail(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteBitsetHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_detail;
}

void eprosima::fastrtps::types::CompleteBitsetHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_detail;
}

/*!
 * @brief This function copies the value in member detail
 * @param _detail New value to be copied in member detail
 */
void eprosima::fastrtps::types::CompleteBitsetHeader::detail(
        const eprosima::fastrtps::types::CompleteTypeDetail& _detail)
{
    m_detail = _detail;
}

/*!
 * @brief This function moves the value in member detail
 * @param _detail New value to be moved in member detail
 */
void eprosima::fastrtps::types::CompleteBitsetHeader::detail(
        eprosima::fastrtps::types::CompleteTypeDetail&& _detail)
{
    m_detail = std::move(_detail);
}

/*!
 * @brief This function returns a constant reference to member detail
 * @return Constant reference to member detail
 */
const eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteBitsetHeader::detail() const
{
    return m_detail;
}

/*!
 * @brief This function returns a reference to member detail
 * @return Reference to member detail
 */
eprosima::fastrtps::types::CompleteTypeDetail& eprosima::fastrtps::types::CompleteBitsetHeader::detail()
{
    return m_detail;
}


size_t eprosima::fastrtps::types::CompleteBitsetHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitsetHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteBitsetHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteBitsetHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalBitsetHeader::MinimalBitsetHeader()
{

}

eprosima::fastrtps::types::MinimalBitsetHeader::~MinimalBitsetHeader()
{
}

eprosima::fastrtps::types::MinimalBitsetHeader::MinimalBitsetHeader(
        const MinimalBitsetHeader& /*x*/)
{
}

eprosima::fastrtps::types::MinimalBitsetHeader::MinimalBitsetHeader(
        MinimalBitsetHeader&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::MinimalBitsetHeader& eprosima::fastrtps::types::MinimalBitsetHeader::operator =(
        const MinimalBitsetHeader& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::MinimalBitsetHeader& eprosima::fastrtps::types::MinimalBitsetHeader::operator =(
        MinimalBitsetHeader&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::MinimalBitsetHeader::operator ==(
        const MinimalBitsetHeader& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::MinimalBitsetHeader::operator !=(
        const MinimalBitsetHeader& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalBitsetHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitsetHeader_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalBitsetHeader::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalBitsetHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalBitsetHeader::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::MinimalBitsetHeader::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::MinimalBitsetHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitsetHeader_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalBitsetHeader::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalBitsetHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteBitsetType::CompleteBitsetType()
{
    // eprosima::fastrtps::types::BitsetTypeFlag m_bitset_flags
    m_bitset_flags = static_cast<eprosima::fastrtps::types::BitsetTypeFlag>(0);
    // eprosima::fastrtps::types::CompleteBitsetHeader m_header

    // eprosima::fastrtps::types::CompleteBitfieldSeq m_field_seq


}

eprosima::fastrtps::types::CompleteBitsetType::~CompleteBitsetType()
{



}

eprosima::fastrtps::types::CompleteBitsetType::CompleteBitsetType(
        const CompleteBitsetType& x)
{
    m_bitset_flags = x.m_bitset_flags;
    m_header = x.m_header;
    m_field_seq = x.m_field_seq;
}

eprosima::fastrtps::types::CompleteBitsetType::CompleteBitsetType(
        CompleteBitsetType&& x) noexcept 
{
    m_bitset_flags = x.m_bitset_flags;
    m_header = std::move(x.m_header);
    m_field_seq = std::move(x.m_field_seq);
}

eprosima::fastrtps::types::CompleteBitsetType& eprosima::fastrtps::types::CompleteBitsetType::operator =(
        const CompleteBitsetType& x)
{

    m_bitset_flags = x.m_bitset_flags;
    m_header = x.m_header;
    m_field_seq = x.m_field_seq;

    return *this;
}

eprosima::fastrtps::types::CompleteBitsetType& eprosima::fastrtps::types::CompleteBitsetType::operator =(
        CompleteBitsetType&& x) noexcept
{

    m_bitset_flags = x.m_bitset_flags;
    m_header = std::move(x.m_header);
    m_field_seq = std::move(x.m_field_seq);

    return *this;
}

bool eprosima::fastrtps::types::CompleteBitsetType::operator ==(
        const CompleteBitsetType& x) const
{

    return (m_bitset_flags == x.m_bitset_flags && m_header == x.m_header && m_field_seq == x.m_field_seq);
}

bool eprosima::fastrtps::types::CompleteBitsetType::operator !=(
        const CompleteBitsetType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteBitsetType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitsetType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteBitsetType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteBitsetType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::CompleteBitsetHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.field_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::CompleteBitfield::getCdrSerializedSize(data.field_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteBitsetType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_bitset_flags;scdr << m_header;scdr << m_field_seq;

}

void eprosima::fastrtps::types::CompleteBitsetType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_bitset_flags = (eprosima::fastrtps::types::BitsetTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_field_seq;
}

/*!
 * @brief This function sets a value in member bitset_flags
 * @param _bitset_flags New value for member bitset_flags
 */
void eprosima::fastrtps::types::CompleteBitsetType::bitset_flags(
        eprosima::fastrtps::types::BitsetTypeFlag _bitset_flags)
{
    m_bitset_flags = _bitset_flags;
}

/*!
 * @brief This function returns the value of member bitset_flags
 * @return Value of member bitset_flags
 */
eprosima::fastrtps::types::BitsetTypeFlag eprosima::fastrtps::types::CompleteBitsetType::bitset_flags() const
{
    return m_bitset_flags;
}

/*!
 * @brief This function returns a reference to member bitset_flags
 * @return Reference to member bitset_flags
 */
eprosima::fastrtps::types::BitsetTypeFlag& eprosima::fastrtps::types::CompleteBitsetType::bitset_flags()
{
    return m_bitset_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::CompleteBitsetType::header(
        const eprosima::fastrtps::types::CompleteBitsetHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::CompleteBitsetType::header(
        eprosima::fastrtps::types::CompleteBitsetHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::CompleteBitsetHeader& eprosima::fastrtps::types::CompleteBitsetType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::CompleteBitsetHeader& eprosima::fastrtps::types::CompleteBitsetType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member field_seq
 * @param _field_seq New value to be copied in member field_seq
 */
void eprosima::fastrtps::types::CompleteBitsetType::field_seq(
        const eprosima::fastrtps::types::CompleteBitfieldSeq& _field_seq)
{
    m_field_seq = _field_seq;
}

/*!
 * @brief This function moves the value in member field_seq
 * @param _field_seq New value to be moved in member field_seq
 */
void eprosima::fastrtps::types::CompleteBitsetType::field_seq(
        eprosima::fastrtps::types::CompleteBitfieldSeq&& _field_seq)
{
    m_field_seq = std::move(_field_seq);
}

/*!
 * @brief This function returns a constant reference to member field_seq
 * @return Constant reference to member field_seq
 */
const eprosima::fastrtps::types::CompleteBitfieldSeq& eprosima::fastrtps::types::CompleteBitsetType::field_seq() const
{
    return m_field_seq;
}

/*!
 * @brief This function returns a reference to member field_seq
 * @return Reference to member field_seq
 */
eprosima::fastrtps::types::CompleteBitfieldSeq& eprosima::fastrtps::types::CompleteBitsetType::field_seq()
{
    return m_field_seq;
}


size_t eprosima::fastrtps::types::CompleteBitsetType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteBitsetType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteBitsetType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteBitsetType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalBitsetType::MinimalBitsetType()
{
    // eprosima::fastrtps::types::BitsetTypeFlag m_bitset_flags
    m_bitset_flags = static_cast<eprosima::fastrtps::types::BitsetTypeFlag>(0);
    // eprosima::fastrtps::types::MinimalBitsetHeader m_header

    // eprosima::fastrtps::types::MinimalBitfieldSeq m_field_seq


}

eprosima::fastrtps::types::MinimalBitsetType::~MinimalBitsetType()
{



}

eprosima::fastrtps::types::MinimalBitsetType::MinimalBitsetType(
        const MinimalBitsetType& x)
{
    m_bitset_flags = x.m_bitset_flags;
    m_header = x.m_header;
    m_field_seq = x.m_field_seq;
}

eprosima::fastrtps::types::MinimalBitsetType::MinimalBitsetType(
        MinimalBitsetType&& x) noexcept 
{
    m_bitset_flags = x.m_bitset_flags;
    m_header = std::move(x.m_header);
    m_field_seq = std::move(x.m_field_seq);
}

eprosima::fastrtps::types::MinimalBitsetType& eprosima::fastrtps::types::MinimalBitsetType::operator =(
        const MinimalBitsetType& x)
{

    m_bitset_flags = x.m_bitset_flags;
    m_header = x.m_header;
    m_field_seq = x.m_field_seq;

    return *this;
}

eprosima::fastrtps::types::MinimalBitsetType& eprosima::fastrtps::types::MinimalBitsetType::operator =(
        MinimalBitsetType&& x) noexcept
{

    m_bitset_flags = x.m_bitset_flags;
    m_header = std::move(x.m_header);
    m_field_seq = std::move(x.m_field_seq);

    return *this;
}

bool eprosima::fastrtps::types::MinimalBitsetType::operator ==(
        const MinimalBitsetType& x) const
{

    return (m_bitset_flags == x.m_bitset_flags && m_header == x.m_header && m_field_seq == x.m_field_seq);
}

bool eprosima::fastrtps::types::MinimalBitsetType::operator !=(
        const MinimalBitsetType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalBitsetType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitsetType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalBitsetType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalBitsetType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += eprosima::fastrtps::types::MinimalBitsetHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.field_seq().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::MinimalBitfield::getCdrSerializedSize(data.field_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalBitsetType::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint16_t)m_bitset_flags;scdr << m_header;scdr << m_field_seq;

}

void eprosima::fastrtps::types::MinimalBitsetType::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint16_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_bitset_flags = (eprosima::fastrtps::types::BitsetTypeFlag)bitmask_value;
    }


    dcdr >> m_header;
    dcdr >> m_field_seq;
}

/*!
 * @brief This function sets a value in member bitset_flags
 * @param _bitset_flags New value for member bitset_flags
 */
void eprosima::fastrtps::types::MinimalBitsetType::bitset_flags(
        eprosima::fastrtps::types::BitsetTypeFlag _bitset_flags)
{
    m_bitset_flags = _bitset_flags;
}

/*!
 * @brief This function returns the value of member bitset_flags
 * @return Value of member bitset_flags
 */
eprosima::fastrtps::types::BitsetTypeFlag eprosima::fastrtps::types::MinimalBitsetType::bitset_flags() const
{
    return m_bitset_flags;
}

/*!
 * @brief This function returns a reference to member bitset_flags
 * @return Reference to member bitset_flags
 */
eprosima::fastrtps::types::BitsetTypeFlag& eprosima::fastrtps::types::MinimalBitsetType::bitset_flags()
{
    return m_bitset_flags;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void eprosima::fastrtps::types::MinimalBitsetType::header(
        const eprosima::fastrtps::types::MinimalBitsetHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void eprosima::fastrtps::types::MinimalBitsetType::header(
        eprosima::fastrtps::types::MinimalBitsetHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const eprosima::fastrtps::types::MinimalBitsetHeader& eprosima::fastrtps::types::MinimalBitsetType::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
eprosima::fastrtps::types::MinimalBitsetHeader& eprosima::fastrtps::types::MinimalBitsetType::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member field_seq
 * @param _field_seq New value to be copied in member field_seq
 */
void eprosima::fastrtps::types::MinimalBitsetType::field_seq(
        const eprosima::fastrtps::types::MinimalBitfieldSeq& _field_seq)
{
    m_field_seq = _field_seq;
}

/*!
 * @brief This function moves the value in member field_seq
 * @param _field_seq New value to be moved in member field_seq
 */
void eprosima::fastrtps::types::MinimalBitsetType::field_seq(
        eprosima::fastrtps::types::MinimalBitfieldSeq&& _field_seq)
{
    m_field_seq = std::move(_field_seq);
}

/*!
 * @brief This function returns a constant reference to member field_seq
 * @return Constant reference to member field_seq
 */
const eprosima::fastrtps::types::MinimalBitfieldSeq& eprosima::fastrtps::types::MinimalBitsetType::field_seq() const
{
    return m_field_seq;
}

/*!
 * @brief This function returns a reference to member field_seq
 * @return Reference to member field_seq
 */
eprosima::fastrtps::types::MinimalBitfieldSeq& eprosima::fastrtps::types::MinimalBitsetType::field_seq()
{
    return m_field_seq;
}


size_t eprosima::fastrtps::types::MinimalBitsetType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalBitsetType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalBitsetType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalBitsetType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteExtendedType::CompleteExtendedType()
{

}

eprosima::fastrtps::types::CompleteExtendedType::~CompleteExtendedType()
{
}

eprosima::fastrtps::types::CompleteExtendedType::CompleteExtendedType(
        const CompleteExtendedType& /*x*/)
{
}

eprosima::fastrtps::types::CompleteExtendedType::CompleteExtendedType(
        CompleteExtendedType&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::CompleteExtendedType& eprosima::fastrtps::types::CompleteExtendedType::operator =(
        const CompleteExtendedType& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::CompleteExtendedType& eprosima::fastrtps::types::CompleteExtendedType::operator =(
        CompleteExtendedType&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::CompleteExtendedType::operator ==(
        const CompleteExtendedType& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::CompleteExtendedType::operator !=(
        const CompleteExtendedType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::CompleteExtendedType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteExtendedType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::CompleteExtendedType::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteExtendedType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteExtendedType::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::CompleteExtendedType::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::CompleteExtendedType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_CompleteExtendedType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::CompleteExtendedType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::CompleteExtendedType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::CompleteTypeObject::CompleteTypeObject()
{
    m__d = 0;
    // eprosima::fastrtps::types::CompleteAliasType m_alias_type

    // eprosima::fastrtps::types::CompleteAnnotationType m_annotation_type

    // eprosima::fastrtps::types::CompleteStructType m_struct_type

    // eprosima::fastrtps::types::CompleteUnionType m_union_type

    // eprosima::fastrtps::types::CompleteBitsetType m_bitset_type

    // eprosima::fastrtps::types::CompleteSequenceType m_sequence_type

    // eprosima::fastrtps::types::CompleteArrayType m_array_type

    // eprosima::fastrtps::types::CompleteMapType m_map_type

    // eprosima::fastrtps::types::CompleteEnumeratedType m_enumerated_type

    // eprosima::fastrtps::types::CompleteBitmaskType m_bitmask_type

    // eprosima::fastrtps::types::CompleteExtendedType m_extended_type

}

eprosima::fastrtps::types::CompleteTypeObject::~CompleteTypeObject()
{
}

eprosima::fastrtps::types::CompleteTypeObject::CompleteTypeObject(
        const CompleteTypeObject& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = x.m_alias_type;
        break;
        case TK_ANNOTATION:
        m_annotation_type = x.m_annotation_type;
        break;
        case TK_STRUCTURE:
        m_struct_type = x.m_struct_type;
        break;
        case TK_UNION:
        m_union_type = x.m_union_type;
        break;
        case TK_BITSET:
        m_bitset_type = x.m_bitset_type;
        break;
        case TK_SEQUENCE:
        m_sequence_type = x.m_sequence_type;
        break;
        case TK_ARRAY:
        m_array_type = x.m_array_type;
        break;
        case TK_MAP:
        m_map_type = x.m_map_type;
        break;
        case TK_ENUM:
        m_enumerated_type = x.m_enumerated_type;
        break;
        case TK_BITMASK:
        m_bitmask_type = x.m_bitmask_type;
        break;

        default:
        m_extended_type = x.m_extended_type;
        break;
    }
}

eprosima::fastrtps::types::CompleteTypeObject::CompleteTypeObject(
        CompleteTypeObject&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = std::move(x.m_alias_type);
        break;
        case TK_ANNOTATION:
        m_annotation_type = std::move(x.m_annotation_type);
        break;
        case TK_STRUCTURE:
        m_struct_type = std::move(x.m_struct_type);
        break;
        case TK_UNION:
        m_union_type = std::move(x.m_union_type);
        break;
        case TK_BITSET:
        m_bitset_type = std::move(x.m_bitset_type);
        break;
        case TK_SEQUENCE:
        m_sequence_type = std::move(x.m_sequence_type);
        break;
        case TK_ARRAY:
        m_array_type = std::move(x.m_array_type);
        break;
        case TK_MAP:
        m_map_type = std::move(x.m_map_type);
        break;
        case TK_ENUM:
        m_enumerated_type = std::move(x.m_enumerated_type);
        break;
        case TK_BITMASK:
        m_bitmask_type = std::move(x.m_bitmask_type);
        break;

        default:
        m_extended_type = std::move(x.m_extended_type);
        break;
    }
}

eprosima::fastrtps::types::CompleteTypeObject& eprosima::fastrtps::types::CompleteTypeObject::operator =(
        const CompleteTypeObject& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = x.m_alias_type;
        break;
        case TK_ANNOTATION:
        m_annotation_type = x.m_annotation_type;
        break;
        case TK_STRUCTURE:
        m_struct_type = x.m_struct_type;
        break;
        case TK_UNION:
        m_union_type = x.m_union_type;
        break;
        case TK_BITSET:
        m_bitset_type = x.m_bitset_type;
        break;
        case TK_SEQUENCE:
        m_sequence_type = x.m_sequence_type;
        break;
        case TK_ARRAY:
        m_array_type = x.m_array_type;
        break;
        case TK_MAP:
        m_map_type = x.m_map_type;
        break;
        case TK_ENUM:
        m_enumerated_type = x.m_enumerated_type;
        break;
        case TK_BITMASK:
        m_bitmask_type = x.m_bitmask_type;
        break;

        default:
        m_extended_type = x.m_extended_type;
        break;
    }

    return *this;
}

eprosima::fastrtps::types::CompleteTypeObject& eprosima::fastrtps::types::CompleteTypeObject::operator =(
        CompleteTypeObject&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = std::move(x.m_alias_type);
        break;
        case TK_ANNOTATION:
        m_annotation_type = std::move(x.m_annotation_type);
        break;
        case TK_STRUCTURE:
        m_struct_type = std::move(x.m_struct_type);
        break;
        case TK_UNION:
        m_union_type = std::move(x.m_union_type);
        break;
        case TK_BITSET:
        m_bitset_type = std::move(x.m_bitset_type);
        break;
        case TK_SEQUENCE:
        m_sequence_type = std::move(x.m_sequence_type);
        break;
        case TK_ARRAY:
        m_array_type = std::move(x.m_array_type);
        break;
        case TK_MAP:
        m_map_type = std::move(x.m_map_type);
        break;
        case TK_ENUM:
        m_enumerated_type = std::move(x.m_enumerated_type);
        break;
        case TK_BITMASK:
        m_bitmask_type = std::move(x.m_bitmask_type);
        break;

        default:
        m_extended_type = std::move(x.m_extended_type);
        break;
    }

    return *this;
}

bool eprosima::fastrtps::types::CompleteTypeObject::operator ==(
        const CompleteTypeObject& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case TK_ALIAS:
            return (m_alias_type == x.m_alias_type);
            break;
        case TK_ANNOTATION:
            return (m_annotation_type == x.m_annotation_type);
            break;
        case TK_STRUCTURE:
            return (m_struct_type == x.m_struct_type);
            break;
        case TK_UNION:
            return (m_union_type == x.m_union_type);
            break;
        case TK_BITSET:
            return (m_bitset_type == x.m_bitset_type);
            break;
        case TK_SEQUENCE:
            return (m_sequence_type == x.m_sequence_type);
            break;
        case TK_ARRAY:
            return (m_array_type == x.m_array_type);
            break;
        case TK_MAP:
            return (m_map_type == x.m_map_type);
            break;
        case TK_ENUM:
            return (m_enumerated_type == x.m_enumerated_type);
            break;
        case TK_BITMASK:
            return (m_bitmask_type == x.m_bitmask_type);
            break;

        default:
        return m_extended_type == x.m_extended_type;
        break;
    }
    return false;
}

bool eprosima::fastrtps::types::CompleteTypeObject::operator !=(
        const CompleteTypeObject& x) const
{
    return !(*this == x);
}

void eprosima::fastrtps::types::CompleteTypeObject::_d(
        uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case TK_ALIAS:
        switch(__d)
        {
            case TK_ALIAS:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ANNOTATION:
        switch(__d)
        {
            case TK_ANNOTATION:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_STRUCTURE:
        switch(__d)
        {
            case TK_STRUCTURE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_UNION:
        switch(__d)
        {
            case TK_UNION:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_BITSET:
        switch(__d)
        {
            case TK_BITSET:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_SEQUENCE:
        switch(__d)
        {
            case TK_SEQUENCE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ARRAY:
        switch(__d)
        {
            case TK_ARRAY:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_MAP:
        switch(__d)
        {
            case TK_MAP:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ENUM:
        switch(__d)
        {
            case TK_ENUM:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_BITMASK:
        switch(__d)
        {
            case TK_BITMASK:
            b = true;
            break;
            default:
            break;
        }
        break;
        default:
        b = true;
        switch(__d)
        {
            case TK_ALIAS:
            case TK_ANNOTATION:
            case TK_STRUCTURE:
            case TK_UNION:
            case TK_BITSET:
            case TK_SEQUENCE:
            case TK_ARRAY:
            case TK_MAP:
            case TK_ENUM:
            case TK_BITMASK:
            b = false;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t eprosima::fastrtps::types::CompleteTypeObject::_d() const
{
    return m__d;
}

uint8_t& eprosima::fastrtps::types::CompleteTypeObject::_d()
{
    return m__d;
}

void eprosima::fastrtps::types::CompleteTypeObject::alias_type(
        const eprosima::fastrtps::types::CompleteAliasType& _alias_type)
{
    m_alias_type = _alias_type;
    m__d = TK_ALIAS;
}

void eprosima::fastrtps::types::CompleteTypeObject::alias_type(
        eprosima::fastrtps::types::CompleteAliasType&& _alias_type)
{
    m_alias_type = std::move(_alias_type);
    m__d = TK_ALIAS;
}

const eprosima::fastrtps::types::CompleteAliasType& eprosima::fastrtps::types::CompleteTypeObject::alias_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ALIAS:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_alias_type;
}

eprosima::fastrtps::types::CompleteAliasType& eprosima::fastrtps::types::CompleteTypeObject::alias_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ALIAS:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_alias_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::annotation_type(
        const eprosima::fastrtps::types::CompleteAnnotationType& _annotation_type)
{
    m_annotation_type = _annotation_type;
    m__d = TK_ANNOTATION;
}

void eprosima::fastrtps::types::CompleteTypeObject::annotation_type(
        eprosima::fastrtps::types::CompleteAnnotationType&& _annotation_type)
{
    m_annotation_type = std::move(_annotation_type);
    m__d = TK_ANNOTATION;
}

const eprosima::fastrtps::types::CompleteAnnotationType& eprosima::fastrtps::types::CompleteTypeObject::annotation_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ANNOTATION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_annotation_type;
}

eprosima::fastrtps::types::CompleteAnnotationType& eprosima::fastrtps::types::CompleteTypeObject::annotation_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ANNOTATION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_annotation_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::struct_type(
        const eprosima::fastrtps::types::CompleteStructType& _struct_type)
{
    m_struct_type = _struct_type;
    m__d = TK_STRUCTURE;
}

void eprosima::fastrtps::types::CompleteTypeObject::struct_type(
        eprosima::fastrtps::types::CompleteStructType&& _struct_type)
{
    m_struct_type = std::move(_struct_type);
    m__d = TK_STRUCTURE;
}

const eprosima::fastrtps::types::CompleteStructType& eprosima::fastrtps::types::CompleteTypeObject::struct_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRUCTURE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_struct_type;
}

eprosima::fastrtps::types::CompleteStructType& eprosima::fastrtps::types::CompleteTypeObject::struct_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRUCTURE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_struct_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::union_type(
        const eprosima::fastrtps::types::CompleteUnionType& _union_type)
{
    m_union_type = _union_type;
    m__d = TK_UNION;
}

void eprosima::fastrtps::types::CompleteTypeObject::union_type(
        eprosima::fastrtps::types::CompleteUnionType&& _union_type)
{
    m_union_type = std::move(_union_type);
    m__d = TK_UNION;
}

const eprosima::fastrtps::types::CompleteUnionType& eprosima::fastrtps::types::CompleteTypeObject::union_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_UNION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_union_type;
}

eprosima::fastrtps::types::CompleteUnionType& eprosima::fastrtps::types::CompleteTypeObject::union_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_UNION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_union_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::bitset_type(
        const eprosima::fastrtps::types::CompleteBitsetType& _bitset_type)
{
    m_bitset_type = _bitset_type;
    m__d = TK_BITSET;
}

void eprosima::fastrtps::types::CompleteTypeObject::bitset_type(
        eprosima::fastrtps::types::CompleteBitsetType&& _bitset_type)
{
    m_bitset_type = std::move(_bitset_type);
    m__d = TK_BITSET;
}

const eprosima::fastrtps::types::CompleteBitsetType& eprosima::fastrtps::types::CompleteTypeObject::bitset_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITSET:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitset_type;
}

eprosima::fastrtps::types::CompleteBitsetType& eprosima::fastrtps::types::CompleteTypeObject::bitset_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITSET:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitset_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::sequence_type(
        const eprosima::fastrtps::types::CompleteSequenceType& _sequence_type)
{
    m_sequence_type = _sequence_type;
    m__d = TK_SEQUENCE;
}

void eprosima::fastrtps::types::CompleteTypeObject::sequence_type(
        eprosima::fastrtps::types::CompleteSequenceType&& _sequence_type)
{
    m_sequence_type = std::move(_sequence_type);
    m__d = TK_SEQUENCE;
}

const eprosima::fastrtps::types::CompleteSequenceType& eprosima::fastrtps::types::CompleteTypeObject::sequence_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_SEQUENCE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_sequence_type;
}

eprosima::fastrtps::types::CompleteSequenceType& eprosima::fastrtps::types::CompleteTypeObject::sequence_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_SEQUENCE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_sequence_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::array_type(
        const eprosima::fastrtps::types::CompleteArrayType& _array_type)
{
    m_array_type = _array_type;
    m__d = TK_ARRAY;
}

void eprosima::fastrtps::types::CompleteTypeObject::array_type(
        eprosima::fastrtps::types::CompleteArrayType&& _array_type)
{
    m_array_type = std::move(_array_type);
    m__d = TK_ARRAY;
}

const eprosima::fastrtps::types::CompleteArrayType& eprosima::fastrtps::types::CompleteTypeObject::array_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ARRAY:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_array_type;
}

eprosima::fastrtps::types::CompleteArrayType& eprosima::fastrtps::types::CompleteTypeObject::array_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ARRAY:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_array_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::map_type(
        const eprosima::fastrtps::types::CompleteMapType& _map_type)
{
    m_map_type = _map_type;
    m__d = TK_MAP;
}

void eprosima::fastrtps::types::CompleteTypeObject::map_type(
        eprosima::fastrtps::types::CompleteMapType&& _map_type)
{
    m_map_type = std::move(_map_type);
    m__d = TK_MAP;
}

const eprosima::fastrtps::types::CompleteMapType& eprosima::fastrtps::types::CompleteTypeObject::map_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_MAP:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_map_type;
}

eprosima::fastrtps::types::CompleteMapType& eprosima::fastrtps::types::CompleteTypeObject::map_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_MAP:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_map_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::enumerated_type(
        const eprosima::fastrtps::types::CompleteEnumeratedType& _enumerated_type)
{
    m_enumerated_type = _enumerated_type;
    m__d = TK_ENUM;
}

void eprosima::fastrtps::types::CompleteTypeObject::enumerated_type(
        eprosima::fastrtps::types::CompleteEnumeratedType&& _enumerated_type)
{
    m_enumerated_type = std::move(_enumerated_type);
    m__d = TK_ENUM;
}

const eprosima::fastrtps::types::CompleteEnumeratedType& eprosima::fastrtps::types::CompleteTypeObject::enumerated_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ENUM:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_enumerated_type;
}

eprosima::fastrtps::types::CompleteEnumeratedType& eprosima::fastrtps::types::CompleteTypeObject::enumerated_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ENUM:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_enumerated_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::bitmask_type(
        const eprosima::fastrtps::types::CompleteBitmaskType& _bitmask_type)
{
    m_bitmask_type = _bitmask_type;
    m__d = TK_BITMASK;
}

void eprosima::fastrtps::types::CompleteTypeObject::bitmask_type(
        eprosima::fastrtps::types::CompleteBitmaskType&& _bitmask_type)
{
    m_bitmask_type = std::move(_bitmask_type);
    m__d = TK_BITMASK;
}

const eprosima::fastrtps::types::CompleteBitmaskType& eprosima::fastrtps::types::CompleteTypeObject::bitmask_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITMASK:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitmask_type;
}

eprosima::fastrtps::types::CompleteBitmaskType& eprosima::fastrtps::types::CompleteTypeObject::bitmask_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITMASK:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitmask_type;
}
void eprosima::fastrtps::types::CompleteTypeObject::extended_type(
        const eprosima::fastrtps::types::CompleteExtendedType& _extended_type)
{
    m_extended_type = _extended_type;
    m__d = 0;
}

void eprosima::fastrtps::types::CompleteTypeObject::extended_type(
        eprosima::fastrtps::types::CompleteExtendedType&& _extended_type)
{
    m_extended_type = std::move(_extended_type);
    m__d = 0;
}

const eprosima::fastrtps::types::CompleteExtendedType& eprosima::fastrtps::types::CompleteTypeObject::extended_type() const
{
    bool b = true;

    switch(m__d)
    {
        case TK_ALIAS:
        case TK_ANNOTATION:
        case TK_STRUCTURE:
        case TK_UNION:
        case TK_BITSET:
        case TK_SEQUENCE:
        case TK_ARRAY:
        case TK_MAP:
        case TK_ENUM:
        case TK_BITMASK:
        b = false;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_extended_type;
}

eprosima::fastrtps::types::CompleteExtendedType& eprosima::fastrtps::types::CompleteTypeObject::extended_type()
{
    bool b = true;

    switch(m__d)
    {
        case TK_ALIAS:
        case TK_ANNOTATION:
        case TK_STRUCTURE:
        case TK_UNION:
        case TK_BITSET:
        case TK_SEQUENCE:
        case TK_ARRAY:
        case TK_MAP:
        case TK_ENUM:
        case TK_BITMASK:
        b = false;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_extended_type;
}

// TODO(Ricardo) Review
size_t eprosima::fastrtps::types::CompleteTypeObject::getCdrSerializedSize(
        const eprosima::fastrtps::types::CompleteTypeObject& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case TK_ALIAS:
        current_alignment += eprosima::fastrtps::types::CompleteAliasType::getCdrSerializedSize(data.alias_type(), current_alignment);
        break;
        case TK_ANNOTATION:
        current_alignment += eprosima::fastrtps::types::CompleteAnnotationType::getCdrSerializedSize(data.annotation_type(), current_alignment);
        break;
        case TK_STRUCTURE:
        current_alignment += eprosima::fastrtps::types::CompleteStructType::getCdrSerializedSize(data.struct_type(), current_alignment);
        break;
        case TK_UNION:
        current_alignment += eprosima::fastrtps::types::CompleteUnionType::getCdrSerializedSize(data.union_type(), current_alignment);
        break;
        case TK_BITSET:
        current_alignment += eprosima::fastrtps::types::CompleteBitsetType::getCdrSerializedSize(data.bitset_type(), current_alignment);
        break;
        case TK_SEQUENCE:
        current_alignment += eprosima::fastrtps::types::CompleteSequenceType::getCdrSerializedSize(data.sequence_type(), current_alignment);
        break;
        case TK_ARRAY:
        current_alignment += eprosima::fastrtps::types::CompleteArrayType::getCdrSerializedSize(data.array_type(), current_alignment);
        break;
        case TK_MAP:
        current_alignment += eprosima::fastrtps::types::CompleteMapType::getCdrSerializedSize(data.map_type(), current_alignment);
        break;
        case TK_ENUM:
        current_alignment += eprosima::fastrtps::types::CompleteEnumeratedType::getCdrSerializedSize(data.enumerated_type(), current_alignment);
        break;
        case TK_BITMASK:
        current_alignment += eprosima::fastrtps::types::CompleteBitmaskType::getCdrSerializedSize(data.bitmask_type(), current_alignment);
        break;

        default:
        current_alignment += eprosima::fastrtps::types::CompleteExtendedType::getCdrSerializedSize(data.extended_type(), current_alignment);
        break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::CompleteTypeObject::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        scdr << m_alias_type;
        break;
        case TK_ANNOTATION:
        scdr << m_annotation_type;
        break;
        case TK_STRUCTURE:
        scdr << m_struct_type;
        break;
        case TK_UNION:
        scdr << m_union_type;
        break;
        case TK_BITSET:
        scdr << m_bitset_type;
        break;
        case TK_SEQUENCE:
        scdr << m_sequence_type;
        break;
        case TK_ARRAY:
        scdr << m_array_type;
        break;
        case TK_MAP:
        scdr << m_map_type;
        break;
        case TK_ENUM:
        scdr << m_enumerated_type;
        break;
        case TK_BITMASK:
        scdr << m_bitmask_type;
        break;

        default:
        scdr << m_extended_type;
        break;
    }
}

void eprosima::fastrtps::types::CompleteTypeObject::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        dcdr >> m_alias_type;
        break;
        case TK_ANNOTATION:
        dcdr >> m_annotation_type;
        break;
        case TK_STRUCTURE:
        dcdr >> m_struct_type;
        break;
        case TK_UNION:
        dcdr >> m_union_type;
        break;
        case TK_BITSET:
        dcdr >> m_bitset_type;
        break;
        case TK_SEQUENCE:
        dcdr >> m_sequence_type;
        break;
        case TK_ARRAY:
        dcdr >> m_array_type;
        break;
        case TK_MAP:
        dcdr >> m_map_type;
        break;
        case TK_ENUM:
        dcdr >> m_enumerated_type;
        break;
        case TK_BITMASK:
        dcdr >> m_bitmask_type;
        break;

        default:
        dcdr >> m_extended_type;
        break;
    }
}


eprosima::fastrtps::types::MinimalExtendedType::MinimalExtendedType()
{

}

eprosima::fastrtps::types::MinimalExtendedType::~MinimalExtendedType()
{
}

eprosima::fastrtps::types::MinimalExtendedType::MinimalExtendedType(
        const MinimalExtendedType& /*x*/)
{
}

eprosima::fastrtps::types::MinimalExtendedType::MinimalExtendedType(
        MinimalExtendedType&& /*x*/) noexcept 
{
}

eprosima::fastrtps::types::MinimalExtendedType& eprosima::fastrtps::types::MinimalExtendedType::operator =(
        const MinimalExtendedType& /*x*/)
{


    return *this;
}

eprosima::fastrtps::types::MinimalExtendedType& eprosima::fastrtps::types::MinimalExtendedType::operator =(
        MinimalExtendedType&& /*x*/) noexcept
{


    return *this;
}

bool eprosima::fastrtps::types::MinimalExtendedType::operator ==(
        const MinimalExtendedType& /*x*/) const
{

    return true;
}

bool eprosima::fastrtps::types::MinimalExtendedType::operator !=(
        const MinimalExtendedType& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::MinimalExtendedType::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalExtendedType_max_cdr_typesize;
}

size_t eprosima::fastrtps::types::MinimalExtendedType::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalExtendedType& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalExtendedType::serialize(
        eprosima::fastcdr::Cdr& /*scdr*/) const
{

}

void eprosima::fastrtps::types::MinimalExtendedType::deserialize(
        eprosima::fastcdr::Cdr& /*dcdr*/)
{

}



size_t eprosima::fastrtps::types::MinimalExtendedType::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_MinimalExtendedType_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::MinimalExtendedType::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::MinimalExtendedType::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::types::MinimalTypeObject::MinimalTypeObject()
{
    m__d = 0;
    // eprosima::fastrtps::types::MinimalAliasType m_alias_type

    // eprosima::fastrtps::types::MinimalAnnotationType m_annotation_type

    // eprosima::fastrtps::types::MinimalStructType m_struct_type

    // eprosima::fastrtps::types::MinimalUnionType m_union_type

    // eprosima::fastrtps::types::MinimalBitsetType m_bitset_type

    // eprosima::fastrtps::types::MinimalSequenceType m_sequence_type

    // eprosima::fastrtps::types::MinimalArrayType m_array_type

    // eprosima::fastrtps::types::MinimalMapType m_map_type

    // eprosima::fastrtps::types::MinimalEnumeratedType m_enumerated_type

    // eprosima::fastrtps::types::MinimalBitmaskType m_bitmask_type

    // eprosima::fastrtps::types::MinimalExtendedType m_extended_type

}

eprosima::fastrtps::types::MinimalTypeObject::~MinimalTypeObject()
{
}

eprosima::fastrtps::types::MinimalTypeObject::MinimalTypeObject(
        const MinimalTypeObject& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = x.m_alias_type;
        break;
        case TK_ANNOTATION:
        m_annotation_type = x.m_annotation_type;
        break;
        case TK_STRUCTURE:
        m_struct_type = x.m_struct_type;
        break;
        case TK_UNION:
        m_union_type = x.m_union_type;
        break;
        case TK_BITSET:
        m_bitset_type = x.m_bitset_type;
        break;
        case TK_SEQUENCE:
        m_sequence_type = x.m_sequence_type;
        break;
        case TK_ARRAY:
        m_array_type = x.m_array_type;
        break;
        case TK_MAP:
        m_map_type = x.m_map_type;
        break;
        case TK_ENUM:
        m_enumerated_type = x.m_enumerated_type;
        break;
        case TK_BITMASK:
        m_bitmask_type = x.m_bitmask_type;
        break;

        default:
        m_extended_type = x.m_extended_type;
        break;
    }
}

eprosima::fastrtps::types::MinimalTypeObject::MinimalTypeObject(
        MinimalTypeObject&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = std::move(x.m_alias_type);
        break;
        case TK_ANNOTATION:
        m_annotation_type = std::move(x.m_annotation_type);
        break;
        case TK_STRUCTURE:
        m_struct_type = std::move(x.m_struct_type);
        break;
        case TK_UNION:
        m_union_type = std::move(x.m_union_type);
        break;
        case TK_BITSET:
        m_bitset_type = std::move(x.m_bitset_type);
        break;
        case TK_SEQUENCE:
        m_sequence_type = std::move(x.m_sequence_type);
        break;
        case TK_ARRAY:
        m_array_type = std::move(x.m_array_type);
        break;
        case TK_MAP:
        m_map_type = std::move(x.m_map_type);
        break;
        case TK_ENUM:
        m_enumerated_type = std::move(x.m_enumerated_type);
        break;
        case TK_BITMASK:
        m_bitmask_type = std::move(x.m_bitmask_type);
        break;

        default:
        m_extended_type = std::move(x.m_extended_type);
        break;
    }
}

eprosima::fastrtps::types::MinimalTypeObject& eprosima::fastrtps::types::MinimalTypeObject::operator =(
        const MinimalTypeObject& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = x.m_alias_type;
        break;
        case TK_ANNOTATION:
        m_annotation_type = x.m_annotation_type;
        break;
        case TK_STRUCTURE:
        m_struct_type = x.m_struct_type;
        break;
        case TK_UNION:
        m_union_type = x.m_union_type;
        break;
        case TK_BITSET:
        m_bitset_type = x.m_bitset_type;
        break;
        case TK_SEQUENCE:
        m_sequence_type = x.m_sequence_type;
        break;
        case TK_ARRAY:
        m_array_type = x.m_array_type;
        break;
        case TK_MAP:
        m_map_type = x.m_map_type;
        break;
        case TK_ENUM:
        m_enumerated_type = x.m_enumerated_type;
        break;
        case TK_BITMASK:
        m_bitmask_type = x.m_bitmask_type;
        break;

        default:
        m_extended_type = x.m_extended_type;
        break;
    }

    return *this;
}

eprosima::fastrtps::types::MinimalTypeObject& eprosima::fastrtps::types::MinimalTypeObject::operator =(
        MinimalTypeObject&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        m_alias_type = std::move(x.m_alias_type);
        break;
        case TK_ANNOTATION:
        m_annotation_type = std::move(x.m_annotation_type);
        break;
        case TK_STRUCTURE:
        m_struct_type = std::move(x.m_struct_type);
        break;
        case TK_UNION:
        m_union_type = std::move(x.m_union_type);
        break;
        case TK_BITSET:
        m_bitset_type = std::move(x.m_bitset_type);
        break;
        case TK_SEQUENCE:
        m_sequence_type = std::move(x.m_sequence_type);
        break;
        case TK_ARRAY:
        m_array_type = std::move(x.m_array_type);
        break;
        case TK_MAP:
        m_map_type = std::move(x.m_map_type);
        break;
        case TK_ENUM:
        m_enumerated_type = std::move(x.m_enumerated_type);
        break;
        case TK_BITMASK:
        m_bitmask_type = std::move(x.m_bitmask_type);
        break;

        default:
        m_extended_type = std::move(x.m_extended_type);
        break;
    }

    return *this;
}

bool eprosima::fastrtps::types::MinimalTypeObject::operator ==(
        const MinimalTypeObject& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case TK_ALIAS:
            return (m_alias_type == x.m_alias_type);
            break;
        case TK_ANNOTATION:
            return (m_annotation_type == x.m_annotation_type);
            break;
        case TK_STRUCTURE:
            return (m_struct_type == x.m_struct_type);
            break;
        case TK_UNION:
            return (m_union_type == x.m_union_type);
            break;
        case TK_BITSET:
            return (m_bitset_type == x.m_bitset_type);
            break;
        case TK_SEQUENCE:
            return (m_sequence_type == x.m_sequence_type);
            break;
        case TK_ARRAY:
            return (m_array_type == x.m_array_type);
            break;
        case TK_MAP:
            return (m_map_type == x.m_map_type);
            break;
        case TK_ENUM:
            return (m_enumerated_type == x.m_enumerated_type);
            break;
        case TK_BITMASK:
            return (m_bitmask_type == x.m_bitmask_type);
            break;

        default:
        return m_extended_type == x.m_extended_type;
        break;
    }
    return false;
}

bool eprosima::fastrtps::types::MinimalTypeObject::operator !=(
        const MinimalTypeObject& x) const
{
    return !(*this == x);
}

void eprosima::fastrtps::types::MinimalTypeObject::_d(
        uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case TK_ALIAS:
        switch(__d)
        {
            case TK_ALIAS:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ANNOTATION:
        switch(__d)
        {
            case TK_ANNOTATION:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_STRUCTURE:
        switch(__d)
        {
            case TK_STRUCTURE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_UNION:
        switch(__d)
        {
            case TK_UNION:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_BITSET:
        switch(__d)
        {
            case TK_BITSET:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_SEQUENCE:
        switch(__d)
        {
            case TK_SEQUENCE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ARRAY:
        switch(__d)
        {
            case TK_ARRAY:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_MAP:
        switch(__d)
        {
            case TK_MAP:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_ENUM:
        switch(__d)
        {
            case TK_ENUM:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TK_BITMASK:
        switch(__d)
        {
            case TK_BITMASK:
            b = true;
            break;
            default:
            break;
        }
        break;
        default:
        b = true;
        switch(__d)
        {
            case TK_ALIAS:
            case TK_ANNOTATION:
            case TK_STRUCTURE:
            case TK_UNION:
            case TK_BITSET:
            case TK_SEQUENCE:
            case TK_ARRAY:
            case TK_MAP:
            case TK_ENUM:
            case TK_BITMASK:
            b = false;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t eprosima::fastrtps::types::MinimalTypeObject::_d() const
{
    return m__d;
}

uint8_t& eprosima::fastrtps::types::MinimalTypeObject::_d()
{
    return m__d;
}

void eprosima::fastrtps::types::MinimalTypeObject::alias_type(
        const eprosima::fastrtps::types::MinimalAliasType& _alias_type)
{
    m_alias_type = _alias_type;
    m__d = TK_ALIAS;
}

void eprosima::fastrtps::types::MinimalTypeObject::alias_type(
        eprosima::fastrtps::types::MinimalAliasType&& _alias_type)
{
    m_alias_type = std::move(_alias_type);
    m__d = TK_ALIAS;
}

const eprosima::fastrtps::types::MinimalAliasType& eprosima::fastrtps::types::MinimalTypeObject::alias_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ALIAS:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_alias_type;
}

eprosima::fastrtps::types::MinimalAliasType& eprosima::fastrtps::types::MinimalTypeObject::alias_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ALIAS:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_alias_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::annotation_type(
        const eprosima::fastrtps::types::MinimalAnnotationType& _annotation_type)
{
    m_annotation_type = _annotation_type;
    m__d = TK_ANNOTATION;
}

void eprosima::fastrtps::types::MinimalTypeObject::annotation_type(
        eprosima::fastrtps::types::MinimalAnnotationType&& _annotation_type)
{
    m_annotation_type = std::move(_annotation_type);
    m__d = TK_ANNOTATION;
}

const eprosima::fastrtps::types::MinimalAnnotationType& eprosima::fastrtps::types::MinimalTypeObject::annotation_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ANNOTATION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_annotation_type;
}

eprosima::fastrtps::types::MinimalAnnotationType& eprosima::fastrtps::types::MinimalTypeObject::annotation_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ANNOTATION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_annotation_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::struct_type(
        const eprosima::fastrtps::types::MinimalStructType& _struct_type)
{
    m_struct_type = _struct_type;
    m__d = TK_STRUCTURE;
}

void eprosima::fastrtps::types::MinimalTypeObject::struct_type(
        eprosima::fastrtps::types::MinimalStructType&& _struct_type)
{
    m_struct_type = std::move(_struct_type);
    m__d = TK_STRUCTURE;
}

const eprosima::fastrtps::types::MinimalStructType& eprosima::fastrtps::types::MinimalTypeObject::struct_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRUCTURE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_struct_type;
}

eprosima::fastrtps::types::MinimalStructType& eprosima::fastrtps::types::MinimalTypeObject::struct_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_STRUCTURE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_struct_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::union_type(
        const eprosima::fastrtps::types::MinimalUnionType& _union_type)
{
    m_union_type = _union_type;
    m__d = TK_UNION;
}

void eprosima::fastrtps::types::MinimalTypeObject::union_type(
        eprosima::fastrtps::types::MinimalUnionType&& _union_type)
{
    m_union_type = std::move(_union_type);
    m__d = TK_UNION;
}

const eprosima::fastrtps::types::MinimalUnionType& eprosima::fastrtps::types::MinimalTypeObject::union_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_UNION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_union_type;
}

eprosima::fastrtps::types::MinimalUnionType& eprosima::fastrtps::types::MinimalTypeObject::union_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_UNION:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_union_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::bitset_type(
        const eprosima::fastrtps::types::MinimalBitsetType& _bitset_type)
{
    m_bitset_type = _bitset_type;
    m__d = TK_BITSET;
}

void eprosima::fastrtps::types::MinimalTypeObject::bitset_type(
        eprosima::fastrtps::types::MinimalBitsetType&& _bitset_type)
{
    m_bitset_type = std::move(_bitset_type);
    m__d = TK_BITSET;
}

const eprosima::fastrtps::types::MinimalBitsetType& eprosima::fastrtps::types::MinimalTypeObject::bitset_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITSET:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitset_type;
}

eprosima::fastrtps::types::MinimalBitsetType& eprosima::fastrtps::types::MinimalTypeObject::bitset_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITSET:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitset_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::sequence_type(
        const eprosima::fastrtps::types::MinimalSequenceType& _sequence_type)
{
    m_sequence_type = _sequence_type;
    m__d = TK_SEQUENCE;
}

void eprosima::fastrtps::types::MinimalTypeObject::sequence_type(
        eprosima::fastrtps::types::MinimalSequenceType&& _sequence_type)
{
    m_sequence_type = std::move(_sequence_type);
    m__d = TK_SEQUENCE;
}

const eprosima::fastrtps::types::MinimalSequenceType& eprosima::fastrtps::types::MinimalTypeObject::sequence_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_SEQUENCE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_sequence_type;
}

eprosima::fastrtps::types::MinimalSequenceType& eprosima::fastrtps::types::MinimalTypeObject::sequence_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_SEQUENCE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_sequence_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::array_type(
        const eprosima::fastrtps::types::MinimalArrayType& _array_type)
{
    m_array_type = _array_type;
    m__d = TK_ARRAY;
}

void eprosima::fastrtps::types::MinimalTypeObject::array_type(
        eprosima::fastrtps::types::MinimalArrayType&& _array_type)
{
    m_array_type = std::move(_array_type);
    m__d = TK_ARRAY;
}

const eprosima::fastrtps::types::MinimalArrayType& eprosima::fastrtps::types::MinimalTypeObject::array_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ARRAY:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_array_type;
}

eprosima::fastrtps::types::MinimalArrayType& eprosima::fastrtps::types::MinimalTypeObject::array_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ARRAY:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_array_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::map_type(
        const eprosima::fastrtps::types::MinimalMapType& _map_type)
{
    m_map_type = _map_type;
    m__d = TK_MAP;
}

void eprosima::fastrtps::types::MinimalTypeObject::map_type(
        eprosima::fastrtps::types::MinimalMapType&& _map_type)
{
    m_map_type = std::move(_map_type);
    m__d = TK_MAP;
}

const eprosima::fastrtps::types::MinimalMapType& eprosima::fastrtps::types::MinimalTypeObject::map_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_MAP:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_map_type;
}

eprosima::fastrtps::types::MinimalMapType& eprosima::fastrtps::types::MinimalTypeObject::map_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_MAP:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_map_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::enumerated_type(
        const eprosima::fastrtps::types::MinimalEnumeratedType& _enumerated_type)
{
    m_enumerated_type = _enumerated_type;
    m__d = TK_ENUM;
}

void eprosima::fastrtps::types::MinimalTypeObject::enumerated_type(
        eprosima::fastrtps::types::MinimalEnumeratedType&& _enumerated_type)
{
    m_enumerated_type = std::move(_enumerated_type);
    m__d = TK_ENUM;
}

const eprosima::fastrtps::types::MinimalEnumeratedType& eprosima::fastrtps::types::MinimalTypeObject::enumerated_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_ENUM:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_enumerated_type;
}

eprosima::fastrtps::types::MinimalEnumeratedType& eprosima::fastrtps::types::MinimalTypeObject::enumerated_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_ENUM:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_enumerated_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::bitmask_type(
        const eprosima::fastrtps::types::MinimalBitmaskType& _bitmask_type)
{
    m_bitmask_type = _bitmask_type;
    m__d = TK_BITMASK;
}

void eprosima::fastrtps::types::MinimalTypeObject::bitmask_type(
        eprosima::fastrtps::types::MinimalBitmaskType&& _bitmask_type)
{
    m_bitmask_type = std::move(_bitmask_type);
    m__d = TK_BITMASK;
}

const eprosima::fastrtps::types::MinimalBitmaskType& eprosima::fastrtps::types::MinimalTypeObject::bitmask_type() const
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITMASK:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitmask_type;
}

eprosima::fastrtps::types::MinimalBitmaskType& eprosima::fastrtps::types::MinimalTypeObject::bitmask_type()
{
    bool b = false;

    switch(m__d)
    {
        case TK_BITMASK:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bitmask_type;
}
void eprosima::fastrtps::types::MinimalTypeObject::extended_type(
        const eprosima::fastrtps::types::MinimalExtendedType& _extended_type)
{
    m_extended_type = _extended_type;
    m__d = 0;
}

void eprosima::fastrtps::types::MinimalTypeObject::extended_type(
        eprosima::fastrtps::types::MinimalExtendedType&& _extended_type)
{
    m_extended_type = std::move(_extended_type);
    m__d = 0;
}

const eprosima::fastrtps::types::MinimalExtendedType& eprosima::fastrtps::types::MinimalTypeObject::extended_type() const
{
    bool b = true;

    switch(m__d)
    {
        case TK_ALIAS:
        case TK_ANNOTATION:
        case TK_STRUCTURE:
        case TK_UNION:
        case TK_BITSET:
        case TK_SEQUENCE:
        case TK_ARRAY:
        case TK_MAP:
        case TK_ENUM:
        case TK_BITMASK:
        b = false;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_extended_type;
}

eprosima::fastrtps::types::MinimalExtendedType& eprosima::fastrtps::types::MinimalTypeObject::extended_type()
{
    bool b = true;

    switch(m__d)
    {
        case TK_ALIAS:
        case TK_ANNOTATION:
        case TK_STRUCTURE:
        case TK_UNION:
        case TK_BITSET:
        case TK_SEQUENCE:
        case TK_ARRAY:
        case TK_MAP:
        case TK_ENUM:
        case TK_BITMASK:
        b = false;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_extended_type;
}

// TODO(Ricardo) Review
size_t eprosima::fastrtps::types::MinimalTypeObject::getCdrSerializedSize(
        const eprosima::fastrtps::types::MinimalTypeObject& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case TK_ALIAS:
        current_alignment += eprosima::fastrtps::types::MinimalAliasType::getCdrSerializedSize(data.alias_type(), current_alignment);
        break;
        case TK_ANNOTATION:
        current_alignment += eprosima::fastrtps::types::MinimalAnnotationType::getCdrSerializedSize(data.annotation_type(), current_alignment);
        break;
        case TK_STRUCTURE:
        current_alignment += eprosima::fastrtps::types::MinimalStructType::getCdrSerializedSize(data.struct_type(), current_alignment);
        break;
        case TK_UNION:
        current_alignment += eprosima::fastrtps::types::MinimalUnionType::getCdrSerializedSize(data.union_type(), current_alignment);
        break;
        case TK_BITSET:
        current_alignment += eprosima::fastrtps::types::MinimalBitsetType::getCdrSerializedSize(data.bitset_type(), current_alignment);
        break;
        case TK_SEQUENCE:
        current_alignment += eprosima::fastrtps::types::MinimalSequenceType::getCdrSerializedSize(data.sequence_type(), current_alignment);
        break;
        case TK_ARRAY:
        current_alignment += eprosima::fastrtps::types::MinimalArrayType::getCdrSerializedSize(data.array_type(), current_alignment);
        break;
        case TK_MAP:
        current_alignment += eprosima::fastrtps::types::MinimalMapType::getCdrSerializedSize(data.map_type(), current_alignment);
        break;
        case TK_ENUM:
        current_alignment += eprosima::fastrtps::types::MinimalEnumeratedType::getCdrSerializedSize(data.enumerated_type(), current_alignment);
        break;
        case TK_BITMASK:
        current_alignment += eprosima::fastrtps::types::MinimalBitmaskType::getCdrSerializedSize(data.bitmask_type(), current_alignment);
        break;

        default:
        current_alignment += eprosima::fastrtps::types::MinimalExtendedType::getCdrSerializedSize(data.extended_type(), current_alignment);
        break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::MinimalTypeObject::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        scdr << m_alias_type;
        break;
        case TK_ANNOTATION:
        scdr << m_annotation_type;
        break;
        case TK_STRUCTURE:
        scdr << m_struct_type;
        break;
        case TK_UNION:
        scdr << m_union_type;
        break;
        case TK_BITSET:
        scdr << m_bitset_type;
        break;
        case TK_SEQUENCE:
        scdr << m_sequence_type;
        break;
        case TK_ARRAY:
        scdr << m_array_type;
        break;
        case TK_MAP:
        scdr << m_map_type;
        break;
        case TK_ENUM:
        scdr << m_enumerated_type;
        break;
        case TK_BITMASK:
        scdr << m_bitmask_type;
        break;

        default:
        scdr << m_extended_type;
        break;
    }
}

void eprosima::fastrtps::types::MinimalTypeObject::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case TK_ALIAS:
        dcdr >> m_alias_type;
        break;
        case TK_ANNOTATION:
        dcdr >> m_annotation_type;
        break;
        case TK_STRUCTURE:
        dcdr >> m_struct_type;
        break;
        case TK_UNION:
        dcdr >> m_union_type;
        break;
        case TK_BITSET:
        dcdr >> m_bitset_type;
        break;
        case TK_SEQUENCE:
        dcdr >> m_sequence_type;
        break;
        case TK_ARRAY:
        dcdr >> m_array_type;
        break;
        case TK_MAP:
        dcdr >> m_map_type;
        break;
        case TK_ENUM:
        dcdr >> m_enumerated_type;
        break;
        case TK_BITMASK:
        dcdr >> m_bitmask_type;
        break;

        default:
        dcdr >> m_extended_type;
        break;
    }
}


eprosima::fastrtps::types::TypeObject::TypeObject()
{
    m__d = EK_COMPLETE;
    // eprosima::fastrtps::types::CompleteTypeObject m_complete

    // eprosima::fastrtps::types::MinimalTypeObject m_minimal

}

eprosima::fastrtps::types::TypeObject::~TypeObject()
{
}

eprosima::fastrtps::types::TypeObject::TypeObject(
        const TypeObject& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case EK_COMPLETE:
        m_complete = x.m_complete;
        break;
        case EK_MINIMAL:
        m_minimal = x.m_minimal;
        break;
        default:
        break;
    }
}

eprosima::fastrtps::types::TypeObject::TypeObject(
        TypeObject&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case EK_COMPLETE:
        m_complete = std::move(x.m_complete);
        break;
        case EK_MINIMAL:
        m_minimal = std::move(x.m_minimal);
        break;
        default:
        break;
    }
}

eprosima::fastrtps::types::TypeObject& eprosima::fastrtps::types::TypeObject::operator =(
        const TypeObject& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case EK_COMPLETE:
        m_complete = x.m_complete;
        break;
        case EK_MINIMAL:
        m_minimal = x.m_minimal;
        break;
        default:
        break;
    }

    return *this;
}

eprosima::fastrtps::types::TypeObject& eprosima::fastrtps::types::TypeObject::operator =(
        TypeObject&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case EK_COMPLETE:
        m_complete = std::move(x.m_complete);
        break;
        case EK_MINIMAL:
        m_minimal = std::move(x.m_minimal);
        break;
        default:
        break;
    }

    return *this;
}

bool eprosima::fastrtps::types::TypeObject::operator ==(
        const TypeObject& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case EK_COMPLETE:
            return (m_complete == x.m_complete);
            break;
        case EK_MINIMAL:
            return (m_minimal == x.m_minimal);
            break;
        default:
        break;
    }
    return false;
}

bool eprosima::fastrtps::types::TypeObject::operator !=(
        const TypeObject& x) const
{
    return !(*this == x);
}

void eprosima::fastrtps::types::TypeObject::_d(
        uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case EK_COMPLETE:
        switch(__d)
        {
            case EK_COMPLETE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case EK_MINIMAL:
        switch(__d)
        {
            case EK_MINIMAL:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t eprosima::fastrtps::types::TypeObject::_d() const
{
    return m__d;
}

uint8_t& eprosima::fastrtps::types::TypeObject::_d()
{
    return m__d;
}

void eprosima::fastrtps::types::TypeObject::complete(
        const eprosima::fastrtps::types::CompleteTypeObject& _complete)
{
    m_complete = _complete;
    m__d = EK_COMPLETE;
}

void eprosima::fastrtps::types::TypeObject::complete(
        eprosima::fastrtps::types::CompleteTypeObject&& _complete)
{
    m_complete = std::move(_complete);
    m__d = EK_COMPLETE;
}

const eprosima::fastrtps::types::CompleteTypeObject& eprosima::fastrtps::types::TypeObject::complete() const
{
    bool b = false;

    switch(m__d)
    {
        case EK_COMPLETE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_complete;
}

eprosima::fastrtps::types::CompleteTypeObject& eprosima::fastrtps::types::TypeObject::complete()
{
    bool b = false;

    switch(m__d)
    {
        case EK_COMPLETE:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_complete;
}
void eprosima::fastrtps::types::TypeObject::minimal(
        const eprosima::fastrtps::types::MinimalTypeObject& _minimal)
{
    m_minimal = _minimal;
    m__d = EK_MINIMAL;
}

void eprosima::fastrtps::types::TypeObject::minimal(
        eprosima::fastrtps::types::MinimalTypeObject&& _minimal)
{
    m_minimal = std::move(_minimal);
    m__d = EK_MINIMAL;
}

const eprosima::fastrtps::types::MinimalTypeObject& eprosima::fastrtps::types::TypeObject::minimal() const
{
    bool b = false;

    switch(m__d)
    {
        case EK_MINIMAL:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_minimal;
}

eprosima::fastrtps::types::MinimalTypeObject& eprosima::fastrtps::types::TypeObject::minimal()
{
    bool b = false;

    switch(m__d)
    {
        case EK_MINIMAL:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_minimal;
}

// TODO(Ricardo) Review
size_t eprosima::fastrtps::types::TypeObject::getCdrSerializedSize(
        const eprosima::fastrtps::types::TypeObject& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case EK_COMPLETE:
        current_alignment += eprosima::fastrtps::types::CompleteTypeObject::getCdrSerializedSize(data.complete(), current_alignment);
        break;
        case EK_MINIMAL:
        current_alignment += eprosima::fastrtps::types::MinimalTypeObject::getCdrSerializedSize(data.minimal(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::TypeObject::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case EK_COMPLETE:
        scdr << m_complete;
        break;
        case EK_MINIMAL:
        scdr << m_minimal;
        break;
        default:
        break;
    }
}

void eprosima::fastrtps::types::TypeObject::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case EK_COMPLETE:
        dcdr >> m_complete;
        break;
        case EK_MINIMAL:
        dcdr >> m_minimal;
        break;
        default:
        break;
    }
}




eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::TypeIdentifierTypeObjectPair()
{
    // eprosima::fastrtps::types::TypeIdentifier m_type_identifier

    // eprosima::fastrtps::types::TypeObject m_type_object


}

eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::~TypeIdentifierTypeObjectPair()
{


}

eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::TypeIdentifierTypeObjectPair(
        const TypeIdentifierTypeObjectPair& x)
{
    m_type_identifier = x.m_type_identifier;

    m_type_object = x.m_type_object;
}

eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::TypeIdentifierTypeObjectPair(
        TypeIdentifierTypeObjectPair&& x) noexcept 
{
    m_type_identifier = std::move(x.m_type_identifier);
    m_type_object = std::move(x.m_type_object);
}

eprosima::fastrtps::types::TypeIdentifierTypeObjectPair& eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::operator =(
        const TypeIdentifierTypeObjectPair& x)
{

    m_type_identifier = x.m_type_identifier;

    m_type_object = x.m_type_object;

    return *this;
}

eprosima::fastrtps::types::TypeIdentifierTypeObjectPair& eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::operator =(
        TypeIdentifierTypeObjectPair&& x) noexcept
{

    m_type_identifier = std::move(x.m_type_identifier);
    m_type_object = std::move(x.m_type_object);

    return *this;
}

bool eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::operator ==(
        const TypeIdentifierTypeObjectPair& x) const
{

    return (m_type_identifier == x.m_type_identifier && m_type_object == x.m_type_object);
}

bool eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::operator !=(
        const TypeIdentifierTypeObjectPair& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::getCdrSerializedSize(
        const eprosima::fastrtps::types::TypeIdentifierTypeObjectPair& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type_identifier(), current_alignment);
    current_alignment += eprosima::fastrtps::types::TypeObject::getCdrSerializedSize(data.type_object(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_type_identifier;scdr << m_type_object;
}

void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_type_identifier;
    dcdr >> m_type_object;
}

/*!
 * @brief This function copies the value in member type_identifier
 * @param _type_identifier New value to be copied in member type_identifier
 */
void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_identifier(
        const eprosima::fastrtps::types::TypeIdentifier& _type_identifier)
{
    m_type_identifier = _type_identifier;
}

/*!
 * @brief This function moves the value in member type_identifier
 * @param _type_identifier New value to be moved in member type_identifier
 */
void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_identifier(
        eprosima::fastrtps::types::TypeIdentifier&& _type_identifier)
{
    m_type_identifier = std::move(_type_identifier);
}

/*!
 * @brief This function returns a constant reference to member type_identifier
 * @return Constant reference to member type_identifier
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_identifier() const
{
    return m_type_identifier;
}

/*!
 * @brief This function returns a reference to member type_identifier
 * @return Reference to member type_identifier
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_identifier()
{
    return m_type_identifier;
}
/*!
 * @brief This function copies the value in member type_object
 * @param _type_object New value to be copied in member type_object
 */
void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_object(
        const eprosima::fastrtps::types::TypeObject& _type_object)
{
    m_type_object = _type_object;
}

/*!
 * @brief This function moves the value in member type_object
 * @param _type_object New value to be moved in member type_object
 */
void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_object(
        eprosima::fastrtps::types::TypeObject&& _type_object)
{
    m_type_object = std::move(_type_object);
}

/*!
 * @brief This function returns a constant reference to member type_object
 * @return Constant reference to member type_object
 */
const eprosima::fastrtps::types::TypeObject& eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_object() const
{
    return m_type_object;
}

/*!
 * @brief This function returns a reference to member type_object
 * @return Reference to member type_object
 */
eprosima::fastrtps::types::TypeObject& eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::type_object()
{
    return m_type_object;
}


size_t eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_TypeIdentifierTypeObjectPair_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::TypeIdentifierTypeObjectPair::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::TypeIdentifierPair::TypeIdentifierPair()
{
    // eprosima::fastrtps::types::TypeIdentifier m_type_identifier1

    // eprosima::fastrtps::types::TypeIdentifier m_type_identifier2


}

eprosima::fastrtps::types::TypeIdentifierPair::~TypeIdentifierPair()
{


}

eprosima::fastrtps::types::TypeIdentifierPair::TypeIdentifierPair(
        const TypeIdentifierPair& x)
{
    m_type_identifier1 = x.m_type_identifier1;

    m_type_identifier2 = x.m_type_identifier2;

}

eprosima::fastrtps::types::TypeIdentifierPair::TypeIdentifierPair(
        TypeIdentifierPair&& x) noexcept 
{
    m_type_identifier1 = std::move(x.m_type_identifier1);
    m_type_identifier2 = std::move(x.m_type_identifier2);
}

eprosima::fastrtps::types::TypeIdentifierPair& eprosima::fastrtps::types::TypeIdentifierPair::operator =(
        const TypeIdentifierPair& x)
{

    m_type_identifier1 = x.m_type_identifier1;

    m_type_identifier2 = x.m_type_identifier2;


    return *this;
}

eprosima::fastrtps::types::TypeIdentifierPair& eprosima::fastrtps::types::TypeIdentifierPair::operator =(
        TypeIdentifierPair&& x) noexcept
{

    m_type_identifier1 = std::move(x.m_type_identifier1);
    m_type_identifier2 = std::move(x.m_type_identifier2);

    return *this;
}

bool eprosima::fastrtps::types::TypeIdentifierPair::operator ==(
        const TypeIdentifierPair& x) const
{

    return (m_type_identifier1 == x.m_type_identifier1 && m_type_identifier2 == x.m_type_identifier2);
}

bool eprosima::fastrtps::types::TypeIdentifierPair::operator !=(
        const TypeIdentifierPair& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::TypeIdentifierPair::getCdrSerializedSize(
        const eprosima::fastrtps::types::TypeIdentifierPair& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type_identifier1(), current_alignment);
    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type_identifier2(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::TypeIdentifierPair::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_type_identifier1;scdr << m_type_identifier2;
}

void eprosima::fastrtps::types::TypeIdentifierPair::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_type_identifier1;
    dcdr >> m_type_identifier2;
}

/*!
 * @brief This function copies the value in member type_identifier1
 * @param _type_identifier1 New value to be copied in member type_identifier1
 */
void eprosima::fastrtps::types::TypeIdentifierPair::type_identifier1(
        const eprosima::fastrtps::types::TypeIdentifier& _type_identifier1)
{
    m_type_identifier1 = _type_identifier1;
}

/*!
 * @brief This function moves the value in member type_identifier1
 * @param _type_identifier1 New value to be moved in member type_identifier1
 */
void eprosima::fastrtps::types::TypeIdentifierPair::type_identifier1(
        eprosima::fastrtps::types::TypeIdentifier&& _type_identifier1)
{
    m_type_identifier1 = std::move(_type_identifier1);
}

/*!
 * @brief This function returns a constant reference to member type_identifier1
 * @return Constant reference to member type_identifier1
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierPair::type_identifier1() const
{
    return m_type_identifier1;
}

/*!
 * @brief This function returns a reference to member type_identifier1
 * @return Reference to member type_identifier1
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierPair::type_identifier1()
{
    return m_type_identifier1;
}
/*!
 * @brief This function copies the value in member type_identifier2
 * @param _type_identifier2 New value to be copied in member type_identifier2
 */
void eprosima::fastrtps::types::TypeIdentifierPair::type_identifier2(
        const eprosima::fastrtps::types::TypeIdentifier& _type_identifier2)
{
    m_type_identifier2 = _type_identifier2;
}

/*!
 * @brief This function moves the value in member type_identifier2
 * @param _type_identifier2 New value to be moved in member type_identifier2
 */
void eprosima::fastrtps::types::TypeIdentifierPair::type_identifier2(
        eprosima::fastrtps::types::TypeIdentifier&& _type_identifier2)
{
    m_type_identifier2 = std::move(_type_identifier2);
}

/*!
 * @brief This function returns a constant reference to member type_identifier2
 * @return Constant reference to member type_identifier2
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierPair::type_identifier2() const
{
    return m_type_identifier2;
}

/*!
 * @brief This function returns a reference to member type_identifier2
 * @return Reference to member type_identifier2
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierPair::type_identifier2()
{
    return m_type_identifier2;
}


size_t eprosima::fastrtps::types::TypeIdentifierPair::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_TypeIdentifierPair_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::TypeIdentifierPair::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::TypeIdentifierPair::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::TypeIdentifierWithSize::TypeIdentifierWithSize()
{
    // eprosima::fastrtps::types::TypeIdentifier m_type_id

    // unsigned long m_typeobject_serialized_size
    m_typeobject_serialized_size = 0;

}

eprosima::fastrtps::types::TypeIdentifierWithSize::~TypeIdentifierWithSize()
{


}

eprosima::fastrtps::types::TypeIdentifierWithSize::TypeIdentifierWithSize(
        const TypeIdentifierWithSize& x)
{
    m_type_id = x.m_type_id;

    m_typeobject_serialized_size = x.m_typeobject_serialized_size;
}

eprosima::fastrtps::types::TypeIdentifierWithSize::TypeIdentifierWithSize(
        TypeIdentifierWithSize&& x) noexcept 
{
    m_type_id = std::move(x.m_type_id);
    m_typeobject_serialized_size = x.m_typeobject_serialized_size;
}

eprosima::fastrtps::types::TypeIdentifierWithSize& eprosima::fastrtps::types::TypeIdentifierWithSize::operator =(
        const TypeIdentifierWithSize& x)
{

    m_type_id = x.m_type_id;

    m_typeobject_serialized_size = x.m_typeobject_serialized_size;

    return *this;
}

eprosima::fastrtps::types::TypeIdentifierWithSize& eprosima::fastrtps::types::TypeIdentifierWithSize::operator =(
        TypeIdentifierWithSize&& x) noexcept
{

    m_type_id = std::move(x.m_type_id);
    m_typeobject_serialized_size = x.m_typeobject_serialized_size;

    return *this;
}

bool eprosima::fastrtps::types::TypeIdentifierWithSize::operator ==(
        const TypeIdentifierWithSize& x) const
{

    return (m_type_id == x.m_type_id && m_typeobject_serialized_size == x.m_typeobject_serialized_size);
}

bool eprosima::fastrtps::types::TypeIdentifierWithSize::operator !=(
        const TypeIdentifierWithSize& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::TypeIdentifierWithSize::getCdrSerializedSize(
        const eprosima::fastrtps::types::TypeIdentifierWithSize& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifier::getCdrSerializedSize(data.type_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::TypeIdentifierWithSize::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_type_id;scdr << m_typeobject_serialized_size;
}

void eprosima::fastrtps::types::TypeIdentifierWithSize::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_type_id;
    dcdr >> m_typeobject_serialized_size;
}

/*!
 * @brief This function copies the value in member type_id
 * @param _type_id New value to be copied in member type_id
 */
void eprosima::fastrtps::types::TypeIdentifierWithSize::type_id(
        const eprosima::fastrtps::types::TypeIdentifier& _type_id)
{
    m_type_id = _type_id;
}

/*!
 * @brief This function moves the value in member type_id
 * @param _type_id New value to be moved in member type_id
 */
void eprosima::fastrtps::types::TypeIdentifierWithSize::type_id(
        eprosima::fastrtps::types::TypeIdentifier&& _type_id)
{
    m_type_id = std::move(_type_id);
}

/*!
 * @brief This function returns a constant reference to member type_id
 * @return Constant reference to member type_id
 */
const eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierWithSize::type_id() const
{
    return m_type_id;
}

/*!
 * @brief This function returns a reference to member type_id
 * @return Reference to member type_id
 */
eprosima::fastrtps::types::TypeIdentifier& eprosima::fastrtps::types::TypeIdentifierWithSize::type_id()
{
    return m_type_id;
}
/*!
 * @brief This function sets a value in member typeobject_serialized_size
 * @param _typeobject_serialized_size New value for member typeobject_serialized_size
 */
void eprosima::fastrtps::types::TypeIdentifierWithSize::typeobject_serialized_size(
        uint32_t _typeobject_serialized_size)
{
    m_typeobject_serialized_size = _typeobject_serialized_size;
}

/*!
 * @brief This function returns the value of member typeobject_serialized_size
 * @return Value of member typeobject_serialized_size
 */
uint32_t eprosima::fastrtps::types::TypeIdentifierWithSize::typeobject_serialized_size() const
{
    return m_typeobject_serialized_size;
}

/*!
 * @brief This function returns a reference to member typeobject_serialized_size
 * @return Reference to member typeobject_serialized_size
 */
uint32_t& eprosima::fastrtps::types::TypeIdentifierWithSize::typeobject_serialized_size()
{
    return m_typeobject_serialized_size;
}



size_t eprosima::fastrtps::types::TypeIdentifierWithSize::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_TypeIdentifierWithSize_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::TypeIdentifierWithSize::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::TypeIdentifierWithSize::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::TypeIdentifierWithDependencies::TypeIdentifierWithDependencies()
{
    // eprosima::fastrtps::types::TypeIdentifierWithSize m_typeid_with_size

    // long m_dependent_typeid_count
    m_dependent_typeid_count = 0;
    // sequence<eprosima::fastrtps::types::TypeIdentifierWithSize> m_dependent_typeids


}

eprosima::fastrtps::types::TypeIdentifierWithDependencies::~TypeIdentifierWithDependencies()
{



}

eprosima::fastrtps::types::TypeIdentifierWithDependencies::TypeIdentifierWithDependencies(
        const TypeIdentifierWithDependencies& x)
{
    m_typeid_with_size = x.m_typeid_with_size;
    m_dependent_typeid_count = x.m_dependent_typeid_count;
    m_dependent_typeids = x.m_dependent_typeids;
}

eprosima::fastrtps::types::TypeIdentifierWithDependencies::TypeIdentifierWithDependencies(
        TypeIdentifierWithDependencies&& x) noexcept 
{
    m_typeid_with_size = std::move(x.m_typeid_with_size);
    m_dependent_typeid_count = x.m_dependent_typeid_count;
    m_dependent_typeids = std::move(x.m_dependent_typeids);
}

eprosima::fastrtps::types::TypeIdentifierWithDependencies& eprosima::fastrtps::types::TypeIdentifierWithDependencies::operator =(
        const TypeIdentifierWithDependencies& x)
{

    m_typeid_with_size = x.m_typeid_with_size;
    m_dependent_typeid_count = x.m_dependent_typeid_count;
    m_dependent_typeids = x.m_dependent_typeids;

    return *this;
}

eprosima::fastrtps::types::TypeIdentifierWithDependencies& eprosima::fastrtps::types::TypeIdentifierWithDependencies::operator =(
        TypeIdentifierWithDependencies&& x) noexcept
{

    m_typeid_with_size = std::move(x.m_typeid_with_size);
    m_dependent_typeid_count = x.m_dependent_typeid_count;
    m_dependent_typeids = std::move(x.m_dependent_typeids);

    return *this;
}

bool eprosima::fastrtps::types::TypeIdentifierWithDependencies::operator ==(
        const TypeIdentifierWithDependencies& x) const
{

    return (m_typeid_with_size == x.m_typeid_with_size && m_dependent_typeid_count == x.m_dependent_typeid_count && m_dependent_typeids == x.m_dependent_typeids);
}

bool eprosima::fastrtps::types::TypeIdentifierWithDependencies::operator !=(
        const TypeIdentifierWithDependencies& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::TypeIdentifierWithDependencies::getCdrSerializedSize(
        const eprosima::fastrtps::types::TypeIdentifierWithDependencies& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifierWithSize::getCdrSerializedSize(data.typeid_with_size(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.dependent_typeids().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::types::TypeIdentifierWithSize::getCdrSerializedSize(data.dependent_typeids().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::TypeIdentifierWithDependencies::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_typeid_with_size;scdr << m_dependent_typeid_count;scdr << m_dependent_typeids;

}

void eprosima::fastrtps::types::TypeIdentifierWithDependencies::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_typeid_with_size;
    dcdr >> m_dependent_typeid_count;
    dcdr >> m_dependent_typeids;
}

/*!
 * @brief This function copies the value in member typeid_with_size
 * @param _typeid_with_size New value to be copied in member typeid_with_size
 */
void eprosima::fastrtps::types::TypeIdentifierWithDependencies::typeid_with_size(
        const eprosima::fastrtps::types::TypeIdentifierWithSize& _typeid_with_size)
{
    m_typeid_with_size = _typeid_with_size;
}

/*!
 * @brief This function moves the value in member typeid_with_size
 * @param _typeid_with_size New value to be moved in member typeid_with_size
 */
void eprosima::fastrtps::types::TypeIdentifierWithDependencies::typeid_with_size(
        eprosima::fastrtps::types::TypeIdentifierWithSize&& _typeid_with_size)
{
    m_typeid_with_size = std::move(_typeid_with_size);
}

/*!
 * @brief This function returns a constant reference to member typeid_with_size
 * @return Constant reference to member typeid_with_size
 */
const eprosima::fastrtps::types::TypeIdentifierWithSize& eprosima::fastrtps::types::TypeIdentifierWithDependencies::typeid_with_size() const
{
    return m_typeid_with_size;
}

/*!
 * @brief This function returns a reference to member typeid_with_size
 * @return Reference to member typeid_with_size
 */
eprosima::fastrtps::types::TypeIdentifierWithSize& eprosima::fastrtps::types::TypeIdentifierWithDependencies::typeid_with_size()
{
    return m_typeid_with_size;
}
/*!
 * @brief This function sets a value in member dependent_typeid_count
 * @param _dependent_typeid_count New value for member dependent_typeid_count
 */
void eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeid_count(
        int32_t _dependent_typeid_count)
{
    m_dependent_typeid_count = _dependent_typeid_count;
}

/*!
 * @brief This function returns the value of member dependent_typeid_count
 * @return Value of member dependent_typeid_count
 */
int32_t eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeid_count() const
{
    return m_dependent_typeid_count;
}

/*!
 * @brief This function returns a reference to member dependent_typeid_count
 * @return Reference to member dependent_typeid_count
 */
int32_t& eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeid_count()
{
    return m_dependent_typeid_count;
}

/*!
 * @brief This function copies the value in member dependent_typeids
 * @param _dependent_typeids New value to be copied in member dependent_typeids
 */
void eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeids(
        const std::vector<eprosima::fastrtps::types::TypeIdentifierWithSize>& _dependent_typeids)
{
    m_dependent_typeids = _dependent_typeids;
}

/*!
 * @brief This function moves the value in member dependent_typeids
 * @param _dependent_typeids New value to be moved in member dependent_typeids
 */
void eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeids(
        std::vector<eprosima::fastrtps::types::TypeIdentifierWithSize>&& _dependent_typeids)
{
    m_dependent_typeids = std::move(_dependent_typeids);
}

/*!
 * @brief This function returns a constant reference to member dependent_typeids
 * @return Constant reference to member dependent_typeids
 */
const std::vector<eprosima::fastrtps::types::TypeIdentifierWithSize>& eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeids() const
{
    return m_dependent_typeids;
}

/*!
 * @brief This function returns a reference to member dependent_typeids
 * @return Reference to member dependent_typeids
 */
std::vector<eprosima::fastrtps::types::TypeIdentifierWithSize>& eprosima::fastrtps::types::TypeIdentifierWithDependencies::dependent_typeids()
{
    return m_dependent_typeids;
}


size_t eprosima::fastrtps::types::TypeIdentifierWithDependencies::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_TypeIdentifierWithDependencies_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::TypeIdentifierWithDependencies::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::TypeIdentifierWithDependencies::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::types::TypeInformation::TypeInformation()
{
    // eprosima::fastrtps::types::TypeIdentifierWithDependencies m_minimal

    // eprosima::fastrtps::types::TypeIdentifierWithDependencies m_complete


}

eprosima::fastrtps::types::TypeInformation::~TypeInformation()
{


}

eprosima::fastrtps::types::TypeInformation::TypeInformation(
        const TypeInformation& x)
{
    m_minimal = x.m_minimal;
    m_complete = x.m_complete;
}

eprosima::fastrtps::types::TypeInformation::TypeInformation(
        TypeInformation&& x) noexcept 
{
    m_minimal = std::move(x.m_minimal);
    m_complete = std::move(x.m_complete);
}

eprosima::fastrtps::types::TypeInformation& eprosima::fastrtps::types::TypeInformation::operator =(
        const TypeInformation& x)
{

    m_minimal = x.m_minimal;
    m_complete = x.m_complete;

    return *this;
}

eprosima::fastrtps::types::TypeInformation& eprosima::fastrtps::types::TypeInformation::operator =(
        TypeInformation&& x) noexcept
{

    m_minimal = std::move(x.m_minimal);
    m_complete = std::move(x.m_complete);

    return *this;
}

bool eprosima::fastrtps::types::TypeInformation::operator ==(
        const TypeInformation& x) const
{

    return (m_minimal == x.m_minimal && m_complete == x.m_complete);
}

bool eprosima::fastrtps::types::TypeInformation::operator !=(
        const TypeInformation& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::types::TypeInformation::getCdrSerializedSize(
        const eprosima::fastrtps::types::TypeInformation& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::types::TypeIdentifierWithDependencies::getCdrSerializedSize(data.minimal(), current_alignment);
    current_alignment += eprosima::fastrtps::types::TypeIdentifierWithDependencies::getCdrSerializedSize(data.complete(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::types::TypeInformation::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_minimal;scdr << m_complete;
}

void eprosima::fastrtps::types::TypeInformation::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_minimal;
    dcdr >> m_complete;
}

/*!
 * @brief This function copies the value in member minimal
 * @param _minimal New value to be copied in member minimal
 */
void eprosima::fastrtps::types::TypeInformation::minimal(
        const eprosima::fastrtps::types::TypeIdentifierWithDependencies& _minimal)
{
    m_minimal = _minimal;
}

/*!
 * @brief This function moves the value in member minimal
 * @param _minimal New value to be moved in member minimal
 */
void eprosima::fastrtps::types::TypeInformation::minimal(
        eprosima::fastrtps::types::TypeIdentifierWithDependencies&& _minimal)
{
    m_minimal = std::move(_minimal);
}

/*!
 * @brief This function returns a constant reference to member minimal
 * @return Constant reference to member minimal
 */
const eprosima::fastrtps::types::TypeIdentifierWithDependencies& eprosima::fastrtps::types::TypeInformation::minimal() const
{
    return m_minimal;
}

/*!
 * @brief This function returns a reference to member minimal
 * @return Reference to member minimal
 */
eprosima::fastrtps::types::TypeIdentifierWithDependencies& eprosima::fastrtps::types::TypeInformation::minimal()
{
    return m_minimal;
}
/*!
 * @brief This function copies the value in member complete
 * @param _complete New value to be copied in member complete
 */
void eprosima::fastrtps::types::TypeInformation::complete(
        const eprosima::fastrtps::types::TypeIdentifierWithDependencies& _complete)
{
    m_complete = _complete;
}

/*!
 * @brief This function moves the value in member complete
 * @param _complete New value to be moved in member complete
 */
void eprosima::fastrtps::types::TypeInformation::complete(
        eprosima::fastrtps::types::TypeIdentifierWithDependencies&& _complete)
{
    m_complete = std::move(_complete);
}

/*!
 * @brief This function returns a constant reference to member complete
 * @return Constant reference to member complete
 */
const eprosima::fastrtps::types::TypeIdentifierWithDependencies& eprosima::fastrtps::types::TypeInformation::complete() const
{
    return m_complete;
}

/*!
 * @brief This function returns a reference to member complete
 * @return Reference to member complete
 */
eprosima::fastrtps::types::TypeIdentifierWithDependencies& eprosima::fastrtps::types::TypeInformation::complete()
{
    return m_complete;
}


size_t eprosima::fastrtps::types::TypeInformation::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_types_TypeInformation_max_key_cdr_typesize;
}

bool eprosima::fastrtps::types::TypeInformation::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::types::TypeInformation::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}





