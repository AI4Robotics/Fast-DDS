// Copyright 2023 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Fast DDS-Gen does not check if the IDL has been included previously.
// #include "XTypesBase.idl"
#include "TypeObjectHashId.idl"

module eprosima {
module fastrtps {
module types {

// Forward declaration
union TypeIdentifier;

// 1 Byte
@extensibility(FINAL) @nested
struct StringSTypeDefn {
    SBound      bound;
};

// 4 Bytes
@extensibility(FINAL) @nested
struct StringLTypeDefn {
    LBound      bound;
};

@extensibility(FINAL) @nested
struct PlainCollectionHeader {
    EquivalenceKind         equiv_kind;
    CollectionElementFlag   element_flags;
};

@extensibility(FINAL) @nested
struct PlainSequenceSElemDefn {
    PlainCollectionHeader       header;
    SBound                      bound;
    @external TypeIdentifier    element_identifier;
};

@extensibility(FINAL) @nested
struct PlainSequenceLElemDefn {
    PlainCollectionHeader       header;
    LBound                      bound;
    @external TypeIdentifier    element_identifier;
};

@extensibility(FINAL) @nested
struct PlainArraySElemDefn {
    PlainCollectionHeader       header;
    SBoundSeq                   array_bound_seq;
    @external TypeIdentifier    element_identifier;
};

@extensibility(FINAL) @nested
struct PlainArrayLElemDefn {
    PlainCollectionHeader       header;
    LBoundSeq                   array_bound_seq;
    @external TypeIdentifier    element_identifier;
};

@extensibility(FINAL) @nested
struct PlainMapSTypeDefn {
    PlainCollectionHeader       header;
    SBound                      bound;
    @external TypeIdentifier    element_identifier;
    CollectionElementFlag       key_flags;
    @external TypeIdentifier    key_identifier;
};

@extensibility(FINAL) @nested
struct PlainMapLTypeDefn {
    PlainCollectionHeader       header;
    LBound                      bound;
    @external TypeIdentifier    element_identifier;
    CollectionElementFlag       key_flags;
    @external TypeIdentifier    key_identifier;
};

// Used for Types that have cyclic depencencies with other types
@extensibility(APPENDABLE) @nested
struct StronglyConnectedComponentId {
    TypeObjectHashId    sc_component_id;    // Hash StronglyConnectedComponent
    long                scc_length;         // StronglyConnectedComponent.length
    long                scc_index ;         // identify type in Strongly Connected Comp.
};

// Future extensibility
@extensibility(MUTABLE) @nested
struct ExtendedTypeDefn {
    // Empty. Available for future extension
};

};
};
};
