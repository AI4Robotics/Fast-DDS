// Copyright 2023 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Fast DDS-Gen does not check if the IDL has been included previously.
// #include "XTypesBase.idl"
#include "TypeIdentifierTypes.idl"

module eprosima {
module fastrtps {
module types {

// The TypeIdentifier uniquely identifies a type (a set of equivalent
// types according to an equivalence relationship: COMPLETE, MNIMAL).
//
// In some cases (primitive types, strings, plain types) the identifier
// is a explicit description of the type.
// In other cases the Identifier is a Hash of the type description
//
// In the case of primitive types and strings the implied equivalence
// relation is the identity.
//
// For Plain Types and Hash-defined TypeIdentifiers there are three
// possibilities: MINIMAL, COMPLETE, and COMMON:
//  - MINIMAL indicates the TypeIdentifier identifies equivalent types
//    according to the MINIMAL equivalence relation
//  - COMPLETE indicates the TypeIdentifier identifies equivalent types
//    according to the COMPLETE equivalence relation
//  - COMMON indicates the TypeIdentifier identifies equivalent types
//    according to both the MINIMAL and the COMMON equivalence relation.
//    This means the TypeIdentifier is the same for both relationships
//
@extensibility(FINAL) @nested
union TypeIdentifier switch (octet) {
    // ============ Primitive types - use TypeKind ====================
    // All primitive types fall here.
    // Commented-out because Unions cannot have cases with no member.
    /*
    case TK_NONE:
    case TK_BOOLEAN:
    case TK_BYTE_TYPE:
    case TK_INT8_TYPE:
    case TK_INT16_TYPE:
    case TK_INT32_TYPE:
    case TK_INT64_TYPE:
    case TK_UINT8_TYPE:
    case TK_UINT16_TYPE:
    case TK_UINT32_TYPE:
    case TK_UINT64_TYPE:
    case TK_FLOAT32_TYPE:
    case TK_FLOAT64_TYPE:
    case TK_FLOAT128_TYPE:
    case TK_CHAR8_TYPE:
    case TK_CHAR16_TYPE:
        // No Value
    */

    // ============ Strings - use TypeIdentifierKind ===================
    case TI_STRING8_SMALL:
    case TI_STRING16_SMALL:
        StringSTypeDefn         string_sdefn;

    case TI_STRING8_LARGE:
    case TI_STRING16_LARGE:
        StringLTypeDefn         string_ldefn;

    // ============ Plain collections - use TypeIdentifierKind =========
    case TI_PLAIN_SEQUENCE_SMALL:
        PlainSequenceSElemDefn  seq_sdefn;
    case TI_PLAIN_SEQUENCE_LARGE:
        PlainSequenceLElemDefn  seq_ldefn;

    case TI_PLAIN_ARRAY_SMALL:
        PlainArraySElemDefn     array_sdefn;
    case TI_PLAIN_ARRAY_LARGE:
        PlainArrayLElemDefn     array_ldefn;

    case TI_PLAIN_MAP_SMALL:
        PlainMapSTypeDefn       map_sdefn;
    case TI_PLAIN_MAP_LARGE:
        PlainMapLTypeDefn       map_ldefn;

    // ============ Types that are mutually dependent on each other ===
    case TI_STRONGLY_CONNECTED_COMPONENT:
        StronglyConnectedComponentId    sc_component_id;

    // ============ The remaining cases - use EquivalenceKind =========
    case EK_COMPLETE:
    case EK_MINIMAL:
        EquivalenceHash         equivalence_hash;

    // =================== Future extensibility ============
    // Future extensions
    default:
        ExtendedTypeDefn        extended_defn;
};
typedef sequence<TypeIdentifier> TypeIdentifierSeq;

};
};
};
